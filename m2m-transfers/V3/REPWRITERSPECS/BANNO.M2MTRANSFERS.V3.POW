[*
**  PowerOn Name:       BANNO.M2MTRANSFERS.V3.POW
**  Letterfile Name:    BANNO.M2MTRANSFERS.V3.CFG
**
**  Copyright 2021-2023 Jack Henry and Associates
**
**  This Banno PowerOn allows the user to perform a transfer
**  (immediate or scheduled) to another CU member
**
**  For more information check
**  https://github.com/Banno/banno-powerons
**
**  Banno is not responsible for any modifications to this file
**  made by unauthorized personnel.
**
**  Modification History:
**   Ver. 1.0.0  07/21/21 T. Kainz - Original Programming
**   Ver. 1.1.0  10/11/21 T. Kainz - Adding check for service code for
**               transfer in on credited share. Added check for IRS code
**               on credited share - must be 0. Added parameter options
**               to allow transfers into clubs or certs. Corrected issue
**               preventing recurring transfers to loans. Set debugmode
**               to on as default for first 45 days after latest update.
**               Removed ability for the user to send funds to account
**               type only, now requiring a specific share or loan ID
**   Ver. 1.1.1  12/03/21 T. Kainz - Corrected transfer locator format
**               issue in JSON output when locator is over 999. Added
**               S/L ID Length to JSON output. Added procedure to
**               normalize S/L ID length. Added check for same account
**               transfer (not allowed). If tran counts are being
**               enforced, and transfer initiated on system date is
**               deleted (expired) or edited, adjust transfer count and
**               transfer amount total accordingly. Added immed. transfer
**               comment parameter.
**   Ver. 1.1.2  3/28/2022 J. Carson - Corrected issue with CREATETRANSFER
**               procedure where a stale transfer record is created if the
**               start date is before the system date (GOODNIGHT has changed
**               the date before midnight). Fix will perform an immediate
**               transfer in that case.
**   Ver. 1.1.3  03/29/2022 T. Kainz - Corrected issue where a saved
**               recipient with a loan as a target was being recalled
**               as a share
**   Ver. 3.0.0  10/10/2022 T. Kainz
**               * Program ver. bumped to v 3.0.0 to correspond with UX
**                 version update to v3.
**               * Added JSON flag for cross-accounts for UX use.
**               * Modified logic determining if a transfer is immediate or
**                  scheduled based upon UX request.
**               * Added Reg E flag to be set to true for immediate transfer
**               * Added Share transfer user created check to logic determining
**                  whether to allow edit of manually created share transfers.
**   Ver. 3.1.0  04/19/2023 R. Robison - Added support for label soft text on
**               the member name and id input.  These labels are for the sub-title
**               text under the main labels.
**   Ver. 3.2.0  11/02/2023 R. Robison - Code refactor including framework for
**               the optional share ID feature.
**   Ver. 3.2.1  11/06/2023 T. Kainz -
**               * Corrected issue where cross-account loans were being allowed
**                 when only shares were requested.
**               * Updated last name verification to properly process last names
**                 stored with one or more spaces at the beginning.
**
**  DO NOT MODIFY THIS FILE UNLESS YOU KNOW WHAT YOU'RE DOING!
*]
SYMCONNECT
STATELESS

TARGET=ACCOUNT

DEFINE
 #INCLUDE "RD.GETDATA.DEF"
 #INCLUDE "RB.LISTEXPAND.DEF"
 #INCLUDE "BNO.INTERACTIVE.DEF"

 TRUE                      = 1
 FALSE                     = 0
 CONFIGFILENAME            = "BANNO.M2MTRANSFERS.V3.CFG"

 STATEPRELOADDATA          = "PRELOADDATA"
 STATEVERIFYMEMBER         = "VERIFYMEMBER"
 STATECREATETRAN           = "CREATETRAN"
 STATEEDITTRAN             = "EDITTRAN"
 STATEDELETERECIP          = "DELETERECIP"
 STATEDELETETRAN           = "DELETETRAN"
 STATEEND                  = "STATEEND"
 DATENULL                  = '--/--/--'

 ACTUALLAST3               = CHARACTER
 BASEINDENT                = NUMBER
 BNODEBUGCOUNT             = NUMBER
 BNODEBUGMSG               = CHARACTER
 BNODEBUGMSGLIST           = CHARACTER ARRAY(199)
 BNODEBUGMSGMAX            = 199
 CAC                       = CHARACTER
 CN                        = CHARACTER
 DATAFIELDCOUNT            = NUMBER
 DATALINE                  = CHARACTER
 DATALINEFIELD             = CHARACTER ARRAY(10)
 DATALINEFIELDMAX          = 10
 DEBUGLOOP                 = NUMBER
 DEBUGMODE                 = NUMBER
 DEBUGMODEOFF              = 0
 DEBUGMODEON               = 1
 ERRORCODE                 = NUMBER
 ERRORDETAIL               = CHARACTER ARRAY(99)
 ERRORDETAILOFFSET         = NUMBER
 ERRORMSG                  = CHARACTER
 EXTACCTNUM                = CHARACTER
 EXTEXPIRE                 = DATE
 EXTFINAME                 = CHARACTER
 EXTPRIMARY                = CHARACTER
 EXTRECFOUND               = NUMBER
 EXTSTATUS                 = NUMBER
 FALSECHR                  = "false"
 FMERROR                   = CHARACTER
 FREQLOOP                  = NUMBER
 I                         = NUMBER
 IDTYPETOCHR               = CHARACTER ARRAY(3)
 INCLUDEPROGRAMINFO        = NUMBER
 INDENT                    = CHARACTER ARRAY(19)
 INDENTMAX                 = 19
 INVALIDACCTTYPEFOUND      = NUMBER
 INVALIDACCTYPES           = NUMBER ARRAY(9999)
 LASTMODDATE               = DATE
 LASTMODTIME               = CHARACTER
 LFERROR                   = CHARACTER
 LFLINE                    = CHARACTER
 LFNUMBER                  = NUMBER
 MAXWARNINGTYPES           = NUMBER
 MBRAMOUNTACTUAL           = MONEY
 MBRAMOUNTACTUALCHR        = CHARACTER
 MBRAMOUNTLIMIT            = MONEY
 MBRAMOUNTLIMITCALC        = MONEY
 MBRAMOUNTLIMITCALCCHR     = CHARACTER
 MBRAMOUNTLIMITCHR         = CHARACTER
 MBRCOUNTACTUAL            = NUMBER
 MBRCOUNTACTUALCHR         = CHARACTER
 MBRCOUNTLIMIT             = NUMBER
 MBRCOUNTLIMITCALC         = NUMBER
 MBRCOUNTLIMITCALCCHR      = CHARACTER
 MBRCOUNTLIMITCHR          = CHARACTER
 MBRINDIVIDUALLIMIT        = MONEY
 MBRINDIVIDUALLIMITCHR     = CHARACTER
 MBRINDIVLIMITCALC         = MONEY
 MBRINDIVLIMITCALCCHR      = CHARACTER
 MBRLASTTRANDATE           = DATE
 NAMEFOUND                 = NUMBER
 NEWLASTTRANDATE           = DATE
 NEWRECIPACCTLOC           = NUMBER
 NEWSLTRANSFERLOC          = NUMBER
 NEWTRANAMOUNT             = MONEY
 NEWTRANCOMMENT            = CHARACTER
 NEWTRANDAY1               = NUMBER
 NEWTRANDAY2               = NUMBER
 NEWTRANFIRST3             = CHARACTER
 NEWTRANFREQ               = NUMBER
 NEWTRANFREQCHR            = CHARACTER
 NEWTRANFREQFOUND          = NUMBER
 NEWTRANNICKNAME           = CHARACTER
 NEWTRANRECIPACCT          = CHARACTER
 NEWTRANRECIPLOC           = NUMBER
 NEWTRANRECIPLONGNAME      = CHARACTER
 NEWTRANRECIPSLID          = CHARACTER
 NEWTRANRECIPSLIDFOUND     = CHARACTER
 NEWTRANRECIPSLIDTYPE      = NUMBER
 NEWTRANRECIPSLIDTYPEFOUND = CHARACTER
 NEWTRANSLDESCRIPTION      = CHARACTER
 NEWTRANSOURCE             = CHARACTER
 NEWTRANSRCACCT            = CHARACTER
 NEWTRANSRCAMOUNT          = MONEY
 NEWTRANSRCID              = CHARACTER
 NEWTRANSRCIDTYPE          = CHARACTER
 NEWTRANSTARTDATE          = DATE
 NEWXFERAMOUNT             = MONEY
 NEWXFERCOUNT              = NUMBER
 TRANSFERCREATEDATE        = DATE
 TRANSFERCREATEUSER        = NUMBER
 PA3FOUND                  = NUMBER
 PAACCOUNTTEST             = CHARACTER

 PARAMALLOWEDIT            = NUMBER
 PARAMCROSSACCTACCESS      = NUMBER
 PARAMENFORCELIMITS        = NUMBER
 PARAMINELIGIBLEACCTS      = CHARACTER
 PARAMINSTAMOUNTLIMIT      = MONEY
 PARAMINSTCOUNTLIMIT       = NUMBER
 PARAMINSTINDIVLIMIT       = MONEY
 PARAMMEMOMODE             = NUMBER
 PARAMNAME                 = CHARACTER
 PARAMNTSLTYPE             = NUMBER
 PARAMVALIDATIONERROR      = NUMBER
 PARAMVALIDATIONNAMETYPES  = CHARACTER
 PARAMVALUE                = CHARACTER
 PARAMWARNINGSACCT         = CHARACTER
 PARAMALLOWABLESHARECODES  = NUMBER ARRAY(3)
 PARAMALLOWCLUBS           = NUMBER
 PARAMALLOWCERTS           = NUMBER
 PARAMSIDOPTIONAL          = NUMBER
 PARAMTRANCOMMENT          = CHARACTER
 PARAMIDLENTEST            = NUMBER
 PARAMLBLMEMBERNAME        = CHARACTER(80)
 PARAMLBLID                = CHARACTER(80)
 PARAMTESTMODE             = NUMBER
 PARAMTESTACCTLIST         = CHARACTER

 PASLIDTEST                = CHARACTER
 PASLIDTYPETEST            = NUMBER
 POS                       = NUMBER
 PREFACCESSMATCH           = NUMBER
 PREFFOUND                 = NUMBER
 PREFLOC                   = NUMBER
 PREFUPDATEERROR           = CHARACTER
 PROGRAMUPDATENOTE1        = CHARACTER
 PROGRAMUPDATENOTE2        = CHARACTER
 READCONFIGERROR           = NUMBER
 READCONFIGERRORMSG        = CHARACTER
 RECIPACCOUNT              = CHARACTER ARRAY(99)
 RECIPCOUNT                = NUMBER
 RECIPEXPIREDATE           = DATE
 RECIPFOUND                = NUMBER
 RECIPINDEX                = NUMBER
 RECIPLASTUNEXPIREDINDEX   = NUMBER
 RECIPLISTEXPIREDATE       = DATE ARRAY(99)
 RECIPLOC                  = NUMBER ARRAY(99)
 RECIPLOCATOR              = NUMBER
 RECIPMAX                  = 99
 RECIPNAME                 = CHARACTER ARRAY(99)
 RECIPNICKNAME             = CHARACTER ARRAY(99)
 RESETPREFVALUES           = NUMBER
 SEQ1                      = NUMBER
 SEQ2                      = NUMBER
 SERVICEIN                 = NUMBER ARRAY(99)
 SLFOUND                   = NUMBER
 SLIDLEN                   = NUMBER
 SLLOOP                    = NUMBER
 SLTRANSFERFOUND           = NUMBER
 SYMXCLIENTNUM             = NUMBER
 SYMXINSTANCE              = NUMBER
 SYSTEMMEMOMODE            = NUMBER
 TARGETACCOUNT             = CHARACTER
 TARGETACCTCLOSEDATE       = DATE
 TARGETACCTTYPE            = CHARACTER
 TARGETSLCLOSECODATE       = DATE
 TARGETSLID                = CHARACTER
 TARGETSLTRANLOC           = NUMBER
 TARGETVERIFY3             = CHARACTER
 TESTCHR                   = CHARACTER
 TESTLOOP                  = NUMBER
 TESTNAME                  = CHARACTER
 THISACCOUNT               = CHARACTER
 TMPAMTCHR                 = CHARACTER
 TMPCHR                    = CHARACTER
 TMPDATE                   = DATE
 TMPEXPIREDATE             = DATE
 TMPLOOP                   = NUMBER
 TMPNUM                    = NUMBER
 TMPSID                    = CHARACTER
 TMPSLID                   = CHARACTER
 TRANACCOUNTNAME           = CHARACTER ARRAY(99)
 TRANCOUNT                 = NUMBER
 TRANCOUNTMAX              = 99
 TRANDAY1                  = NUMBER ARRAY(99)
 TRANDAY2                  = NUMBER ARRAY(99)
 TRANERROR                 = CHARACTER
 TRANFREQALT               = 1
 TRANFREQSTD               = 0
 TRANFREQUENCY             = NUMBER ARRAY(99)
 TRANLOC                   = NUMBER ARRAY(99)
 TRANCREATEDATE            = DATE ARRAY(99)
 TRANCREATEUSER            = NUMBER ARRAY(99)
 TRANNEXTTRANDATE          = DATE ARRAY(99)
 TRANREADONLYSTATUS        = CHARACTER ARRAY(99)
 TRANRECIPACCT             = CHARACTER ARRAY(99)
 TRANRECIPACCTID           = CHARACTER ARRAY(99)
 TRANRECIPACCTTYPE         = CHARACTER ARRAY(99)
 TRANRECIPEXPIREDATE       = DATE ARRAY(99)
 TRANRECIPMBRID            = CHARACTER ARRAY(99)
 TRANRECIPNAME             = CHARACTER ARRAY(99)
 TRANRECIPNICKNAME         = CHARACTER ARRAY(99)
 TRANRECIPTYPECHR          = CHARACTER ARRAY(5)
 TRANSFERFREQCHR           = CHARACTER ARRAY(1,15)
 TRANSFERFREQMAX           = 14
 TRANSOURCEACCT            = CHARACTER ARRAY(99)
 TRANSTARTDATE             = DATE ARRAY(99)
 TRANTYPE                  = NUMBER
 TRANTYPEIMMEDIATE         = 1
 TRANTYPEREGULAR           = 0
 TRANXFERAMOUNT            = MONEY ARRAY(99)
 TRUEFALSECHR              = CHARACTER ARRAY(1)
 VALIDACCOUNT              = NUMBER
 VALIDCHRINPUT1            = CHARACTER
 VALIDPARAMS               = NUMBER
 VALIDRANGEINPUT           = NUMBER
 WARNINGFOUND              = NUMBER
 WARNINGSACCT              = NUMBER ARRAY(999)

 TMPLOCATOR                = NUMBER
 VALIDDATA                 = NUMBER
 VALIDACCTNUM              = NUMBER
 TMPACCT                   = CHARACTER
 NLTSCHR                   = CHARACTER
 VALIDLIMITSEXCEEDED       = NUMBER
 SVCCODEFOUND              = NUMBER
 SVCCODEMAX                = 99
 SHARECODESAVINGS          = 0
 SHARECODEDRAFT            = 1
 SHARECODECERT             = 2
 SHARECODECLUB             = 3
 SHARECODEMAX              = 3
 TARGETSLIDFOUND           = NUMBER
 AUTODEBUGDAYS             = 45
 FOUND                     = NUMBER
 TESTIDLENGTH2             = 2
 TESTIDLENGTH4             = 4
 TMPCOMMENT1               = CHARACTER
 TMPAMOUNT                 = MONEY
 TRANCREATEDATEFOUND       = NUMBER
 TARGETTRANSFERLOC         = NUMBER
 PROGRAMVERSION            = CHARACTER

 BNOTRUEFALSECHR           = CHARACTER ARRAY(2)
 CROSSACCTFLAG             = NUMBER
 SOONESTAVAILABLE          = NUMBER
 VALIDATESTATUS            = NUMBER
 FINDSHARECODE             = NUMBER

 TARGETVERIFIED            = 0
 TARGETSAMEACCT            = 1
 TARGETACCTNOTFOUND        = 2
 TARGETACCTCLOSED          = 3
 TARGETSLCLOSED            = 4
 TARGETNAMENOMATCH         = 5
 TARGETNOTFOUNDBYSLID      = 6
 TARGETNOTFOUNDBYTYPE      = 7
 TARGETNOSERVICECODE       = 8
 TARGETINVALIDSLTYPE       = 9
 TARGETINVALIDSHARECODE    = 10
 TARGETLOANZEROPAYOFF      = 11
 TARGETINVALIDIRSCODE      = 12
END [DEFINE]

SETUP
 #INCLUDE "BNO.INTERACTIVE.INIT"

 INCLUDEPROGRAMINFO        = TRUE
 PROGRAMVERSION            = "3.2.0"
 LASTMODDATE               = '11/02/2023'
 LASTMODTIME               = "17:00 MT"
 PROGRAMUPDATENOTE1        = "some code refactor"
 PROGRAMUPDATENOTE2        = ""
 NTSLTYPE                  = NTSLTYPESHARELOAN
 NTCROSSACCTACCESS         = TRUE
 NTACCESSTYPE              = NTACCESSTYPEIQ
 NTSLCODE(NTSHARECODESHARE)= TRUE
 NTSLCODE(NTSHARECODEDRAFT)= TRUE
 NTSLCODE(NTSHARECODECERTIFICATE)=TRUE
 NTSLCODE(NTSHARECODECLUB) = TRUE
 NTSYCCLIENTNUMBER         = @CLIENTNUMBER
 NTCROSSACCTFLAG           = FALSE
 NTACCOUNTMASKFLAG         = FALSE
 NTACCOUNTMASK             = "1111111111"
 NTAVAILCALCMETHOD         = 0
 NTNAMEINCROSSACCTDISPLAY  = FALSE
 NTEXTLOANMASKFLAG         = FALSE
 FOR NTI=1 TO NTEXTLOANTYPESMAX
  DO
   NTEXTLOANTYPESMASK(NTI)="11111111111111111111"
  END

 NTSERVICELISTSETFLAG      = FALSE
 NTEXCLUDESHARELISTSETFLAG = FALSE
 NTEXCLUDELOANLISTSETFLAG  = FALSE
 NTSTOPPMTSHARELISTSETFLAG = FALSE
 NTSTOPPMTLOANLISTSETFLAG  = FALSE
 NTCLOSEDSHARELISTSETFLAG  = FALSE
 NTCLOSEDLOANLISTSETFLAG   = FALSE

 TRANRECIPTYPECHR(0)       = "savings"
 TRANRECIPTYPECHR(1)       = "checking"
 TRANRECIPTYPECHR(2)       = "certificate"
 TRANRECIPTYPECHR(3)       = "club"
 TRANRECIPTYPECHR(4)       = "loan"

 Q                         = CTRLCHR(34)
 SYSTEMMEMOMODE            = SYSMEMOMODE

 VALIDCHRINPUT1            = "32-126,128-175,181-184,189,190,198,199,208-216,221,222,224-253"
 FOR TMPLOOP=1 TO INDENTMAX
  DO
   INDENT(TMPLOOP)=REPEATCHR(" ",TMPLOOP*2)
  END
 TRUEFALSECHR(TRUE)        = "true"
 TRUEFALSECHR(FALSE)       = "false"
 DEBUGMODE                 = DEBUGMODEOFF
 MAXWARNINGTYPES           = 999

 IDTYPETOCHR(0)            = "S"
 IDTYPETOCHR(1)            = "L"

 SLIDLEN                   = GETDATANUMBER(GETPARAMIDLENGTH)

[*the followowing freq refreences are defined twice because there are some differences
** between Episys and Banno in the frequency type declarations.
*]
 TRANSFERFREQCHR(TRANFREQSTD,0)="demand"
 TRANSFERFREQCHR(TRANFREQALT,0)="once"

 TRANSFERFREQCHR(TRANFREQSTD,1)="annual"
 TRANSFERFREQCHR(TRANFREQALT,1)=""

 TRANSFERFREQCHR(TRANFREQSTD,2)="semi-annual"
 TRANSFERFREQCHR(TRANFREQALT,2)=""

 TRANSFERFREQCHR(TRANFREQSTD,3)="quarterly"
 TRANSFERFREQCHR(TRANFREQALT,3)=""

 TRANSFERFREQCHR(TRANFREQSTD,4)="monthly"
 TRANSFERFREQCHR(TRANFREQALT,4)="monthly"

 TRANSFERFREQCHR(TRANFREQSTD,5)="semi-monthly"
 TRANSFERFREQCHR(TRANFREQALT,5)="semiMonthly"

 TRANSFERFREQCHR(TRANFREQSTD,6)="biweekly skip-first"
 TRANSFERFREQCHR(TRANFREQALT,6)=""

 TRANSFERFREQCHR(TRANFREQSTD,7)="biweekly skip-last"
 TRANSFERFREQCHR(TRANFREQALT,7)=""

 TRANSFERFREQCHR(TRANFREQSTD,8)="biweekly"
 TRANSFERFREQCHR(TRANFREQALT,8)="biWeekly"

 TRANSFERFREQCHR(TRANFREQSTD,9)="weekly"
 TRANSFERFREQCHR(TRANFREQALT,9)="weekly"

 TRANSFERFREQCHR(TRANFREQSTD,10)="immediate"
 TRANSFERFREQCHR(TRANFREQALT,10)="immediate"

 TRANSFERFREQCHR(TRANFREQSTD,11)="weekly skip-first"
 TRANSFERFREQCHR(TRANFREQALT,11)=""

 TRANSFERFREQCHR(TRANFREQSTD,12)="weekly skip-last"
 TRANSFERFREQCHR(TRANFREQALT,12)=""

 TRANSFERFREQCHR(TRANFREQSTD,13)="bimonthly"
 TRANSFERFREQCHR(TRANFREQALT,13)=""

 BNOTRUEFALSECHR(FALSE)="false"
 BNOTRUEFALSECHR(TRUE)="true"
END [SETUP]

PRINT TITLE=""
 CALL INITIALIZEDATA
 CALL SETMEMOMODE
 CALL READCONFIGFILESETTINGS
 IF ERRORCODE=0 THEN
  CALL CHECKFORPA3

[*If system is not in memo mode, continue
*]
 IF @RGSTATE=STATEPRELOADDATA THEN
  DO
   CALL READPREFSETTINGS

   IF PARAMENFORCELIMITS=TRUE AND
    ((PARAMINSTCOUNTLIMIT=0 AND MBRCOUNTLIMIT=0) OR
     (PARAMINSTAMOUNTLIMIT=$0.00 AND MBRAMOUNTLIMIT=$0.00) OR
      PARAMINSTINDIVLIMIT=$0.00 AND MBRINDIVIDUALLIMIT=$0.00) THEN
    DO
     NEWLINE
     CALL JSONOPEN
     CALL PRINTPROGRAMINFO
     ERRORCODE=501
     CALL ERRORHANDLER
     @RGSTATE=STATEEND
    END
   IF ERRORCODE=0 THEN
    CALL VALIDATEACCOUNT

   IF ERRORCODE=0 THEN
    DO
     CALL CALCLIMITS
     IF ERRORCODE=0 THEN
      DO
       CALL BUILDSHARELOANLIST

       IF NTSHARECOUNT=0 AND
          NTLOANCOUNT=0 THEN
        DO
         NEWLINE
         CALL JSONOPEN
         CALL PRINTPROGRAMINFO
         ERRORCODE=502
         CALL ERRORHANDLER
         @RGSTATE=STATEEND
        END
       IF ERRORCODE=0 THEN
        DO

         CALL BUILDRECIPLIST
         CALL BUILDSLTRANSFERLIST
         BASEINDENT=0
         CALL JSONOPEN
         CALL PRINTPROGRAMINFO
         CALL PRINTCURRENTSTATE
        END
      END
    END
  END
 ELSE IF @RGSTATE=STATEVERIFYMEMBER THEN
  DO
   CALL PULLRGDATA
   CALL VALIDATETARGETACCOUNT
   IF VALIDATESTATUS=TARGETVERIFIED THEN
    DO
     PRINT "{"
     NEWLINE
     PRINT "  "+Q+"results"+Q+": {"
     NEWLINE
     PRINT "    "+Q+"verified"+Q+": true,"
     NEWLINE
     PRINT "    "+Q+"recipientAccountId"+Q+": "+Q+TARGETSLID+Q
     NEWLINE
     PRINT "  }"
     NEWLINE
    END
   ELSE
    DO
     NEWLINE
     CALL JSONOPEN
     CALL PRINTPROGRAMINFO
     ERRORCODE=509
     CALL ERRORHANDLER

     @RGSTATE=STATEEND
    END
  END
 ELSE IF @RGSTATE=STATECREATETRAN THEN
  DO
   CALL PULLRGDATA
   IF TARGETSLIDFOUND=TRUE AND
      NEWTRANRECIPSLIDTYPEFOUND<>"" AND
      NEWTRANRECIPSLIDFOUND<>"" THEN
    DO
     CALL CREATETRANSFER
     IF VALIDLIMITSEXCEEDED=TRUE OR
        TRANERROR<>"" THEN
      DO
       CALL JSONOPEN
       CALL PRINTPROGRAMINFO
       PRINT INDENT(BASEINDENT+2)+Q+"results"+Q+": {"
       NEWLINE

       IF VALIDLIMITSEXCEEDED=TRUE THEN
        ERRORCODE=505
       ELSE
        ERRORCODE=507
       CALL ERRORHANDLER
       PRINT INDENT(BASEINDENT+1)+"}"
       NEWLINE
       @RGSTATE=STATEEND
      END
     ELSE
      DO
       IF PARAMENFORCELIMITS=TRUE THEN
        CALL UPDATEPREFTOTALS
       IF NEWTRANRECIPLOC=0 THEN
        CALL CREATERECIPACCT
       BASEINDENT=2
       CALL JSONOUTTRANSUCCESS
       NEWLINE
      END
    END
   ELSE
    DO
     CALL JSONOPEN
     CALL PRINTPROGRAMINFO
     ERRORCODE=507
     CALL ERRORHANDLER
     @RGSTATE=STATEEND
    END
  END
 ELSE IF @RGSTATE=STATEEDITTRAN THEN
  DO
   CALL PULLRGDATA
   IF ERRORCODE=0 THEN
    DO
[* check for amounts before expiration process to avoid issues
** where transfer is expired but new transfer cannot be created due to limits.
*]
     VALIDLIMITSEXCEEDED=FALSE
     IF PARAMENFORCELIMITS=TRUE THEN
      DO
       CALL SETUPLIMITS
       TMPAMOUNT=MBRAMOUNTACTUAL-NEWTRANSRCAMOUNT+NEWTRANAMOUNT
       IF TMPAMOUNT>MBRAMOUNTLIMITCALC OR
          NEWTRANAMOUNT>MBRINDIVLIMITCALC THEN
        VALIDLIMITSEXCEEDED=TRUE
      END

     IF VALIDLIMITSEXCEEDED=TRUE THEN
      DO
       CALL JSONOPEN
       CALL PRINTPROGRAMINFO
       ERRORCODE=511
       CALL ERRORHANDLER
       @RGSTATE=STATEEND
      END
     ELSE
      DO
       CALL EXPIREEXISTINGXFER
       IF ERRORCODE=0 THEN
        DO
         CALL CREATETRANSFER
         IF TRANERROR <>"" THEN
          DO
           CALL JSONOPEN
           CALL PRINTPROGRAMINFO
           ERRORCODE=507
           CALL ERRORHANDLER
           @RGSTATE=STATEEND
          END
         ELSE
          DO
           IF PARAMENFORCELIMITS=TRUE THEN
            CALL UPDATEPREFTOTALS
           BASEINDENT=2
           CALL JSONOUTTRANSUCCESS
          END
        END [IF ERRORCODE=0 THEN...]
      END
    END
  END
 ELSE IF @RGSTATE=STATEDELETERECIP THEN
  DO
   CALL PULLRGDATA
   CALL EXPIRERECIPIENT
  END
 ELSE IF @RGSTATE=STATEDELETETRAN THEN
  DO
   CALL PULLRGDATA
   CALL EXPIREEXISTINGXFER
  END

 CALL BNOPRINTDEBUG
 IF DEBUGMODE=DEBUGMODEOFF THEN
  NEWLINE
 PRINT INDENT(0)+"}"
 NEWLINE
END [PRINT]

PROCEDURE VALIDATETARGETACCOUNT
[*
]
 BNODEBUGMSG="PROCEDURE VALIDATETARGETACCOUNT - TARGETING - "+
             "ACCT "+TARGETACCOUNT+"  ACCT TYPE:"+
              UPPERCASE(TARGETACCTTYPE)+"  "+
             "TARGETSLID="+TARGETSLID
 CALL BNODEBUGMSGADD

 VALIDATESTATUS=TARGETVERIFIED

 IF TARGETACCOUNT=THISACCOUNT THEN
  VALIDATESTATUS=TARGETSAMEACCT

 IF VALIDATESTATUS=TARGETVERIFIED THEN
  DO
   VALIDATESTATUS=TARGETACCTNOTFOUND
   FOR ACCOUNT TARGETACCOUNT
    DO
     VALIDATESTATUS=TARGETVERIFIED
     TARGETACCTCLOSEDATE=ACCOUNT:CLOSEDATE
     IF TARGETACCTCLOSEDATE<>DATENULL THEN
      VALIDATESTATUS=TARGETACCTCLOSED

[* Validate the first three characters of the last name against eligible name records.
*]
     IF VALIDATESTATUS=TARGETVERIFIED THEN
      DO
       NAMEFOUND=FALSE
       FOR EACH NAME WITH (CHARACTERSEARCH(PARAMVALIDATIONNAMETYPES,FORMAT("99",NAME:TYPE))>0)
        DO
         TESTNAME=NAME:LAST
         CALL VALIDATENAME
        END
       UNTIL NAMEFOUND=TRUE

       IF NAMEFOUND=FALSE THEN
        VALIDATESTATUS=TARGETNAMENOMATCH

       BNODEBUGMSG=FORMAT("END OF NAME CHECK - NAME FOUND:9",NAMEFOUND)
       CALL BNODEBUGMSGADD
      END

[*Attempt to validate the share/loan account type and share/loan ID
*]

     IF UPPERCASE(TARGETACCTTYPE)<>"SHARE" AND
        UPPERCASE(TARGETACCTTYPE)<>"LOAN" THEN
      VALIDATESTATUS=TARGETINVALIDSLTYPE

     IF VALIDATESTATUS=TARGETVERIFIED AND
        UPPERCASE(TARGETACCTTYPE)="SHARE" AND
        TARGETSLID<>"" THEN
      DO
       SLFOUND=FALSE
       FOR EACH SHARE WITH (SHARE:ID=TARGETSLID)
        DO
         SLFOUND=TRUE
         IF SHARE:CLOSEDATE<>DATENULL OR SHARE:CHARGEOFFDATE<>DATENULL THEN
          DO
           VALIDATESTATUS=TARGETSLCLOSED
           IF SHARE:CLOSEDATE<>DATENULL THEN
            TARGETSLCLOSECODATE=SHARE:CLOSEDATE
           ELSE IF SHARE:CHARGEOFFDATE<>DATENULL THEN
            TARGETSLCLOSECODATE=SHARE:CHARGEOFFDATE
          END
         ELSE IF PARAMALLOWABLESHARECODES(SHARE:SHARECODE)=FALSE THEN
          VALIDATESTATUS=TARGETINVALIDSHARECODE
         ELSE IF SHARE:IRSCODE<>0 THEN
          VALIDATESTATUS=TARGETINVALIDIRSCODE


         IF VALIDATESTATUS=TARGETVERIFIED THEN
          DO
           SVCCODEFOUND=FALSE
           TMPLOOP=1
           WHILE TMPLOOP<=SVCCODEMAX AND SVCCODEFOUND=FALSE
            DO
             IF SERVICEIN(TMPLOOP)=TRUE AND ANYSERVICE(SHARE,TMPLOOP) THEN
              SVCCODEFOUND=TRUE

             TMPLOOP=TMPLOOP+1
            END
           IF SVCCODEFOUND=FALSE THEN
            VALIDATESTATUS=TARGETNOSERVICECODE
          END
        END
       UNTIL SLFOUND=TRUE

       IF SLFOUND=FALSE THEN
        VALIDATESTATUS=TARGETNOTFOUNDBYSLID
      END

     IF VALIDATESTATUS=TARGETVERIFIED AND
        UPPERCASE(TARGETACCTTYPE)="SHARE" AND
        TARGETSLID="" THEN
      DO
       CALL FINDBYACCTTYPESHARE
       IF SLFOUND=FALSE THEN
        VALIDATESTATUS=TARGETNOTFOUNDBYTYPE
      END

     IF VALIDATESTATUS=TARGETVERIFIED AND
        UPPERCASE(TARGETACCTTYPE)="LOAN" THEN
      DO
       SLFOUND=FALSE
       FOR EACH LOAN WITH (LOAN:ID=TARGETSLID)
        DO
         SLFOUND=TRUE
         IF LOAN:CLOSEDATE<>DATENULL OR LOAN:CHARGEOFFDATE<>DATENULL THEN
          DO
           VALIDATESTATUS=TARGETSLCLOSED
           IF LOAN:CLOSEDATE<>DATENULL THEN
            TARGETSLCLOSECODATE=LOAN:CLOSEDATE
           ELSE IF LOAN:CHARGEOFFDATE<>DATENULL THEN
            TARGETSLCLOSECODATE=LOAN:CHARGEOFFDATE
          END
         ELSE IF LOAN:PAYOFFAMOUNT<=$0.00 THEN
          VALIDATESTATUS=TARGETLOANZEROPAYOFF

         IF VALIDATESTATUS=TARGETVERIFIED THEN
          DO
           SVCCODEFOUND=FALSE
           TMPLOOP=1
           WHILE TMPLOOP<=SVCCODEMAX AND SVCCODEFOUND=FALSE
            DO
             IF SERVICEIN(TMPLOOP)=TRUE AND ANYSERVICE(LOAN,TMPLOOP) THEN
              SVCCODEFOUND=TRUE

             TMPLOOP=TMPLOOP+1
            END
           IF SVCCODEFOUND=FALSE THEN
            VALIDATESTATUS=TARGETNOSERVICECODE
           ELSE
            DO
             BNODEBUGMSG="Loan ID found - BY TARGET TYPE: "+LOAN:ID
             CALL BNODEBUGMSGADD
            END
          END
        END
       UNTIL SLFOUND=TRUE

       IF SLFOUND=FALSE THEN
        VALIDATESTATUS=TARGETNOTFOUNDBYSLID
      END
    END [FOR ACCOUNT]
  END

 BNODEBUGMSG=" END OF VALIDATETARGETACCOUNT - "+FORMAT("VALIDATESTATUS:99",VALIDATESTATUS)
 CALL BNODEBUGMSGADD

END [PROCEDURE]

PROCEDURE FINDBYACCTTYPESHARE
[*this procedure contains custom logic for finding the share account if the option share ID feature is enabled.
*]
 SLFOUND=FALSE
[
 FINDSHARECODE=1
 IF PARAMALLOWABLESHARECODES(FINDSHARECODE)=TRUE THEN
  CALL FINDBYSHARECODE
 FINDSHARECODE=0
 IF SLFOUND=FALSE AND
    PARAMALLOWABLESHARECODES(FINDSHARECODE)=TRUE THEN
  CALL FINDBYSHARECODE
]
END

PROCEDURE FINDBYSHARECODE

 SLFOUND=FALSE
 FOR EACH SHARE WITH (SHARE:CLOSEDATE=DATENULL AND
                      SHARE:CHARGEOFFDATE=DATENULL AND
                      SHARE:SHARECODE=FINDSHARECODE AND
                      SHARE:IRSCODE=0)
  DO
   TMPLOOP=1
   WHILE TMPLOOP<=SVCCODEMAX AND SLFOUND=FALSE
    DO
     IF SERVICEIN(TMPLOOP)=TRUE AND ANYSERVICE(SHARE,TMPLOOP) THEN
      DO
       SLFOUND=TRUE
       TARGETSLID=SHARE:ID
      END
     TMPLOOP=TMPLOOP+1
    END
  END
 UNTIL SLFOUND=TRUE
END

PROCEDURE VALIDATENAME
[* Validate the primary member's last name against user input
** PASS    TESTNAME   target account last name
** RETURN  NAMEFOUND  BOOLOEAN name found?
*]
 NLTSCHR=TESTNAME
 CALL NLS
 TESTNAME=NLTSCHR

 ACTUALLAST3=UPPERCASE(SEGMENT(TESTNAME,1,3))
 IF ACTUALLAST3=TARGETVERIFY3 THEN
  NAMEFOUND=TRUE
END [PROCEDURE]

PROCEDURE JSONOUTTRANSUCCESS
[* Generate JSON output for a successful transaction.
*]

 PRINT INDENT(BASEINDENT+0)+"{"
 NEWLINE
 CALL PRINTPROGRAMINFO
 PRINT INDENT(BASEINDENT+1)+Q+"history"+Q+": {"
 NEWLINE
 PRINT INDENT(BASEINDENT+2)+Q+"change"+Q+": {"
 NEWLINE
 PRINT INDENT(BASEINDENT+3)+Q+"application"+Q+": "+Q+"member-to-member-transfers-poweron"+Q+","
 NEWLINE
 IF @RGSTATE=STATECREATETRAN THEN
  DO
   IF TRANTYPE=TRANTYPEIMMEDIATE THEN
    PRINT INDENT(BASEINDENT+3)+Q+"name"+Q+": "+Q+"MemberToMemberTransferScheduled"+Q+","
   ELSE
    PRINT INDENT(BASEINDENT+3)+Q+"name"+Q+": "+Q+"MemberToMemberTransferScheduled"+Q+","
   NEWLINE

  END
 ELSE IF @RGSTATE=STATEDELETETRAN THEN
  DO
   PRINT INDENT(BASEINDENT+3)+Q+"name"+Q+": "+Q+"MemberToMemberTransferDeleted"+Q+","
   NEWLINE
  END
 ELSE IF @RGSTATE=STATEEDITTRAN THEN
  DO
   PRINT INDENT(BASEINDENT+3)+Q+"name"+Q+": "+Q+"MemberToMemberTransferUpdated"+Q+","
   NEWLINE
  END

 PRINT INDENT(BASEINDENT+3)+Q+"toMemberName"+Q+": "+Q+NEWTRANRECIPLONGNAME+Q+","
 NEWLINE
 NLTSCHR=FORMAT("##########9.99",NEWTRANAMOUNT)
 CALL NLS
 PRINT INDENT(BASEINDENT+3)+Q+"amount"+Q+": "+NLTSCHR+","
 NEWLINE
 PRINT INDENT(BASEINDENT+3)+Q+"toAccountName"+Q+": "+Q+NEWTRANSLDESCRIPTION+Q+","
 NEWLINE
 TMPCHR=NEWTRANSRCACCT+NEWTRANSRCIDTYPE+NEWTRANSRCID
 TMPCHR="X"+SEGMENT(TMPCHR,LENGTH(TMPCHR)-6,LENGTH(TMPCHR))
 PRINT INDENT(BASEINDENT+3)+Q+"fromAccountNumberMasked"+Q+": "+Q+TMPCHR+Q+","
 NEWLINE
 TMPCHR=NEWTRANRECIPACCT+NEWTRANRECIPSLIDTYPEFOUND+NEWTRANRECIPSLIDFOUND
 TMPCHR="X"+SEGMENT(TMPCHR,LENGTH(TMPCHR)-6,LENGTH(TMPCHR))
 PRINT INDENT(BASEINDENT+3)+Q+"toAccountNumberMasked"+Q+": "+Q+TMPCHR+Q+","
 NEWLINE

 PRINT INDENT(BASEINDENT+3)+Q+"nextTransferDate"+Q+": "+Q+ FORMAT("99/99/9999",NEWTRANSTARTDATE)+Q

 IF NEWTRANFREQ<>0 THEN
  DO
   PRINT ","
   NEWLINE
   PRINT INDENT(BASEINDENT+3)+Q+"frequency"+Q+": "+Q+NEWTRANFREQCHR+Q+","
   NEWLINE
   NLTSCHR=""
   IF NEWTRANDAY1>0 THEN
    DO
     NLTSCHR=FORMAT("#9",NEWTRANDAY1)
     CALL NLS
    END
   PRINT INDENT(BASEINDENT+3)+Q+"day1"+Q+": "+Q+NLTSCHR+Q+","
   NEWLINE
   NLTSCHR=""
   IF NEWTRANDAY2>0 THEN
    DO
     NLTSCHR=FORMAT("#9",NEWTRANDAY2)
     CALL NLS
    END
   PRINT INDENT(BASEINDENT+3)+Q+"day2"+Q+": "+Q+NLTSCHR+Q
   NEWLINE
  END
 ELSE
  NEWLINE

 PRINT INDENT(BASEINDENT+2)+"}"
 NEWLINE
 PRINT INDENT(BASEINDENT+1)+"},"
 NEWLINE
 PRINT INDENT(BASEINDENT+2)+Q+"results"+Q+": {"
 NEWLINE
 PRINT INDENT(BASEINDENT+3)+Q+"success"+Q+": true,"
 NEWLINE
 PRINT INDENT(BASEINDENT+3)+Q+"memoMode"+Q+": "+TRUEFALSECHR(SYSTEMMEMOMODE)+","
 NEWLINE

 NLTSCHR=FORMAT("#######9",NEWSLTRANSFERLOC)
 CALL NLS
 PRINT INDENT(BASEINDENT+3)+Q+"transferLoc"+Q+": "+Q+NLTSCHR+Q+","
 NEWLINE

 IF NEWTRANRECIPLOC>0 THEN
  NLTSCHR=FORMAT("#######9",NEWTRANRECIPLOC)
 ELSE
  NLTSCHR=FORMAT("#######9",NEWRECIPACCTLOC)
 IF LENGTH(NLTSCHR)>0 THEN
  CALL NLS

 IF @RGSTATE<>STATEEDITTRAN AND
    @RGSTATE<>STATEDELETETRAN THEN
  DO
   PRINT INDENT(BASEINDENT+3)+Q+"recipientLoc"+Q+": "+Q+NLTSCHR+Q+","
   NEWLINE
  END

 WHILELIMIT=1000000
 FOR ACCOUNT ACCOUNT:NUMBER
  DO
   CALL READPREFSETTINGS
   CALL CALCLIMITS
   IF ERRORCODE=0 THEN
    DO
     CALL BUILDSHARELOANLIST

     CALL BUILDRECIPLIST
     CALL BUILDSLTRANSFERLIST
    END
  END
 BASEINDENT=2
 CALL PRINTCURRENTSTATE
 PRINT "    }"
END [PROCEDURE]

PROCEDURE CREATERECIPACCT
[* Create a new recipient's account for future use
*]
 BNODEBUGMSG="** PROCEDURE CREATERECIPACCT"
 CALL BNODEBUGMSGADD

 TMPEXPIREDATE=DATENULL

 IF NEWTRANNICKNAME="" THEN
  DO
   TMPEXPIREDATE=SYSTEMDATE
   EXTFINAME="M2M:"
  END
 ELSE
  DO
   EXTFINAME="M2M:"+NEWTRANNICKNAME
  END

 EXTACCTNUM=NEWTRANRECIPACCT+NEWTRANRECIPSLIDTYPEFOUND+NEWTRANRECIPSLIDFOUND

 BNODEBUGMSG="NEWTRANNICKNAME:"+NEWTRANNICKNAME
 CALL BNODEBUGMSGADD
 EXTPRIMARY=UPPERCASE(NEWTRANFIRST3)
 EXTSTATUS=2
 [EXTEXPIRE=TMPDATE]
 RECIPFOUND=FALSE
 RECIPEXPIREDATE=DATENULL
 TMPLOCATOR=0
 FOR EACH EXTERNALACCOUNT WITH (EXTERNALACCOUNT:FINANCIALINSTITUTIONNAME=EXTFINAME AND
                                EXTERNALACCOUNT:NUMBER=EXTACCTNUM AND
                                EXTERNALACCOUNT:PRIMARYACCOUNTHOLDERNAME=EXTPRIMARY AND
                                EXTERNALACCOUNT:STATUS=EXTSTATUS)
  DO

   BNODEBUGMSG=FORMAT("TESTING EXT REC:9999",EXTERNALACCOUNT:LOCATOR)+
               "  FINAME:"+EXTERNALACCOUNT:FINANCIALINSTITUTIONNAME+
               "  NUMBER:"+EXTERNALACCOUNT:NUMBER+
               "  ACCTHLDRNAME:"+EXTERNALACCOUNT:PRIMARYACCOUNTHOLDERNAME+
               FORMAT("  STATUS:9",EXTERNALACCOUNT:STATUS)
   CALL BNODEBUGMSGADD
   RECIPFOUND=TRUE
   RECIPEXPIREDATE=EXTERNALACCOUNT:EXPIRATIONDATE
   TMPLOCATOR=EXTERNALACCOUNT:LOCATOR
  END UNTIL RECIPFOUND=TRUE

 IF RECIPFOUND=TRUE AND
    RECIPEXPIREDATE<>TMPEXPIREDATE THEN
  DO
   FMPERFORM REVISE EXTERNALACCOUNT LOC TMPLOCATOR (0,0,FMERROR)
    DO
     SET EXPIRATIONDATE TO TMPEXPIREDATE
    END
  END
 ELSE IF RECIPFOUND=FALSE THEN
  DO
   FMPERFORM CREATE EXTERNALACCOUNT LOC AFTERLAST (0,0,NEWRECIPACCTLOC,FMERROR)
    DO
     SET FINANCIALINSTITUTIONNAME TO EXTFINAME
     SET NUMBER TO EXTACCTNUM
     SET PRIMARYACCOUNTHOLDERNAME TO EXTPRIMARY
     SET STATUS TO EXTSTATUS
     SET EXPIRATIONDATE TO TMPEXPIREDATE
    END
  END
 BNODEBUGMSG=FORMAT("RECIPFOUND:9",RECIPFOUND)+FORMAT("   RECIPEXPIREDATE:99/99/99",RECIPEXPIREDATE)
 CALL BNODEBUGMSGADD

 BNODEBUGMSG="CREATE RECIP - EXTFINAME:"+EXTFINAME
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="  EXTACCTNUM:"+EXTACCTNUM+
             "  EXTPRIMARY:"+EXTPRIMARY+FORMAT("  EXTSTATUS:9",EXTSTATUS)+
             FORMAT("  TMPEXPIREDATE:99/99/99",TMPEXPIREDATE)

 CALL BNODEBUGMSGADD
 BNODEBUGMSG="FMERROR:"+FMERROR
 CALL BNODEBUGMSGADD
END [PROCEDURE]

PROCEDURE EXPIREEXISTINGXFER
[* Expire an existing transfer
**
*]
 IF @RGSTATE=STATEEDITTRAN THEN
  DO
   FMPERFORM REVISE SHARE NEWTRANSRCID TRANSFER LOC TARGETSLTRANLOC (0,0,TRANERROR)
    DO
     SET EFFECTIVEDATE TO DATENULL
     SET EXPIRATIONDATE TO SYSTEMDATE
    END
   IF TRANERROR<>"" THEN
    DO
     NEWLINE
     CALL JSONOPEN
     CALL PRINTPROGRAMINFO
     ERRORCODE=507
     CALL ERRORHANDLER
     CALL JSONCLOSE
     @RGSTATE=STATEEND
    END
  END
 ELSE IF @RGSTATE=STATEDELETETRAN THEN
  DO
   SLTRANSFERFOUND=FALSE
   FOR EACH SHARE
    DO
     FOR EACH SHARE TRANSFER WITH (SHARE TRANSFER:LOCATOR=TARGETSLTRANLOC)
      DO

       SLTRANSFERFOUND=TRUE
       NEWTRANRECIPACCT=SHARE TRANSFER:ACCOUNTNUMBER
       NEWTRANRECIPSLIDTYPE=SHARE TRANSFER:IDTYPE
       NEWTRANRECIPSLIDFOUND=SHARE TRANSFER:ID
       NEWTRANSRCACCT=ACCOUNT:NUMBER
       NEWTRANSRCID=SHARE:ID
       NEWTRANFREQ=SHARE TRANSFER:FREQUENCY
       NEWTRANFREQCHR=TRANSFERFREQCHR(TRANFREQALT,NEWTRANFREQ)
       NEWTRANSTARTDATE=SHARE TRANSFER:EFFECTIVEDATE
       IF NEWTRANSTARTDATE=DATENULL THEN
        NEWTRANSTARTDATE=SHARE TRANSFER:NEXTDATE
       NEWTRANDAY1=SHARE TRANSFER:DAY1
       NEWTRANDAY2=SHARE TRANSFER:DAY2
       NEWTRANAMOUNT=SHARE TRANSFER:AMOUNT
       NEWTRANSRCIDTYPE="S"

       NEWTRANRECIPLONGNAME=NAME:LONGNAME
       CALL GETRECIPSLDATA

      END
    END

   IF SLTRANSFERFOUND=FALSE THEN
    DO
     ERRORCODE=507
     @RGSTATE=STATEEND
     CALL JSONOPEN
     CALL PRINTPROGRAMINFO
     CALL ERRORHANDLER
     CALL JSONCLOSE
    END
   ELSE
    DO
     FMPERFORM REVISE SHARE NEWTRANSRCID TRANSFER LOC TARGETSLTRANLOC (0,0,TRANERROR)
      DO
       SET EFFECTIVEDATE TO DATENULL
       SET EXPIRATIONDATE TO SYSTEMDATE
      END
     IF TRANERROR<>"" THEN
      DO
       NEWLINE
       CALL JSONOPEN
       CALL PRINTPROGRAMINFO
       ERRORCODE=507
       CALL ERRORHANDLER
       CALL JSONCLOSE
       @RGSTATE=STATEEND
      END
     ELSE
      DO
       IF PARAMENFORCELIMITS=TRUE THEN
        DO
         CALL UPDATEPREFTOTALS
         CALL SETUPLIMITS
        END
       CALL JSONOUTTRANSUCCESS
      END
    END
  END
END [PROCEDURE]

PROCEDURE FINDTRANCREATEDATE
[* Find the date on which the transfer was created
**
**  PASS   TARGETTRANSFERLOC          The S/L Transfer Locator to lookup
**  RETURN TRANCREATEDATEFOUND        Boolean - Was record found
**  RETURN TRANSFERCREATEDATE         Record created date
*]
 TRANSFERCREATEDATE=DATENULL
 TRANSFERCREATEUSER=-1
 TRANCREATEDATEFOUND=FALSE

 FOR ACCOUNT ACCOUNT:NUMBER
  DO
   FOR EACH FMHISTORY
    DO
     IF FMHISTORY:ACCOUNTNUMBER=ACCOUNT:NUMBER AND
        FMHISTORY:RECORDTYPE=8 AND
        UPPERCASE(FMHISTORY:FIELDNAME)="NEW LOCATOR" THEN
      DO
       IF FMHISTORY:NEWNUMBER=TARGETTRANSFERLOC THEN
        DO
         TRANCREATEDATEFOUND=TRUE
         TRANSFERCREATEDATE=FMHISTORY:POSTDATE
         TRANSFERCREATEUSER=FMHISTORY:USERNUMBER
         BNODEBUGMSG=FORMAT("CREATE DATE FOUND:99/99/9999    ",TRANSFERCREATEDATE)+
                     FORMAT("CREATE USER:999+",TRANSFERCREATEUSER)
         CALL BNODEBUGMSGADD
        END
      END
    END
   UNTIL TRANCREATEDATEFOUND=TRUE
  END
END [PROCEDURE]


PROCEDURE GETRECIPSLDATA
 FOR ACCOUNT NEWTRANRECIPACCT
  DO
   IF NEWTRANRECIPSLIDTYPE=0 THEN
    DO
     FOR EACH SHARE WITH (SHARE:ID=NEWTRANRECIPSLIDFOUND)
      DO
       NEWTRANRECIPSLIDTYPEFOUND="S"
       NEWTRANSLDESCRIPTION=SHARE:NICKNAME
       IF NEWTRANSLDESCRIPTION="" THEN
        NEWTRANSLDESCRIPTION=SHARE:DESCRIPTION
      END
    END
   ELSE [recip is a loan]
    DO
     FOR EACH LOAN WITH (LOAN:ID=NEWTRANRECIPSLIDFOUND)
      DO
       NEWTRANRECIPSLIDTYPEFOUND="L"
       NEWTRANSLDESCRIPTION=LOAN:NICKNAME
       IF NEWTRANSLDESCRIPTION="" THEN
        NEWTRANSLDESCRIPTION=LOAN:DESCRIPTION
      END
    END
  END
END

PROCEDURE SETUPLIMITS
[* Establish current transfer limits
*]
 BNODEBUGMSG="*** PROCEDURE SETUPLIMITS"
 CALL BNODEBUGMSGADD

 CALL READPREFSETTINGS
 CALL CALCLIMITS
END [PROCEDURE]

PROCEDURE CREATETRANSFER
[* Create Transfer Record. If creating a new transfer record as a result
** of an edit, validate net increase/decrease against daily limits..
*]
 BNODEBUGMSG="*** PROCEDURE CREATETRANSFER"
 CALL BNODEBUGMSGADD

 VALIDLIMITSEXCEEDED=FALSE
 IF PARAMENFORCELIMITS=TRUE THEN
  DO
   CALL SETUPLIMITS

   IF @RGSTATE=STATEEDITTRAN THEN
    DO
     TMPAMOUNT=MBRAMOUNTACTUAL-NEWTRANSRCAMOUNT+NEWTRANAMOUNT
     IF TMPAMOUNT>MBRAMOUNTLIMITCALC OR
        NEWTRANAMOUNT>MBRINDIVLIMITCALC THEN
      VALIDLIMITSEXCEEDED=TRUE
    END
   ELSE
    DO
     IF MBRCOUNTACTUAL+1>MBRCOUNTLIMITCALC OR
        MBRAMOUNTACTUAL+NEWTRANAMOUNT>MBRAMOUNTLIMITCALC OR
        NEWTRANAMOUNT>MBRINDIVLIMITCALC THEN
      VALIDLIMITSEXCEEDED=TRUE
    END
  END

 IF VALIDLIMITSEXCEEDED=FALSE THEN
  DO

   IF NEWTRANFREQ=0 AND
      SOONESTAVAILABLE=TRUE AND
      NEWTRANDAY1=0 AND
      NEWTRANDAY2=0 THEN
    TRANTYPE=TRANTYPEIMMEDIATE
   ELSE
    TRANTYPE=TRANTYPEREGULAR

   IF TRANTYPE=TRANTYPEIMMEDIATE THEN
    CALL CREATEIMMEDIATETRANSFER
   ELSE
    CALL CREATEFUTURETRANSFER
  END
END [PROCEDURE]

PROCEDURE CREATEIMMEDIATETRANSFER
[* Perform an immediate transfer
*]
 BNODEBUGMSG="*** PROCEDURE CREATEIMMEDIATETRANSFER"
 CALL BNODEBUGMSGADD

 BNODEBUGMSG=FORMAT("NEWTRANAMOUNT:###,##9.99",NEWTRANAMOUNT)+
             "   NEWTRANCOMMENT:"+NEWTRANCOMMENT
 CALL BNODEBUGMSGADD

 BNODEBUGMSG="SOURCE - NEWTRANSRCACCT:"+NEWTRANSRCACCT+
            "   NEWTRANSRCIDTYPE:"+NEWTRANSRCIDTYPE+
            "   NEWTRANSRCID: "+NEWTRANSRCID
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="RECIP - NEWTRANRECIPACCT:"+NEWTRANRECIPACCT+
            "   NEWTRANRECIPSLIDTYPEFOUND:"+NEWTRANRECIPSLIDTYPEFOUND+
            "   NEWTRANRECIPSLIDFOUND:"+NEWTRANRECIPSLIDFOUND
 CALL BNODEBUGMSGADD

[* If comment is 16 characters or less, it will be stored as a transaction
** description. PARMTRANCOMMENT allows the CU to seed the comment with
** a std value to force the comment to be over 16 characters and thus
** always be a tran comment instead of a tran description.
*]
 TMPCOMMENT1=PARAMTRANCOMMENT
 IF TMPCOMMENT1<>"" AND
    NEWTRANCOMMENT<>"" THEN
  TMPCOMMENT1=TMPCOMMENT1+" "
 TMPCOMMENT1=TMPCOMMENT1+
             NEWTRANCOMMENT
 TRANPERFORM XF (0,SEQ1,SEQ2,CAC,CN,TRANERROR)
  DO
   SET FMACCT TO NEWTRANSRCACCT
   SET FMTYPE TO NEWTRANSRCIDTYPE
   SET FMID   TO NEWTRANSRCID

   SET TOACCT TO NEWTRANRECIPACCT
   SET TOTYPE TO NEWTRANRECIPSLIDTYPEFOUND
   SET TOID   TO NEWTRANRECIPSLIDFOUND
   SET REGE   TO 1
   SET AMOUNT TO NEWTRANAMOUNT
   SET COMMENT:1 TO TMPCOMMENT1
  END [TRANPERFORM]

 BNODEBUGMSG="S/L TRANPERFORM TRANERROR:"+TRANERROR
 CALL BNODEBUGMSGADD
END [PROCEDURE]

PROCEDURE CREATEFUTURETRANSFER
[* NEED TO ADD >> Perform a final check to make sure limits aren't being exceeded and if so
** return an error message
*]

 TMPNUM=0
 IF UPPERCASE(NEWTRANRECIPSLIDTYPEFOUND)="L" THEN
  TMPNUM=1
 IF TRANERROR="" THEN
  DO
   FMPERFORM CREATE SHARE NEWTRANSRCID TRANSFER LOC AFTERLAST (0,0,NEWSLTRANSFERLOC,TRANERROR)
    DO
     SET TYPE TO 3
     SET ACCOUNTNUMBER TO NEWTRANRECIPACCT
     SET IDTYPE TO TMPNUM
     SET ID TO NEWTRANRECIPSLIDFOUND
     SET AMOUNT TO NEWTRANAMOUNT
     SET EFFECTIVEDATE TO NEWTRANSTARTDATE
     SET NEXTDATE TO NEWTRANSTARTDATE
     SET FREQUENCY TO NEWTRANFREQ
     SET DAY1 TO NEWTRANDAY1
     SET DAY2 TO NEWTRANDAY2
    END
  END

 BNODEBUGMSG="S/L CREATE TRANSFER TRANERROR:"+TRANERROR
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="NEWTRANSRCID:"+NEWTRANSRCID+"  "+
             "NEWTRANRECIPACCT:"+NEWTRANRECIPACCT+"  "+
             "NEWTRANRECIPSLIDFOUND:"+NEWTRANRECIPSLIDFOUND+"  "+
             "NEWTRANRECIPSLIDTYPEFOUND:"+NEWTRANRECIPSLIDTYPEFOUND
 CALL BNODEBUGMSGADD
END [PROCEDURE]

PROCEDURE UPDATEPREFTOTALS
[* Update Preference record totals based upon the tran type and amount
*]
 BNODEBUGMSG="*** PROCEDURE UPDATEPREFTOTALS"
 CALL BNODEBUGMSGADD

 CALL READPREFSETTINGS
 BNODEBUGMSG=FORMAT("PRE UPDATE XFER AMOUNT:###,##9.99",MBRAMOUNTACTUAL)
 CALL BNODEBUGMSGADD

 IF @RGSTATE=STATECREATETRAN THEN
  DO
   IF SYSTEMDATE=MBRLASTTRANDATE THEN
    DO
     NEWXFERCOUNT=MBRCOUNTACTUAL+1
     NEWXFERAMOUNT=MBRAMOUNTACTUAL+NEWTRANAMOUNT
     NEWLASTTRANDATE=SYSTEMDATE
    END
   ELSE
    DO
     NEWXFERCOUNT=1
     NEWXFERAMOUNT=NEWTRANAMOUNT
     NEWLASTTRANDATE=SYSTEMDATE
    END
  END
 ELSE IF @RGSTATE=STATEDELETETRAN THEN
  DO
[* Determine if transfer being deleted was created on the system date and
** if so, deduct the transfer values from the daily totals.
*]
   TARGETTRANSFERLOC=TARGETSLTRANLOC
   CALL FINDTRANCREATEDATE


   IF TRANCREATEDATEFOUND=TRUE AND
      TRANSFERCREATEDATE=SYSTEMDATE THEN
    DO
[*reduce the ttl transfer count by 1 and the ttl amount by transfer amount
*]
     NEWXFERCOUNT=MBRCOUNTACTUAL-1
     NEWXFERAMOUNT=MBRAMOUNTACTUAL-NEWTRANAMOUNT
     NEWLASTTRANDATE=SYSTEMDATE
    END
  END
 ELSE IF @RGSTATE=STATEEDITTRAN THEN
  DO
   TARGETTRANSFERLOC=TARGETSLTRANLOC
   CALL FINDTRANCREATEDATE

   NEWXFERCOUNT=MBRCOUNTACTUAL
   NEWXFERAMOUNT=MBRAMOUNTACTUAL-NEWTRANSRCAMOUNT+NEWTRANAMOUNT
   NEWLASTTRANDATE=SYSTEMDATE
  END

 BNODEBUGMSG=FORMAT("NEWXFERCOUNT:###,##9.99",NEWTRANSRCAMOUNT)+
             FORMAT("  NEWXFERCOUNT:999   ",NEWXFERCOUNT)+
             FORMAT("  XFERAMOUNT:###,##9.99",NEWXFERAMOUNT)+
             FORMAT("  NEWLASTTRANDATE:99/99/99",NEWLASTTRANDATE)
 CALL BNODEBUGMSGADD

 IF @RGSTATE=STATECREATETRAN OR
   (@RGSTATE=STATEEDITTRAN AND
    TRANCREATEDATEFOUND=TRUE AND
    TRANSFERCREATEDATE=SYSTEMDATE) OR
   (@RGSTATE=STATEDELETETRAN AND
    TRANCREATEDATEFOUND=TRUE AND
    TRANSFERCREATEDATE=SYSTEMDATE) THEN
  DO
   FMPERFORM REVISE PREFERENCE LOC @PREFLOCATOR (0,0,PREFUPDATEERROR)
    DO
     SET XFERCOUNT TO NEWXFERCOUNT
     SET XFERAMOUNT TO NEWXFERAMOUNT
     SET LASTTRANDATE TO NEWLASTTRANDATE
    END
  END
 BNODEBUGMSG="PREFUPDATEERROR:"+PREFUPDATEERROR
 CALL BNODEBUGMSGADD

 CALL READPREFSETTINGS

 BNODEBUGMSG=FORMAT("POST UPDATE XFER AMOUNT:###,##9.99",MBRAMOUNTACTUAL)
 CALL BNODEBUGMSGADD
END

PROCEDURE PRINTCURRENTSTATE
[* Member's Preference Record limits and counts
*]

 PRINT INDENT(BASEINDENT+1)+Q+"currentState"+Q+": {"
 NEWLINE
[* Pass S/L ID length value to UX for user input enforcement
*]
 PRINT INDENT(BASEINDENT+1)+Q+"slidLength"+Q+": "
 IF PARAMIDLENTEST>0 THEN
  PRINT PARAMIDLENTEST
 ELSE
  PRINT SLIDLEN
 PRINT ","
 NEWLINE

 PRINT INDENT(BASEINDENT+1)+Q+"systemDate"+Q+": "+Q+FORMAT("99/99/9999",SYSTEMDATE)+Q+","
 NEWLINE

 PRINT INDENT(BASEINDENT+2)+Q+"transferLimits"+Q+": {"
 NEWLINE
 PRINT INDENT(BASEINDENT+3)+Q+"enforceLimits"+Q+": "+TRUEFALSECHR(PARAMENFORCELIMITS)+","
 NEWLINE
 PRINT INDENT(BASEINDENT+3)+Q+"countLimit"+Q+": "+Q+MBRCOUNTLIMITCALCCHR+Q+","
 NEWLINE
 PRINT INDENT(BASEINDENT+3)+Q+"memberCount"+Q+": "+Q+MBRCOUNTACTUALCHR+Q+","
 NEWLINE
 PRINT INDENT(BASEINDENT+3)+Q+"amountLimit"+Q+": "+Q+MBRAMOUNTLIMITCALCCHR+Q+","
 NEWLINE
 PRINT INDENT(BASEINDENT+3)+Q+"memberAmount"+Q+": "+Q+MBRAMOUNTACTUALCHR+Q+","
 NEWLINE
 PRINT INDENT(BASEINDENT+3)+Q+"perTransferLimit"+Q+": "+Q+MBRINDIVLIMITCALCCHR+Q
 NEWLINE
 PRINT INDENT(BASEINDENT+3)+"},"
 NEWLINE

[* Start Available Transfer Shares
*]
 PRINT INDENT(BASEINDENT+2)+Q+"availableShares"+Q+": ["
 NEWLINE

 FOR SLLOOP=1 TO NTSHARECOUNT
  DO
   IF NTSHAREACCTNUM(SLLOOP)<>THISACCOUNT THEN
    CROSSACCTFLAG=TRUE
   ELSE
    CROSSACCTFLAG=FALSE

   PRINT INDENT(BASEINDENT+3)+"{"
   NEWLINE

   PRINT INDENT(BASEINDENT+4)+Q+"transferSLId"+Q+": "+Q+NTSHAREACCTNUM(SLLOOP)+"S"+NTSHAREID(SLLOOP)+Q+","
   NEWLINE

   TMPNUM=NTSHARECODE(SLLOOP)
   IF TMPNUM>1 THEN
    TMPNUM=0

   PRINT INDENT(BASEINDENT+4)+Q+"type"+Q+": "+Q+TRANRECIPTYPECHR(TMPNUM)+Q+","
   NEWLINE

   IF NTSHARENICKNAME(SLLOOP)<>"" THEN
    TMPCHR=UPPERCASE(NTSHARENICKNAME(SLLOOP))
   ELSE
    TMPCHR=UPPERCASE(NTSHAREDESC(SLLOOP))

   PRINT INDENT(BASEINDENT+4)+Q+"name"+Q+": "+Q+TMPCHR+Q+","
   NEWLINE

   NLTSCHR=FORMAT("#############9.99",NTSHAREAVAILBAL(SLLOOP))
   CALL NLS
   PRINT INDENT(BASEINDENT+4)+Q+"available"+Q+": "+Q+NLTSCHR+Q+","
   NEWLINE
   PRINT INDENT(BASEINDENT+4)+Q+"accountOwnerName"+Q+": "+Q+NTSHAREACCOUNTNAME(SLLOOP)+Q+","
   NEWLINE

   PRINT INDENT(BASEINDENT+4)+Q+"crossAccount"+Q+": "+BNOTRUEFALSECHR(CROSSACCTFLAG)
   NEWLINE


   PRINT INDENT(BASEINDENT+3)+"}"
   IF SLLOOP<NTSHARECOUNT OR
     (SLLOOP=NTSHARECOUNT AND
      NTLOANCOUNT>0) THEN
    PRINT ","
   NEWLINE
  END

 FOR SLLOOP=1 TO NTLOANCOUNT
  DO
   IF NTLOANACCTNUM(SLLOOP)<>THISACCOUNT THEN
    CROSSACCTFLAG=TRUE
   ELSE
    CROSSACCTFLAG=FALSE

   PRINT INDENT(BASEINDENT+3)+"{"
   NEWLINE

   PRINT INDENT(BASEINDENT+4)+Q+"transferSLId"+Q+": "+Q+NTLOANACCTNUM(SLLOOP)+"L"+NTLOANID(SLLOOP)+Q+","
   NEWLINE

   PRINT INDENT(BASEINDENT+4)+Q+"type"+Q+": "+Q+"loan"+Q+","
   NEWLINE

   IF NTLOANNICKNAME(SLLOOP)<>"" THEN
    TMPCHR=UPPERCASE(NTLOANNICKNAME(SLLOOP))
   ELSE
    TMPCHR=UPPERCASE(NTLOANDESC(SLLOOP))

   PRINT INDENT(BASEINDENT+4)+Q+"name"+Q+": "+Q+TMPCHR+Q+","
   NEWLINE
   NLTSCHR=FORMAT("#############9.99",NTLOANAVAILCREDIT(SLLOOP))
   CALL NLS
   PRINT INDENT(BASEINDENT+4)+Q+"available"+Q+": "+Q+NLTSCHR+Q+","
   NEWLINE
   PRINT INDENT(BASEINDENT+4)+Q+"accountOwnerName"+Q+": "+Q+NTLOANACCOUNTNAME(SLLOOP)+Q+","
   NEWLINE
   PRINT INDENT(BASEINDENT+4)+Q+"crossAccount"+Q+": "+BNOTRUEFALSECHR(CROSSACCTFLAG)
   NEWLINE

   PRINT INDENT(BASEINDENT+3)+"}"
   IF SLLOOP<NTLOANCOUNT THEN
    PRINT ","
   NEWLINE
  END

[* End availableShares
*]
 PRINT INDENT(BASEINDENT+3)+"],"
 NEWLINE

[* Start Existing Transfers
*]
 PRINT INDENT(BASEINDENT+2)+Q+"scheduledTransfers"+Q+": ["
 NEWLINE

 FOR TMPLOOP=1 TO TRANCOUNT
  DO

   PRINT INDENT(BASEINDENT+3)+"{"
   NEWLINE
   PRINT INDENT(BASEINDENT+4)+Q+"transferLoc"+Q+": "+Q
[* Format locator to remove comma(s)
*]
   NLTSCHR=FORMAT("#######9",TRANLOC(TMPLOOP))
   CALL NLS
   PRINT NLTSCHR
   PRINT Q+","
   NEWLINE
[* Send transfer creation date to UX for user input logic
*]
   PRINT INDENT(BASEINDENT+4)+Q+"transferCreateDate"+Q+": "+Q+FORMAT("99/99/9999",TRANCREATEDATE(TMPLOOP))+Q+","
   NEWLINE

   PRINT INDENT(BASEINDENT+4)+Q+"sourceAccount"+Q+": "+Q+TRANSOURCEACCT(TMPLOOP)+Q+","
   NEWLINE


   PRINT INDENT(BASEINDENT+4)+Q+"accountName"+Q+": "+Q+TRANACCOUNTNAME(TMPLOOP)+Q+","
   NEWLINE
   PRINT INDENT(BASEINDENT+4)+Q+"transferAmt"+Q+": "+Q


   NLTSCHR=FORMAT("##########9.99",TRANXFERAMOUNT(TMPLOOP))
   CALL NLS


   PRINT NLTSCHR
   PRINT Q+","
   NEWLINE
   PRINT INDENT(BASEINDENT+4)+Q+"recipientName"+Q+": "+Q+TRANRECIPNAME(TMPLOOP)+Q+","
   NEWLINE
   PRINT INDENT(BASEINDENT+4)+Q+"recipientMemberId"+Q+": "+Q+TRANRECIPACCT(TMPLOOP)+Q+","
   NEWLINE
   PRINT INDENT(BASEINDENT+4)+Q+"recipientAccountType"+Q+": "+Q+TRANRECIPACCTTYPE(TMPLOOP)+Q+","
   NEWLINE

   IF TRANRECIPEXPIREDATE(TMPLOOP)<>DATENULL THEN
    PRINT INDENT(BASEINDENT+4)+Q+"recipientAccountId"+Q+": "+Q+Q+","
   ELSE
    PRINT INDENT(BASEINDENT+4)+Q+"recipientAccountId"+Q+": "+Q+TRANRECIPACCTID(TMPLOOP)+Q+","

   NEWLINE
   PRINT INDENT(BASEINDENT+4)+Q+"recipientNickname"+Q+": "+Q+TRANRECIPNICKNAME(TMPLOOP)+Q+","
   NEWLINE
   PRINT INDENT(BASEINDENT+4)+Q+"startDate"+Q+": "+Q+FORMAT("99/99/9999",TRANSTARTDATE(TMPLOOP))+Q+","
   NEWLINE
   PRINT INDENT(BASEINDENT+4)+Q+"nextTransferDate"+Q+": "+Q+FORMAT("99/99/9999",TRANNEXTTRANDATE(TMPLOOP))+Q+","
   NEWLINE


   IF TRANSFERFREQCHR(TRANFREQALT,TRANFREQUENCY(TMPLOOP))<>"" THEN
    PRINT INDENT(BASEINDENT+4)+Q+"transferFrequency"+Q+": "+Q+TRANSFERFREQCHR(TRANFREQALT,TRANFREQUENCY(TMPLOOP))+Q+","
   ELSE
    PRINT INDENT(BASEINDENT+4)+Q+"transferFrequency"+Q+": "+Q+TRANSFERFREQCHR(TRANFREQSTD,TRANFREQUENCY(TMPLOOP))+Q+","
   NEWLINE

   NLTSCHR=""
   IF TRANDAY1(TMPLOOP)>0 THEN
    DO
     NLTSCHR=FORMAT("#9",TRANDAY1(TMPLOOP))
     CALL NLS
    END
   PRINT INDENT(BASEINDENT+4)+Q+"day1"+Q+": "+Q+NLTSCHR+Q+","
   NEWLINE

   NLTSCHR=""
   IF TRANDAY2(TMPLOOP)>0 THEN
    DO
     NLTSCHR=FORMAT("#9",TRANDAY2(TMPLOOP))
     CALL NLS
    END

   PRINT INDENT(BASEINDENT+4)+Q+"day2"+Q+": "+Q+NLTSCHR+Q+","
   NEWLINE
   PRINT INDENT(BASEINDENT+4)+Q+"readOnly"+Q+": "+TRANREADONLYSTATUS(TMPLOOP)
   NEWLINE

   PRINT INDENT(BASEINDENT+3)+"}"
   IF TMPLOOP<TRANCOUNT THEN
    PRINT ","
   NEWLINE
  END
[* End Existing Transfers
*]

 PRINT INDENT(BASEINDENT+3)+"],"
 NEWLINE

[* Start Saved Recipients
*]
 PRINT INDENT(BASEINDENT+2)+Q+"savedRecipients"+Q+": ["
 NEWLINE

 RECIPLASTUNEXPIREDINDEX=0
 FOR TMPLOOP=1 TO RECIPCOUNT
  DO
   IF RECIPLISTEXPIREDATE(TMPLOOP)=DATENULL THEN
    RECIPLASTUNEXPIREDINDEX=TMPLOOP
  END

 IF RECIPLASTUNEXPIREDINDEX>0 THEN
  DO
   FOR TMPLOOP=1 TO RECIPCOUNT
    DO
     IF RECIPLISTEXPIREDATE(TMPLOOP)=DATENULL THEN
      DO
       PRINT INDENT(BASEINDENT+3)+"{"
       NEWLINE

       NLTSCHR=FORMAT("########9",RECIPLOC(TMPLOOP))
       CALL NLS
       PRINT INDENT(BASEINDENT+4)+Q+"recipientLoc"+Q+": "+Q+NLTSCHR+Q+","
       NEWLINE

       PRINT INDENT(BASEINDENT+4)+Q+"recipientName"+Q+": "+Q+RECIPNAME(TMPLOOP)+Q+","
       NEWLINE

       PRINT INDENT(BASEINDENT+4)+Q+"recipientMemberId"+Q+": "+Q+SEGMENT(RECIPACCOUNT(TMPLOOP),1,10)+Q+","
       NEWLINE

       TMPCHR=""
[tek 03/29/22]
       IF UPPERCASE(SEGMENT(RECIPACCOUNT(TMPLOOP),11,11))="L" THEN
        TMPCHR="loan"
       ELSE
        TMPCHR="share"

       PRINT INDENT(BASEINDENT+4)+Q+"recipientAccountType"+Q+": "+Q+TMPCHR+Q+","
       NEWLINE

       PRINT INDENT(BASEINDENT+4)+Q+"recipientAccountId"+Q+": "+Q+SEGMENT(RECIPACCOUNT(TMPLOOP),12,LENGTH(RECIPACCOUNT(TMPLOOP)))+Q+","
       NEWLINE

       PRINT INDENT(BASEINDENT+4)+Q+"recipientNickname"+Q+": "+Q+RECIPNICKNAME(TMPLOOP)+Q
       NEWLINE

       PRINT INDENT(BASEINDENT+3)+"}"
       IF TMPLOOP<RECIPLASTUNEXPIREDINDEX THEN
        PRINT ","
       NEWLINE

      END [IF RECIPLISTEXPIREDATE(TMPLOOP)=DATENULL]
    END [FOR TMPLOOP=1 TO RECIPCOUNT]
  END [IF RECIPLASTUNEXPIREDINDEX>0]


[* End Saved Recipients
*]
 PRINT INDENT(BASEINDENT+3)+"]"
 NEWLINE

[* Start labels
*]
 IF PARAMLBLMEMBERNAME<>"" OR PARAMLBLID<>"" THEN
  DO
   PRINT ","+Q+"labels"+Q+": {"
   NEWLINE
   PRINT Q+"memberNameSubTitle"+Q+": "+Q+PARAMLBLMEMBERNAME+Q+","
   NEWLINE
   PRINT Q+"idSubTitle"+Q+": "+Q+PARAMLBLID+Q
   NEWLINE
   PRINT "}"
   NEWLINE
  END
[* End labels
*]

[* The share ID optional feature is not currently supported in baseline PowerOn.
 PRINT ","+Q+"shareAcctIdOptional"+Q+": "+TRUEFALSECHR(PARAMSIDOPTIONAL)
 NEWLINE
*]

[* End currentState
*]
 PRINT INDENT(BASEINDENT+2)+"}"
 NEWLINE
END

PROCEDURE CHECKFORPA3

 FOR EACH PREFERENCE WITH (PREFERENCE:LOCATOR=@PREFLOCATOR)
  DO
   FOR EACH PREFERENCE ACCESS WITH (PREFERENCE ACCESS:ACCESSTYPE=3)
    DO
     PA3FOUND=TRUE
    END
  END
 IF PA3FOUND=FALSE THEN
  DO
   NEWLINE
   CALL JSONOPEN
   CALL PRINTPROGRAMINFO
   ERRORCODE=502
   CALL ERRORHANDLER
   @RGSTATE=STATEEND
  END
END

PROCEDURE READPREFSETTINGS
[* Reset the preference record calculation settings for the day
*]
 BNODEBUGMSG="*** PROCEDURE READPREFSETTINGS"
 CALL BNODEBUGMSGADD

 PREFFOUND=FALSE
 MBRCOUNTLIMIT=0
 MBRAMOUNTLIMIT=$0.00
 MBRINDIVIDUALLIMIT=$0.00
 MBRCOUNTACTUAL=0
 MBRAMOUNTACTUAL=$0.00
 RESETPREFVALUES=FALSE

 FOR EACH PREFERENCE WITH (PREFERENCE:LOCATOR=@PREFLOCATOR)
  DO
   IF PREFERENCE:LASTTRANDATE<SYSTEMDATE THEN
    RESETPREFVALUES=TRUE

    BNODEBUGMSG=FORMAT("PREFERENCE:LASTTRANDATE = 99/99/99",PREFERENCE:LASTTRANDATE)+
                FORMAT("  RESETPREFVALUES:9",RESETPREFVALUES)
    CALL BNODEBUGMSGADD
  END

 IF RESETPREFVALUES=TRUE THEN
  DO
   FMPERFORM REVISE PREFERENCE LOC @PREFLOCATOR(1,0,PREFUPDATEERROR)
    DO
     SET XFERCOUNT TO 0
     SET XFERAMOUNT TO $0.00
     SET DEPCOUNT TO 0
     SET DEPAMOUNT TO $0.00
     SET WDCHECKCOUNT TO 0
     SET WDCHECKAMOUNT TO $0.00
     SET WDCASHCOUNT TO 0
     SET WDCASHAMOUNT TO $0.00
     SET BILLPAYCOUNT TO 0
     SET BILLPAYAMOUNT TO $0.00
     SET LASTTRANDATE TO SYSTEMDATE
    END
  END

 FOR EACH PREFERENCE WITH (PREFERENCE:LOCATOR=@PREFLOCATOR)
  DO
   PREFFOUND=TRUE
   MBRCOUNTLIMIT=PREFERENCE:XFERCOUNTLIMIT
   MBRAMOUNTLIMIT=PREFERENCE:XFERLIMIT
   MBRINDIVIDUALLIMIT=PREFERENCE:XFERMAX
   MBRCOUNTACTUAL=PREFERENCE:XFERCOUNT
   MBRAMOUNTACTUAL=PREFERENCE:XFERAMOUNT
   MBRLASTTRANDATE=PREFERENCE:LASTTRANDATE
  END

 NLTSCHR=FORMAT("#####9",MBRCOUNTLIMIT)
 CALL NLS
 MBRCOUNTLIMITCHR=NLTSCHR

 NLTSCHR=FORMAT("##########9.99",MBRAMOUNTLIMIT)
 CALL NLS
 MBRAMOUNTLIMITCHR=NLTSCHR

 NLTSCHR=FORMAT("##########9.99",MBRINDIVIDUALLIMIT)
 CALL NLS
 MBRINDIVIDUALLIMITCHR=NLTSCHR

 NLTSCHR=FORMAT("#####9",MBRCOUNTACTUAL)
 CALL NLS
 MBRCOUNTACTUALCHR=NLTSCHR

 NLTSCHR=FORMAT("##########9.99",MBRAMOUNTACTUAL)
 CALL NLS
 MBRAMOUNTACTUALCHR=NLTSCHR
END [PROCEDURE ]

PROCEDURE CALCLIMITS
[* Calculate member's current Preference record limits
*]
 BNODEBUGMSG="*** PROCEDURE CALCLIMITS"
 CALL BNODEBUGMSGADD

 MBRCOUNTLIMITCALC=-1
 MBRAMOUNTLIMITCALC=-$0.01
 MBRINDIVLIMITCALC=-$0.01

 MBRCOUNTLIMITCALCCHR=""
 MBRAMOUNTLIMITCALCCHR=""
 MBRINDIVLIMITCALCCHR=""

 BNODEBUGMSG="PROCEDURE CALCLIMITS (START)"
 CALL BNODEBUGMSGADD
 BNODEBUGMSG=FORMAT("MBRCOUNTLIMIT:###9+   ",MBRCOUNTLIMIT)+
            FORMAT("MBRAMOUNTLIMIT:###,##9.99+   ",MBRAMOUNTLIMIT)+
            FORMAT("MBRINDIVIDUALLIMIT:###,##9.99+   ",MBRINDIVIDUALLIMIT)
 CALL BNODEBUGMSGADD

 IF (PARAMINSTCOUNTLIMIT>0 AND PARAMINSTCOUNTLIMIT<9999) THEN
  DO
   IF MBRCOUNTLIMIT=0 THEN
    MBRCOUNTLIMITCALC=PARAMINSTCOUNTLIMIT
   ELSE IF (MBRCOUNTLIMIT>0 AND MBRCOUNTLIMIT<9999) THEN
    MBRCOUNTLIMITCALC=MBRCOUNTLIMIT
   ELSE IF MBRCOUNTLIMIT>=9999 THEN
    MBRCOUNTLIMITCALC=9999
  END
 ELSE IF PARAMINSTCOUNTLIMIT>=9999 THEN
  DO
   IF MBRCOUNTLIMIT=0 THEN
    MBRCOUNTLIMITCALC=9999
   ELSE IF (MBRCOUNTLIMIT>0 AND MBRCOUNTLIMIT<9999) THEN
    MBRCOUNTLIMITCALC=MBRCOUNTLIMIT
   ELSE IF MBRCOUNTLIMIT>=9999 THEN
    MBRCOUNTLIMITCALC=9999
  END
 ELSE IF PARAMINSTCOUNTLIMIT=0 THEN
  DO
   IF MBRCOUNTLIMIT=0 THEN
    MBRCOUNTLIMITCALC=MBRCOUNTLIMIT
   IF (MBRCOUNTLIMIT>0 AND MBRCOUNTLIMIT<9999) THEN
    MBRCOUNTLIMITCALC=MBRCOUNTLIMIT
   ELSE IF MBRCOUNTLIMIT>=9999 THEN
    MBRCOUNTLIMITCALC=9999
  END

 IF (PARAMINSTAMOUNTLIMIT>$0.00 AND PARAMINSTAMOUNTLIMIT<$999,999.99) THEN
  DO
   IF MBRAMOUNTLIMIT=$0.00 THEN
    MBRAMOUNTLIMITCALC=PARAMINSTAMOUNTLIMIT
   ELSE IF (MBRAMOUNTLIMIT>$0.00 AND MBRAMOUNTLIMIT<$999,999.99) THEN
    MBRAMOUNTLIMITCALC=MBRAMOUNTLIMIT
   ELSE IF MBRAMOUNTLIMIT>=$999,999.99 THEN
    MBRAMOUNTLIMITCALC=$999,999.99
  END
 ELSE IF PARAMINSTAMOUNTLIMIT>=$999,999.99 THEN
  DO
   IF MBRAMOUNTLIMIT=$0.00 THEN
    MBRAMOUNTLIMITCALC=$999,999.99
   ELSE IF (MBRAMOUNTLIMIT>$0.00 AND MBRAMOUNTLIMIT<$999,999.99) THEN
    MBRAMOUNTLIMITCALC=MBRAMOUNTLIMIT
   ELSE IF MBRAMOUNTLIMIT>=$999,999.99 THEN
    MBRCOUNTLIMITCALC=9999
  END
 ELSE IF PARAMINSTAMOUNTLIMIT=$0.00 THEN
  DO
   IF (MBRAMOUNTLIMIT>$0.00 AND MBRAMOUNTLIMIT<$999,999.99) THEN
    MBRAMOUNTLIMITCALC=MBRAMOUNTLIMIT
   ELSE IF MBRAMOUNTLIMIT>=$999,999.99 THEN
    MBRAMOUNTLIMITCALC=$999,999.99
   ELSE IF MBRAMOUNTLIMIT>=$999,999.99 THEN
    MBRAMOUNTLIMITCALC=$999,999.99
  END
 IF (PARAMINSTINDIVLIMIT>$0.00 AND PARAMINSTINDIVLIMIT<$999,999.99) THEN
  DO
   IF MBRINDIVIDUALLIMIT=$0.00 THEN
    MBRINDIVLIMITCALC=PARAMINSTINDIVLIMIT
   ELSE IF (MBRINDIVIDUALLIMIT>$0.00 AND MBRINDIVIDUALLIMIT<$999,999.99) THEN
    MBRINDIVLIMITCALC=MBRINDIVIDUALLIMIT
   ELSE IF MBRINDIVIDUALLIMIT>=$999,999.99 THEN
    MBRINDIVLIMITCALC=$999,999.99
  END
 ELSE IF PARAMINSTINDIVLIMIT>=$999,999.99 THEN
  DO
   IF MBRINDIVIDUALLIMIT=$0.00 THEN
    MBRINDIVLIMITCALC=$999,999.99
   ELSE IF (MBRINDIVIDUALLIMIT>$0.00 AND MBRINDIVIDUALLIMIT<$999,999.99) THEN
    MBRINDIVLIMITCALC=MBRINDIVIDUALLIMIT
   ELSE IF MBRINDIVIDUALLIMIT>=$999,999.99 THEN
    MBRINDIVLIMITCALC=$999,999.99
  END
 ELSE IF PARAMINSTINDIVLIMIT=$0.00 THEN
  DO
   IF (MBRINDIVIDUALLIMIT>$0.00 AND MBRINDIVIDUALLIMIT<$999,999.99) THEN
    MBRINDIVLIMITCALC=MBRINDIVIDUALLIMIT
   ELSE IF MBRINDIVIDUALLIMIT>=$999,999.99 THEN
    MBRINDIVLIMITCALC=$999,999.99
   ELSE IF MBRINDIVIDUALLIMIT>=$999,999.99 THEN
    MBRINDIVLIMITCALC=$999,999.99
  END
 IF MBRINDIVLIMITCALC>=$999,999.99 AND
    MBRCOUNTLIMITCALC>=9999 AND
    MBRAMOUNTLIMITCALC>=$999,999.99 THEN
  PARAMENFORCELIMITS=FALSE
 IF PARAMENFORCELIMITS=TRUE AND
   (MBRCOUNTLIMITCALC<0 OR
    MBRAMOUNTLIMITCALC<$0.00 OR
    MBRINDIVLIMITCALC<$0.00) THEN
  DO
   NEWLINE
   CALL JSONOPEN
   CALL PRINTPROGRAMINFO
   ERRORCODE=504
   CALL ERRORHANDLER
   @RGSTATE=STATEEND
  END
 NLTSCHR=FORMAT("######9+",MBRCOUNTLIMITCALC)
 CALL NLS
 MBRCOUNTLIMITCALCCHR=NLTSCHR

 NLTSCHR=FORMAT("########9.99+",MBRAMOUNTLIMITCALC)
 CALL NLS
 MBRAMOUNTLIMITCALCCHR=NLTSCHR

 NLTSCHR=FORMAT("########9.99+",MBRINDIVLIMITCALC)
 CALL NLS
 MBRINDIVLIMITCALCCHR=NLTSCHR

 BNODEBUGMSG="MBRCOUNTLIMITCALC:"+MBRCOUNTLIMITCALCCHR+
             "   MBRAMOUNTLIMITCALC:"+MBRAMOUNTLIMITCALCCHR+
             "   MBRINDIVLIMITCALC:"+MBRINDIVLIMITCALCCHR
 CALL BNODEBUGMSGADD
END [PROCEDURE]

PROCEDURE BUILDSHARELOANLIST

 CALL NTSETUSERHBENABLE
 NTCROSSACCTACCESS=PARAMCROSSACCTACCESS
 NTSLTYPE=PARAMNTSLTYPE
 NTACCESSTYPE=NTACCESSTYPEXFEROUT
 NTACCOUNTMASKFLAG=FALSE
 CALL NTBUILDSHARELOANLIST

 BNODEBUGMSG=FORMAT("1 NTSHARECOUNT=999",NTSHARECOUNT)+
             FORMAT("   NTLOANCOUNT=999",NTLOANCOUNT)
 CALL BNODEBUGMSGADD

END

PROCEDURE BUILDRECIPLIST
 RECIPCOUNT=0
 FOR EACH EXTERNALACCOUNT WITH (SEGMENT(EXTERNALACCOUNT:FINANCIALINSTITUTIONNAME,1,4)="M2M:" AND
                                EXTERNALACCOUNT:RT="" AND
                                EXTERNALACCOUNT:STATUS=2 [AND
                                EXTERNALACCOUNT:EXPIRATIONDATE=DATENULL])
  DO
   IF RECIPCOUNT<RECIPMAX THEN
    DO
     RECIPCOUNT=RECIPCOUNT+1
     RECIPLOC(RECIPCOUNT)=EXTERNALACCOUNT:LOCATOR
     RECIPNAME(RECIPCOUNT)=UPPERCASE(EXTERNALACCOUNT:PRIMARYACCOUNTHOLDERNAME)
     NLTSCHR=SEGMENT(EXTERNALACCOUNT:FINANCIALINSTITUTIONNAME,5,
            LENGTH(EXTERNALACCOUNT:FINANCIALINSTITUTIONNAME))
     CALL NLS
     RECIPNICKNAME(RECIPCOUNT)=NLTSCHR
     RECIPACCOUNT(RECIPCOUNT)=EXTERNALACCOUNT:NUMBER
     RECIPLISTEXPIREDATE(RECIPCOUNT)=EXTERNALACCOUNT:EXPIRATIONDATE
    END
  END
END

PROCEDURE BUILDSLTRANSFERLIST
 WHILELIMIT=2000000
 TRANCOUNT=0
 FOR EACH SHARE WITH (SHARE:CLOSEDATE=DATENULL)
  DO
   FOR EACH SHARE TRANSFER WITH (SHARE TRANSFER:TYPE=3 AND
                                (SHARE TRANSFER:EXPIRATIONDATE=DATENULL OR
                                 SHARE TRANSFER:EXPIRATIONDATE>SYSTEMDATE) AND
                                 SHARE TRANSFER:ACCOUNTNUMBER<>ACCOUNT:NUMBER)
    DO
     IF TRANCOUNT<TRANCOUNTMAX THEN
      DO
       PAACCOUNTTEST=SHARE TRANSFER:ACCOUNTNUMBER
       PASLIDTYPETEST=SHARE TRANSFER:IDTYPE
       PASLIDTEST=SHARE TRANSFER:ID

       TMPCHR=PAACCOUNTTEST+IDTYPETOCHR(SHARE TRANSFER:IDTYPE)+SHARE TRANSFER:ID

       CALL FINDEXTERNALRECORD
       CALL FINDPREFACCESSMATCH

       IF PREFACCESSMATCH=FALSE THEN
        DO
         TMPNUM=0
         TRANCOUNT=TRANCOUNT+1

         BNODEBUGMSG=">>>> TESTING FOR READONLY"
         CALL BNODEBUGMSGADD
         BNODEBUGMSG=FORMAT("EXTRECFOUND:9",EXTRECFOUND)+
                     FORMAT("     PARAMALLOWEDIT:9",PARAMALLOWEDIT)+
                    "   TRANSFERFREQCHR(TRANFREQALT,SHARE TRANSFER:FREQUENCY):"+
                     TRANSFERFREQCHR(TRANFREQALT,SHARE TRANSFER:FREQUENCY)
         CALL BNODEBUGMSGADD

         TRANLOC(TRANCOUNT)=SHARE TRANSFER:LOCATOR
         TRANSOURCEACCT(TRANCOUNT)=ACCOUNT:NUMBER+"S"+SHARE:ID

         TARGETTRANSFERLOC=TRANLOC(TRANCOUNT)
         CALL FINDTRANCREATEDATE
         TRANCREATEDATE(TRANCOUNT)=TRANSFERCREATEDATE
         TRANCREATEUSER(TRANCOUNT)=TRANSFERCREATEUSER

[* Determine if existing transfer is editible or not
*]
         IF ((EXTRECFOUND<>FALSE AND TRANCREATEUSER(TRANCOUNT)>=800) OR
             PARAMALLOWEDIT=TRUE) AND
             TRANSFERFREQCHR(TRANFREQALT,SHARE TRANSFER:FREQUENCY)<>"" THEN
          TRANREADONLYSTATUS(TRANCOUNT)="false"
         ELSE
          TRANREADONLYSTATUS(TRANCOUNT)="true"


         TRANACCOUNTNAME(TRANCOUNT)=SHARE:NICKNAME
         IF SHARE:NICKNAME="" THEN
          TRANACCOUNTNAME(TRANCOUNT)=SHARE:DESCRIPTION
         TRANXFERAMOUNT(TRANCOUNT)=SHARE TRANSFER:AMOUNT

         TRANRECIPNAME(TRANCOUNT)=RECIPNAME(EXTRECFOUND)

         TRANRECIPMBRID(TRANCOUNT)=SHARE TRANSFER:ACCOUNTNUMBER
         TRANRECIPACCT(TRANCOUNT)=SHARE TRANSFER:ACCOUNTNUMBER
         IF SHARE TRANSFER:IDTYPE=1 THEN
          TMPNUM=4
         ELSE
          DO
           TMPSID=SHARE TRANSFER:ID
           FOR ACCOUNT SHARE TRANSFER:ACCOUNTNUMBER
            DO
             FOR EACH SHARE WITH (SHARE:ID=TMPSID)
              DO
               TMPNUM=SHARE:SHARECODE
              END
            END
          END
         IF SHARE TRANSFER:IDTYPE=1 THEN
          TRANRECIPACCTTYPE(TRANCOUNT)="loan"
         ELSE
          TRANRECIPACCTTYPE(TRANCOUNT)="share"
         TRANRECIPEXPIREDATE(TRANCOUNT)=RECIPLISTEXPIREDATE(EXTRECFOUND)

         BNODEBUGMSG=FORMAT("TMPNUM:#9",TMPNUM)+"   TRANRECIPTYPECHR(TMPNUM):"+ TRANRECIPTYPECHR(TMPNUM)
         CALL BNODEBUGMSGADD


         TRANRECIPACCTID(TRANCOUNT)=SHARE TRANSFER:ID

         TRANRECIPNICKNAME(TRANCOUNT)=RECIPNICKNAME(EXTRECFOUND)

         TRANSTARTDATE(TRANCOUNT)=SHARE TRANSFER:EFFECTIVEDATE
         IF TRANSTARTDATE(TRANCOUNT)=DATENULL THEN
          TRANSTARTDATE(TRANCOUNT)=SHARE TRANSFER:NEXTDATE
         TRANNEXTTRANDATE(TRANCOUNT)=SHARE TRANSFER:NEXTDATE

         TRANFREQUENCY(TRANCOUNT)=SHARE TRANSFER:FREQUENCY

         TRANDAY1(TRANCOUNT)=SHARE TRANSFER:DAY1
         TRANDAY2(TRANCOUNT)=SHARE TRANSFER:DAY2

        END
      END
    END
  END
END [BUILDSLTRANSFERLIST]

PROCEDURE FINDPREFACCESSMATCH
 PREFACCESSMATCH=FALSE
 FOR ACCOUNT ACCOUNT:NUMBER
  DO

   FOR EACH PREFERENCE WITH (PREFERENCE:LOCATOR=@PREFLOCATOR)
    DO

     FOR EACH PREFERENCE ACCESS WITH  (PREFERENCE ACCESS:ACCESSTYPE=0 OR
                                       PREFERENCE ACCESS:ACCESSTYPE=2) AND
                                      ((PREFERENCE ACCESS:ACCOUNTNUMBER=PAACCOUNTTEST AND
                                       PREFERENCE ACCESS:IDTYPE=PASLIDTYPETEST AND
                                       PREFERENCE ACCESS:ID=PASLIDTEST) OR

                                      (PREFERENCE ACCESS:ACCOUNTNUMBER=PAACCOUNTTEST AND
                                       PREFERENCE ACCESS:IDTYPE=2))
      DO
       PREFACCESSMATCH=TRUE
      END
    END
  END
END

PROCEDURE FINDEXTERNALRECORD
 EXTRECFOUND=FALSE

 FOR RECIPINDEX=1 TO RECIPCOUNT
  DO
   IF TMPCHR=RECIPACCOUNT(RECIPINDEX) THEN
    EXTRECFOUND=RECIPINDEX
  END
 BNODEBUGMSG="TMPCHR:"+TMPCHR+FORMAT("   EXTRECFOUND:9",EXTRECFOUND)
 CALL BNODEBUGMSGADD
END

PROCEDURE INITIALIZEDATA
[* Initialize state variables
*]
 WHILELIMIT=100000
 PA3FOUND=FALSE
 LFNUMBER=0
 LFERROR=""
 VALIDACCOUNT=FALSE
 VALIDPARAMS=TRUE
 READCONFIGERROR=FALSE
 READCONFIGERRORMSG=""
 LFERROR=""
 LFNUMBER=0
 ERRORCODE=0
 PREFLOC=@PREFLOCATOR

 THISACCOUNT=ACCOUNT:NUMBER
 SYMXINSTANCE=@SYMXINSTANCEID
 SYMXCLIENTNUM=@CLIENTNUMBER
 LELISTINPUT=GETDATACHARACTER(GETPARAMSYMXCHCLSERVICESXIN,SYMXINSTANCE,SYMXCLIENTNUM)
 BNODEBUGMSG="SVCS XFER IN:"+LELISTINPUT
 CALL BNODEBUGMSGADD
 CALL LISTEXPAND
 FOR TMPLOOP=1 TO SVCCODEMAX
  DO
   SERVICEIN(TMPLOOP)=LELIST(TMPLOOP)
  END

 FOR TMPLOOP=0 TO MAXWARNINGTYPES
  DO
   WARNINGSACCT(TMPLOOP)=FALSE
  END
END [PROCEDURE]

PROCEDURE SETMEMOMODE
[* Check to see if the system is in memo mode and if so, return error code
** 500 and halt program run
*]
 SYSTEMMEMOMODE=SYSMEMOMODE
 IF PARAMMEMOMODE=DEBUGMODEON THEN
  SYSTEMMEMOMODE=TRUE
END [PROCEDURE]

PROCEDURE JSONOPEN
[* Print JSON open char
*]
 PRINT INDENT(BASEINDENT+0)
 PRINT "{"
 NEWLINE
END [PROCEDURE]

PROCEDURE JSONCLOSE
[* Print JSON close char
*]
 PRINT INDENT(BASEINDENT+0)
 PRINT "}"
 NEWLINE
END [PROCEDURE]

PROCEDURE READCONFIGFILESETTINGS
[* Read parameter settings from the configuration Letter file.
**
**  PASS   CONFIGFILENAME             The name of the configuration Letter file
**  RETURN READCONFIGERROR            Config file read error
**  RETURN READCONFIGERRORMSG         Config file read error detail
**  RETURN PARAMENFORCELIMITS         Should the program honor Preference record limits TRUE/FALSE
**  RETURN PARAMINELIGIBLEACCTS       Ineligible account Type(s) (in LISTEXPAND format)
**  RETURN PARAMWARNINGSACCT          Ineligible account warning(s) (in LISTEXPAND format)
**  RETURN PARAMINSTCOUNTLIMIT        Institution level aggregate transfer count limit
**  RETURN PARAMINSTAMOUNTLIMIT       Institution level aggregate transfer amount limit
**  RETURN PARAMINSTINDIVLIMIT        Institution level single transfer limit
**  RETURN PARAMCROSSACCTACCESS       Can transfers be made from cross accounts
**  RETURN PARAMNTSLTYPE              Transfer from types (shares, loans or both)
**  RETURN PARAMALLOWEDIT             Can the member edit manually created transfers
**  RETURN PARAMVALIDATIONNAMETYPES   Valid name types (Internal parameter setting only)
**  RETURN PARAMALLOWABLESHARECODES() Share codes allowed to transfer into (boolean)
**  RETURN MEMOMODE                   Is the system in memo mode (boolean)
**  RETURN DEBUGMODE                  Add debugging code to JSON Ouput (boolean)

*]
 READCONFIGERROR=FALSE
 READCONFIGERRORMSG=""
 PARAMINELIGIBLEACCTS=""
 PARAMWARNINGSACCT=""
 PARAMENFORCELIMITS=FALSE
 PARAMINSTCOUNTLIMIT=0
 PARAMINSTAMOUNTLIMIT=$0.00
 PARAMINSTINDIVLIMIT=$0.00
 PARAMCROSSACCTACCESS=FALSE
 PARAMNTSLTYPE=NTSLTYPESHARE
 DEBUGMODE=DEBUGMODEOFF
 IF SYSTEMDATE<LASTMODDATE+AUTODEBUGDAYS THEN
  DEBUGMODE=DEBUGMODEON
 PARAMMEMOMODE=FALSE
 PARAMALLOWEDIT=FALSE
 PARAMVALIDATIONNAMETYPES="00,01,05,06,07,08,09"
 PARAMALLOWABLESHARECODES(SHARECODESAVINGS)=TRUE
 PARAMALLOWABLESHARECODES(SHARECODEDRAFT)=TRUE
 PARAMALLOWABLESHARECODES(SHARECODECERT)=FALSE
 PARAMALLOWABLESHARECODES(SHARECODECLUB)=FALSE
 PARAMSIDOPTIONAL=FALSE
 PARAMIDLENTEST=0
 PARAMTRANCOMMENT=""
 PARAMLBLMEMBERNAME=""
 PARAMLBLID=""
 PARAMTESTMODE=FALSE
 PARAMTESTACCTLIST=""

 FILEOPEN("LETTER",CONFIGFILENAME,"READ",LFNUMBER,LFERROR)
 IF LFERROR<>"" THEN
  DO
   READCONFIGERROR=TRUE
   READCONFIGERRORMSG=CONFIGFILENAME+" open error - "+LFERROR
  END
 ELSE
  DO
   FILEREADLINE(LFNUMBER,LFLINE,LFERROR)
   IF LFERROR<>"" AND
      LFERROR<>"EOF" THEN
    DO
     READCONFIGERROR=TRUE
     READCONFIGERRORMSG=CONFIGFILENAME+" read error - "+LFERROR
    END
   WHILE LFERROR=""
    DO
     CALL NORMALIZEDATA
     IF PARAMNAME<>"" THEN
      DO
[* Enforce Limits
*]
       IF PARAMNAME="EL" THEN
        DO
         IF CHARACTERSEARCH("1YESTRUE",UPPERCASE(PARAMVALUE))>0 THEN
          PARAMENFORCELIMITS=TRUE
        END
[* Ineligible Account Type(s)
*]
       IF PARAMNAME="IAT" AND
          PARAMVALUE<>"" THEN
        PARAMINELIGIBLEACCTS=PARAMVALUE
[* Account Warnings
*]
       ELSE IF PARAMNAME="IAW" AND
               PARAMVALUE<>"" THEN
        PARAMWARNINGSACCT=PARAMVALUE
[* Global Count Limit
*]
       IF PARAMNAME="GCL" AND
          PARAMVALUE<>"" THEN
        DO
         PARAMINSTCOUNTLIMIT=VALUE(PARAMVALUE)
        END

[* Global Amount Limit
*]
       IF PARAMNAME="GAL" AND
          PARAMVALUE<>"" THEN
        DO
         PARAMINSTAMOUNTLIMIT=MONEY(VALUE(PARAMVALUE))
        END

[* Global Individual Limit
*]
       IF PARAMNAME="GIL" AND
          PARAMVALUE<>"" THEN
        DO
         PARAMINSTINDIVLIMIT=MONEY(VALUE(PARAMVALUE))
        END

[* Cross-Account Access
*]
       ELSE IF PARAMNAME="XA" THEN
        DO
         IF CHARACTERSEARCH("1YESTRUE",UPPERCASE(PARAMVALUE))>0 THEN
          PARAMCROSSACCTACCESS=TRUE
        END
[* Transfer From Type - If parameter is not 'SHARE[S]',
** 'LOAN[S]' or 'BOTH' then defaults to NTSLTYPESHARE ('SHARES')
*]
       ELSE IF PARAMNAME="XT" AND
               PARAMVALUE<>"" THEN
        DO
         IF UPPERCASE(PARAMVALUE)="LOAN" OR
            UPPERCASE(PARAMVALUE)="LOANS" THEN
          PARAMNTSLTYPE=NTSLTYPELOAN
         ELSE IF UPPERCASE(PARAMVALUE)="SHARE" OR
                 UPPERCASE(PARAMVALUE)="SHARES" THEN
          PARAMNTSLTYPE=NTSLTYPESHARE
         ELSE IF UPPERCASE(PARAMVALUE)="BOTH" THEN
          PARAMNTSLTYPE=NTSLTYPESHARELOAN
         ELSE
          PARAMNTSLTYPE=NTSLTYPESHARE
        END
[* Allow manual transfer edits
*]
       ELSE IF PARAMNAME="AE" THEN
        DO
         IF CHARACTERSEARCH("1YESTRUE",UPPERCASE(PARAMVALUE))>0 THEN
          PARAMALLOWEDIT=TRUE
        END
[* Validation name types
*]
       ELSE IF PARAMNAME="VNT" AND
               PARAMVALUE<>"" THEN
        DO
         PARAMVALIDATIONNAMETYPES=PARAMVALUE
        END
[* Allow transfers to certificates IF member elects to transfer to a
** specific ID
*]
       ELSE IF PARAMNAME="ACE" THEN
        DO
         IF CHARACTERSEARCH("1YESTRUE",UPPERCASE(PARAMVALUE))>0 THEN
          DO
           PARAMALLOWCERTS=TRUE
           PARAMALLOWABLESHARECODES(SHARECODECERT)=TRUE
          END
        END
[* Allow transfers to club shares IF member elects to transfer to a
** specific ID
*]
       ELSE IF PARAMNAME="ACL" THEN
        DO
         IF CHARACTERSEARCH("1YESTRUE",UPPERCASE(PARAMVALUE))>0 THEN
          DO
           PARAMALLOWCLUBS=TRUE
           PARAMALLOWABLESHARECODES(SHARECODECLUB)=TRUE
          END
        END
[* Share ID optional on new member transfers
*]
       ELSE IF PARAMNAME="SIDO" THEN
        DO
         IF CHARACTERSEARCH("1YESTRUE",UPPERCASE(PARAMVALUE))>0 THEN
          PARAMSIDOPTIONAL=TRUE
        END
[* Share/Loan ID Length Test
*]
       ELSE IF PARAMNAME="IL" AND
               PARAMVALUE<>"" THEN
        DO
         IF VALUE(PARAMVALUE)=2 THEN
          PARAMIDLENTEST=TESTIDLENGTH2
         ELSE IF VALUE(PARAMVALUE)=4 THEN
          PARAMIDLENTEST=TESTIDLENGTH4
        END
[* Default Transaction Comment
*]
       ELSE IF PARAMNAME="TC" THEN
        DO
         PARAMTRANCOMMENT=PARAMVALUE
        END
[* Member Name sub-title label
*]
       ELSE IF PARAMNAME="LBLMN" THEN
        DO
         PARAMLBLMEMBERNAME=PARAMVALUE
        END
[* ID sub-title label
*]
       ELSE IF PARAMNAME="LBLID" THEN
        DO
         PARAMLBLID=PARAMVALUE
        END
[* Debug mode
*]
       ELSE IF PARAMNAME="DB" THEN
        DO
         IF CHARACTERSEARCH("1YESTRUE",UPPERCASE(PARAMVALUE))>0 THEN
          DEBUGMODE=DEBUGMODEON
        END
[* Memo mode
*]
       ELSE IF PARAMNAME="MM" THEN
        DO
         IF CHARACTERSEARCH("1YESTRUE",UPPERCASE(PARAMVALUE))>0 THEN
         PARAMMEMOMODE=DEBUGMODEON
        END
[* Test Mode
*]
       ELSE IF PARAMNAME="TESTMODE" AND
               UPPERCASE(PARAMVALUE)="TRUE" THEN
        PARAMTESTMODE=TRUE
[* Test Account List
*]
       ELSE IF PARAMNAME="TESTACCOUNTLIST" THEN
        PARAMTESTACCTLIST=PARAMVALUE
      END
     PARAMNAME=""
     PARAMVALUE=""
     FILEREADLINE(LFNUMBER,LFLINE,LFERROR)
     IF LFERROR<>"" AND
        LFERROR<>"EOF" THEN
      DO
       READCONFIGERROR=TRUE
       READCONFIGERRORMSG="3-Error Reading Letterfile "+CONFIGFILENAME+": "+LFERROR
      END

    END [WHILE LFERROR=""]
   FILECLOSE(LFNUMBER,LFERROR)
  END

 BNODEBUGMSG="EL:"+TRUEFALSECHR(PARAMENFORCELIMITS)
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="IAT:"+PARAMINELIGIBLEACCTS
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="IAW:"+PARAMWARNINGSACCT
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="GCL:"+FORMAT("######9",PARAMINSTCOUNTLIMIT)
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="GAL:"+FORMAT("##########9.99",PARAMINSTAMOUNTLIMIT)
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="XA (NTCROSSACCTACCESS):"+TRUEFALSECHR(NTCROSSACCTACCESS)
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="XT (NTSLTYPE):"+FORMAT("9",NTSLTYPE)
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="VNT:"+PARAMVALIDATIONNAMETYPES
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="ACE:"+TRUEFALSECHR(PARAMALLOWCERTS)
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="ACL:"+TRUEFALSECHR(PARAMALLOWCLUBS)
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="SIDO:"+TRUEFALSECHR(PARAMSIDOPTIONAL)
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="VALID SHARE CODES:"
 FOR TMPLOOP=0 TO SHARECODEMAX
  DO
   IF PARAMALLOWABLESHARECODES(TMPLOOP)=TRUE THEN
    BNODEBUGMSG=BNODEBUGMSG+FORMAT("9",TMPLOOP)
  END
 CALL BNODEBUGMSGADD

 BNODEBUGMSG="DB:"+FORMAT("9",DEBUGMODE)
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="MM:"+FORMAT("9",PARAMMEMOMODE)
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="TESTMODE:"+BNOTRUEFALSECHR(PARAMTESTMODE)
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="TESTACCOUNTLIST:"+PARAMTESTACCTLIST
 CALL BNODEBUGMSGADD

 LELISTINPUT=PARAMINELIGIBLEACCTS
 IF LELISTINPUT="" THEN
  LELISTINPUT="NONE"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO 9999
  DO
   INVALIDACCTYPES(TMPLOOP)=LELIST(TMPLOOP)
  END

 LELISTINPUT=PARAMWARNINGSACCT
 IF LELISTINPUT="" THEN
  LELISTINPUT="NONE"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO MAXWARNINGTYPES
  DO
   WARNINGSACCT(TMPLOOP)=LELIST(TMPLOOP)
  END

 IF READCONFIGERROR=TRUE THEN
  DO
   NEWLINE
   CALL JSONOPEN
   CALL PRINTPROGRAMINFO
   ERRORCODE=501
   CALL ERRORHANDLER
   @RGSTATE=STATEEND
  END
END [PROCEDURE]

PROCEDURE NORMALIZEDATA
[* Read in a line from the parameter Letter file and segment it into
** the parameter name and the parameter value
** PASS    LFLINE          Character line read in
** RETURN  PARAMNAME       Parameter name found
** RETURN  PARAMVALUE      Parameter value
**
*]
 PARAMNAME=""
 PARAMVALUE=""

 POS=CHARACTERSEARCH(LFLINE,":")
 IF LFLINE<>"" AND
    SEGMENT(LFLINE,1,1)<>"*" AND
    POS>1 THEN
  DO
   NLTSCHR=SEGMENT(LFLINE,1,POS-1)
   CALL NLTS
   PARAMNAME=UPPERCASE(NLTSCHR)

   NLTSCHR=SEGMENT(LFLINE,POS+1,LENGTH(LFLINE))
   CALL NLTS
   PARAMVALUE=NLTSCHR
  END
END [PROCEDURE]

PROCEDURE NLTS
[* Remove leading AND trailing spaces
**  PASS       NLTSCHR
**  RETURN     NLTSCHR
*]
 CALL NTS
 IF NLTSCHR<>"" THEN
  CALL NLS
END [PROCEDURE]

PROCEDURE NLS
[* Remove leading spaces
**  PASS       NLTSCHR
**  RETURN     NLTSCHR
*]
 WHILE (LENGTH(NLTSCHR)>0 AND
        SEGMENT(NLTSCHR,1,1)=" ")
  DO
   IF LENGTH(NLTSCHR)=1 THEN
    NLTSCHR=""
   ELSE
    NLTSCHR=SEGMENT(NLTSCHR,2,LENGTH(NLTSCHR))
  END
 IF LENGTH(NLTSCHR)=0 THEN
  NLTSCHR=""
END [PROCEDURE]

PROCEDURE NTS
[* Remove trailing spaces
**  PASS       NLTSCHR
**  RETURN     NLTSCHR
*]
 IF NLTSCHR<>"" THEN
  NLTSCHR=SEGMENT(NLTSCHR,1,LENGTH(NLTSCHR))
 IF LENGTH(NLTSCHR)=0 THEN
  NLTSCHR=""
END [PROCEDURE]

PROCEDURE PARSEDATALINE
[* Parse through a line of delimited data and store individual fields into an array
**  PASS    DATALINE  Line of data to be parsed.
**  RETURN  DATALINEFIELD  Array of data elements rom the parsed DATALINE
**  RETURN  DATAFIELDCOUNT  Number of elements in the DATALINEFIELD array
*]

 FOR TMPLOOP=0 TO DATALINEFIELDMAX
  DO
   DATALINEFIELD(TMPLOOP)=""
  END
 DATAFIELDCOUNT=0

 WHILE DATALINE<>""
  DO
   POS=CHARACTERSEARCH(DATALINE,"|")
   DATAFIELDCOUNT=DATAFIELDCOUNT+1
   IF POS=0 THEN
    DO
     DATALINEFIELD(DATAFIELDCOUNT)=DATALINE
     DATALINE=""
    END
   ELSE
    DO
     DATALINEFIELD(DATAFIELDCOUNT)=SEGMENT(DATALINE,1,POS-1)
     DATALINE=SEGMENT(DATALINE,POS+1,LENGTH(DATALINE))
    END
  END
END [PROCEDURE]

PROCEDURE BNOPRINTDEBUG
[* Add debug messages to JSON output
**  PASS    DEBUGMODE  Boolean - is debug mode on
**  PASS    BNODEBUGCOUNT  Number of debut lines to send to JSON output
**  RETURN  BNODEBUGMSGLIST  debug output
*]
 IF DEBUGMODE=DEBUGMODEON THEN
  DO
   FOR DEBUGLOOP=1 TO BNODEBUGCOUNT
    DO

     IF DEBUGLOOP=1 THEN
      DO
       PRINT ","
       NEWLINE

       PRINT INDENT(2)+Q+"debugData"+Q+": ["
       NEWLINE
      END

     PRINT INDENT(2)+Q+BNODEBUGMSGLIST(DEBUGLOOP)+Q
     IF DEBUGLOOP<BNODEBUGCOUNT THEN
      PRINT ","
     NEWLINE
    END
   PRINT INDENT(2)+"]"
   NEWLINE
  END
END [PROCEDURE]

PROCEDURE BNODEBUGMSGADD
[* Add debug line output to array for later display in JSON output
**  PASS    BNODEBUGMSG  Line of debug output
**  RETURN  BNODEBUGMSGLIST  Array of debug messages to display
**  RETURN  BNODEBUGCOUNT  number of debug lines to display
**
*]
 IF BNODEBUGCOUNT<BNODEBUGMSGMAX THEN
  DO
   BNODEBUGCOUNT=BNODEBUGCOUNT+1
   BNODEBUGMSGLIST(BNODEBUGCOUNT)=BNODEBUGMSG
   BNODEBUGMSG=""
  END
END [PROCEDURE]

PROCEDURE VALIDATERANGEINPUT
[* Validate user input as valid listexpand input
**  PASS       TESTCHR          User input
**  RETURN     VALIDRANGEINPUT  Boolean T/F
*]
 VALIDRANGEINPUT=TRUE
 FOR TESTLOOP=1 TO LENGTH(TESTCHR)
  DO
   IF CHARACTERSEARCH("0123456789,- ALLNONE",UPPERCASE(SEGMENT(TESTCHR,TESTLOOP,TESTLOOP)))=0 THEN
    DO
     VALIDRANGEINPUT=FALSE
     TESTLOOP=LENGTH(TESTCHR)
    END
  END
 BNODEBUGMSG="Range Input Test ("+TESTCHR+"):"+TRUEFALSECHR(VALIDRANGEINPUT)
 CALL BNODEBUGMSGADD
END [PROCEDURE]

PROCEDURE ERRORHANDLER
[* Print error code information to output.
**  PASS    ERRORCODE      Error code to print
**  PASS    ERRORMSG       Error type to print
**  PASS    ERRORDETAIL    Specific error detail
**
** ERROR CODES
**  500 - System running in memo mode
**  501 - Config file processing error
**  502 - Invalid Source Account
**  503 - Invalid Recipient Account
**  504 - Insufficient Information
**  505 - Invalid Input
**  506 - Error Creating/Deleting Recipient Record
**  507 - Error Creating/Updating/Deleting Transfer
**  508 - Undefined Error
**  509 - Member Unverified
**  510 - Account ID incorrect
**  511 - Request exceeds limits
**
*]
 ERRORMSG="loggingErrorMessage"
 ERRORDETAIL(0)="Program running in memo mode"
 ERRORDETAIL(1)="Config file error"
 ERRORDETAIL(2)="Invalid Source Account"
 ERRORDETAIL(3)="Invalid Recipient Account"
 ERRORDETAIL(4)="Insufficient Information"
 ERRORDETAIL(5)="Invalid Input"
 ERRORDETAIL(6)="Error Processing Recipient Record"
 ERRORDETAIL(7)="Error Processing Transfer Record"
 ERRORDETAIL(8)="Undefined Error"
 ERRORDETAIL(9)="Member verification failed"
 ERRORDETAIL(10)="Account ID incorrect"
 ERRORDETAIL(11)="Request exceeds limits"
 ERRORDETAILOFFSET=ERRORCODE-500

 IF ERRORDETAILOFFSET=1 THEN
  IF READCONFIGERROR=TRUE THEN
   ERRORDETAIL(1)=ERRORDETAIL(1)+": "+READCONFIGERRORMSG
  ELSE IF PARAMVALIDATIONERROR=TRUE THEN
   ERRORDETAIL(1)=ERRORDETAIL(1)+": Invalid Parameter in CFG file"

 IF ERRORDETAILOFFSET=2 THEN
  IF PA3FOUND=FALSE THEN
   ERRORDETAIL(2)=ERRORDETAIL(2)+": Pref Access type 3 not found"
  ELSE IF WARNINGFOUND<>FALSE THEN
   ERRORDETAIL(2)=ERRORDETAIL(2)+FORMAT(": Acct Warning ###9",WARNINGFOUND)
  ELSE IF NTSHARECOUNT=0 AND NTLOANCOUNT=0 THEN
   ERRORDETAIL(2)=ERRORDETAIL(2)+": No eligible transfer from shares/loans"
  ELSE
   ERRORDETAIL(2)=ERRORDETAIL(2)+FORMAT(": Acct Type ####9",ACCOUNT:TYPE)

 IF ERRORDETAILOFFSET=4 THEN
  DO
   ERRORDETAIL(2)=ERRORDETAIL(2)+"Cannot calc member limits."
  END

 IF ERRORDETAILOFFSET=7 THEN
  DO
   IF @RGSTATE=STATEEDITTRAN AND
      SLTRANSFERFOUND=FALSE THEN
    ERRORDETAIL(7)=ERRORDETAIL(7)+FORMAT("Target s/l xfer Loc ######9 not found",TARGETSLTRANLOC)
   ELSE IF @RGSTATE=STATECREATETRAN AND
           TARGETSLIDFOUND=FALSE THEN
    ERRORDETAIL(7)=ERRORDETAIL(7)+": Target ID not found or invalid"
  END

 IF ERRORDETAILOFFSET=9 THEN
  DO
   IF VALIDATESTATUS=TARGETACCTNOTFOUND THEN
    ERRORDETAIL(9)=ERRORDETAIL(9)+": "+"Member account not found"
   ELSE IF VALIDATESTATUS=TARGETACCTCLOSED THEN
    ERRORDETAIL(9)=ERRORDETAIL(9)+": "+FORMAT("Account Closed - 99/99/99",TARGETACCTCLOSEDATE)
   ELSE IF VALIDATESTATUS=TARGETNAMENOMATCH THEN
    ERRORDETAIL(9)=ERRORDETAIL(9)+": "+"Name verification failed"
   ELSE IF VALIDATESTATUS=TARGETSAMEACCT THEN
    ERRORDETAIL(9)=ERRORDETAIL(9)+": "+"Must be a different member account number"
   ELSE IF VALIDATESTATUS=TARGETSLCLOSED THEN
    ERRORDETAIL(9)=ERRORDETAIL(9)+": "+FORMAT("S/L closed or charged-off - 99/99/99",TARGETSLCLOSECODATE)
   ELSE IF VALIDATESTATUS=TARGETNOTFOUNDBYSLID THEN
    ERRORDETAIL(9)=ERRORDETAIL(9)+": "+"S/L ID not found"
   ELSE IF VALIDATESTATUS=TARGETNOTFOUNDBYTYPE THEN
    ERRORDETAIL(9)=ERRORDETAIL(9)+": "+"No valid share or loan found"
   ELSE IF VALIDATESTATUS=TARGETNOSERVICECODE THEN
    ERRORDETAIL(9)=ERRORDETAIL(9)+": "+"S/L missing service code"
   ELSE IF VALIDATESTATUS=TARGETINVALIDSLTYPE THEN
    ERRORDETAIL(9)=ERRORDETAIL(9)+": "+"Invalid S/L type"
   ELSE IF VALIDATESTATUS=TARGETINVALIDSHARECODE THEN
    ERRORDETAIL(9)=ERRORDETAIL(9)+": "+"Invalid share code"
   ELSE IF VALIDATESTATUS=TARGETLOANZEROPAYOFF THEN
    ERRORDETAIL(9)=ERRORDETAIL(9)+": "+"Loan has $0.00 payoff"
   ELSE IF VALIDATESTATUS=TARGETINVALIDIRSCODE THEN
    ERRORDETAIL(9)=ERRORDETAIL(9)+": "+"Invalid IRS code"
  END

 PRINT "    "+Q+"errorCode"+Q+": "+FORMAT(Q+"999"+Q,ERRORCODE)+","
 NEWLINE
 PRINT SEGMENT("    "+Q+ERRORMSG+Q+": "+
            Q+ERRORDETAIL(ERRORDETAILOFFSET),1,130)+Q
 NEWLINE
END [PROCEDURE]

PROCEDURE VALIDATEACCOUNT
[* Validate the account against targeted account warning codes
** and validate account type
**  PASS    INVALIDACCTYPES  Array of invalid account types (indexed by ACCOUNT:TYPE)
**  RETURN  INVALIDACCTTYPEFOUND  Boolean - targeted account type found
**  RETURN  WARNINGFOUND Boolean - targeted account warning found
*]
 INVALIDACCTTYPEFOUND=FALSE
 IF INVALIDACCTYPES(ACCOUNT:TYPE)=TRUE THEN
  INVALIDACCTTYPEFOUND=TRUE

 WARNINGFOUND=FALSE
 FOR TMPLOOP=1 TO MAXWARNINGTYPES
  DO
   IF WARNINGSACCT(TMPLOOP)=TRUE AND
      ANYWARNING(ACCOUNT,TMPLOOP) THEN
    DO
     WARNINGFOUND=TMPLOOP
     TMPLOOP=MAXWARNINGTYPES
    END
  END
 IF INVALIDACCTTYPEFOUND=TRUE OR
    WARNINGFOUND<>FALSE THEN
  DO
   ERRORCODE=502
   @RGSTATE=STATEEND
   CALL JSONOPEN
   CALL PRINTPROGRAMINFO
   CALL ERRORHANDLER
  END
END [PROCEDURE]

PROCEDURE PRINTPROGRAMINFO
[* Print program info to JSON output
*]
 IF INCLUDEPROGRAMINFO=TRUE THEN
  DO
   PRINT INDENT(BASEINDENT+1)+Q+"programInfo"+Q+": {"
   NEWLINE
   PRINT INDENT(BASEINDENT+2)+Q+"programName"+Q+": "+Q+"BANNO.M2MTRANSFERS.V3.POW"+Q+","
   NEWLINE
   PRINT INDENT(BASEINDENT+2)+Q+"programVersion"+Q+": "+Q+PROGRAMVERSION+Q+","
   NEWLINE
   PRINT INDENT(BASEINDENT+2)+Q+"programLastModDate"+Q+": "+Q+FORMAT("99/99/99-",LASTMODDATE)+LASTMODTIME+Q+","
   NEWLINE
   PRINT INDENT(BASEINDENT+2)+Q+"programNote1"+Q+": "+Q+PROGRAMUPDATENOTE1+Q+","
   NEWLINE
   PRINT INDENT(BASEINDENT+2)+Q+"programNote2"+Q+": "+Q+PROGRAMUPDATENOTE2+Q
   NEWLINE
   PRINT INDENT(BASEINDENT+1)+"},"
   NEWLINE
 END
END [PROCEDURE]

PROCEDURE PULLRGDATA
[* Parse through the data passed back from the UI. Data will be delimited
** with a pipe character. Data passed back will vary based upon the current
** state.
**
** STATE VERIFYMEMBER
**   PASS    @RGUSERCHR1     Member ID | First 3 of last name or business | account type | account ID
** STATE CREATETRAN
**   PASS    @RGUSERCHR1  Source Account | Recip Member ID | Acct Type or ID |
**                        Frequency | Start Date | Day 1 | Day 2
**   PASS    @RGUSERCHR2  First 3 | Nickname
**   PASS    @RGUSERCHR3  Immediate Transfer Comment
**   PASS    @RGUSERCHR4  Transaction Amount
**   PASS    @RGUSERNUM1  Recipient Locator Code (if available)
** STATE EDITTRAN
**   PASS    @RGUSERCHR1  TransferFrequency | Start Date | Day 1| Day 2
**   PASS    @RGUSERCHR2  Internal memo for immediate transfers
**   PASS    @RGUSERCHR3  Transfer Amount
** STATE DELETERECIP
**   PASS    @RGUSERNUM1  Recipient Record Locator
** STATE DELETETRAN
**   PASS    @RGUSERNUM1  Share Transfer Locator
**
**   RETURN  TARGETACCOUNT   Account Number being tested
**   RETURN  TARGETVERIFY3   First three characters of the primary/busines name on the
**                           target account.
**   RETURN  TARGETACCTTYPE
**   RETURN  TARGETSLID
**   RETURN  NEWTRANSRCACCT
**   RETURN  NEWTRANSRCIDTYPE
**   RETURN  NEWTRANSRCID
**   RETURN  NEWTRANRECIPACCT
**   RETURN  NEWTRANRECIPSLID
**   RETURN  NEWTRANRECIPLONGNAME
**   RETURN  NEWTRANRECIPSLIDTYPEFOUND
**   RETURN  NEWTRANSLDESCRIPTION
**   RETURN  NEWTRANRECIPSLIDFOUND
**   RETURN  NEWTRANFREQ
**   RETURN  NEWTRANFREQCHR
**   RETURN  NEWTRANSTARTDATE  Transfer start date
**   RETURN  NEWTRANDAY1 Transfer day 1
**   RETURN  NEWTRANDAY2 Transfer Day 2
**   RETURN  NEWTRANCOMMENT  Transfer comment for immediate transfers
**   RETURN  NEWTRANAMOUNT  Transfer amount
**   RETURN  NEWTRANRECIPLOC  Transfer recipient locator code (External Account)
**   RETURN  TARGETSLTRANLOC  Locator code of the transfer record which is being edited
**   RETURN  SLTRANSFERFOUND  Targeted S/L Transfer locator found (boolean)
**   RETURN  NEWTRANRECIPLOC  Transfer recipient locator code (External Account)
**   RETURN  RECIPLOCATOR  Recipient Record Locator
**   RETURN  TARGETSLTRANLOC  Share Transfer Locator
*]

 VALIDDATA=TRUE

 IF @RGSTATE=STATEVERIFYMEMBER THEN
  DO
[* @RGUSERCHR1
*]
   DATALINE=@RGUSERCHR1
   CALL PARSEDATALINE
   TARGETACCOUNT=DATALINEFIELD(1)
   TARGETVERIFY3=UPPERCASE(DATALINEFIELD(2))
   TARGETACCTTYPE=DATALINEFIELD(3)

   TMPSLID=DATALINEFIELD(4)
   CALL NORMALIZESLID
   TARGETSLID=TMPSLID

   IF LENGTH(TARGETACCOUNT)<10 THEN
    TARGETACCOUNT=REPEATCHR("0",10-LENGTH(TARGETACCOUNT))+TARGETACCOUNT
  END
 ELSE IF @RGSTATE=STATECREATETRAN THEN
  DO
[* @RGUSERCHR1
*]
   SOONESTAVAILABLE=FALSE
   DATALINE=@RGUSERCHR1

   BNODEBUGMSG="@RGUSERCHR1='"+@RGUSERCHR1+"'"
   CALL BNODEBUGMSGADD
   BNODEBUGMSG="DATALINE='"+DATALINE+"'"
   CALL BNODEBUGMSGADD

   CALL PARSEDATALINE

   BNODEBUGMSG="PROCEDURE CREATETRAN...:"
   CALL BNODEBUGMSGADD
   BNODEBUGMSG="  DATALINEFIELD(1):"+DATALINEFIELD(1)
   CALL BNODEBUGMSGADD
   BNODEBUGMSG="  DATALINEFIELD(2):"+DATALINEFIELD(2)
   CALL BNODEBUGMSGADD
   BNODEBUGMSG="  DATALINEFIELD(3):"+DATALINEFIELD(3)
   CALL BNODEBUGMSGADD
   BNODEBUGMSG="  DATALINEFIELD(4):"+DATALINEFIELD(4)
   CALL BNODEBUGMSGADD
   BNODEBUGMSG="  DATALINEFIELD(5):"+DATALINEFIELD(5)
   CALL BNODEBUGMSGADD
   BNODEBUGMSG="  DATALINEFIELD(6):"+DATALINEFIELD(6)
   CALL BNODEBUGMSGADD
   BNODEBUGMSG="  DATALINEFIELD(7):"+DATALINEFIELD(7)
   CALL BNODEBUGMSGADD

[* Source Acct Detail *]
   NEWTRANSOURCE=DATALINEFIELD(1)
   NEWTRANSRCACCT=SEGMENT(NEWTRANSOURCE,1,10)
   NEWTRANSRCIDTYPE=SEGMENT(NEWTRANSOURCE,11,11)
   NEWTRANSRCID=SEGMENT(NEWTRANSOURCE,12,LENGTH(NEWTRANSOURCE))


   BNODEBUGMSG="NEWTRANSOURCE:"+NEWTRANSOURCE+"   "+
               "NEWTRANSRCACCT:"+NEWTRANSRCACCT+"   "+
               "NEWTRANSRCIDTYPE:"+NEWTRANSRCIDTYPE+"   "+
               "NEWTRANSRCID:"+NEWTRANSRCID
   CALL BNODEBUGMSGADD


[* Recipent Acct Detail]
   NEWTRANRECIPACCT=DATALINEFIELD(2)
   IF LENGTH(NEWTRANRECIPACCT)<10 THEN
    NEWTRANRECIPACCT=REPEATCHR("0",10-LENGTH(NEWTRANRECIPACCT))+NEWTRANRECIPACCT
   NEWTRANRECIPSLID=DATALINEFIELD(3)

[* Recipient is either "S" or "L" and share/loan ID
*]


   TARGETSLIDFOUND=FALSE
   NEWTRANRECIPSLIDTYPEFOUND=UPPERCASE(SEGMENT(NEWTRANRECIPSLID,1,1))
   TMPSLID=SEGMENT(NEWTRANRECIPSLID,2,LENGTH(NEWTRANRECIPSLID))
   CALL NORMALIZESLID
   NEWTRANRECIPSLIDFOUND=TMPSLID

   BNODEBUGMSG="NEWTRANRECIPSLID:"+NEWTRANRECIPSLID+
               "   NEWTRANRECIPSLIDTYPEFOUND:"+NEWTRANRECIPSLIDTYPEFOUND+
               "   TMPSLID:"+TMPSLID
   CALL BNODEBUGMSGADD

   BNODEBUGMSG="Targeting by specific ID: "+NEWTRANRECIPACCT+" "+UPPERCASE(NEWTRANRECIPSLIDTYPEFOUND)+" '"+NEWTRANRECIPSLIDFOUND+"'"
   CALL BNODEBUGMSGADD

   FOR ACCOUNT NEWTRANRECIPACCT
    DO
     NEWTRANRECIPLONGNAME=NAME:LONGNAME
     IF UPPERCASE(NEWTRANRECIPSLIDTYPEFOUND)="S" THEN
      DO
       FOR EACH SHARE WITH (SHARE:ID=NEWTRANRECIPSLIDFOUND AND
                            SHARE:IRSCODE=0 AND
                            PARAMALLOWABLESHARECODES(SHARE:SHARECODE)=TRUE)
        DO
         SVCCODEFOUND=FALSE
         FOR TMPLOOP=1 TO SVCCODEMAX
          DO
           IF SERVICEIN(TMPLOOP)=TRUE AND
              ANYSERVICE(SHARE,TMPLOOP) THEN
            DO
             SVCCODEFOUND=TRUE
             TMPLOOP=SVCCODEMAX
            END
          END
         BNODEBUGMSG=FORMAT("SHARE SVC CODE FOUND=9",SVCCODEFOUND)
         CALL BNODEBUGMSGADD
         IF SVCCODEFOUND=TRUE THEN
          DO
           TARGETSLIDFOUND=TRUE
           NEWTRANSLDESCRIPTION=SHARE:NICKNAME
           IF NEWTRANSLDESCRIPTION="" THEN
            NEWTRANSLDESCRIPTION=SHARE:DESCRIPTION
          END
        END

      END [IF UPPERCASE(NEWTRANRECIPSLIDTYPEFOUND)="S" THEN]
     ELSE
      DO
       FOR EACH LOAN WITH LOAN:ID=NEWTRANRECIPSLIDFOUND
        DO
         SVCCODEFOUND=FALSE
         FOR TMPLOOP=1 TO SVCCODEMAX
          DO
           IF SERVICEIN(TMPLOOP)=TRUE AND
              ANYSERVICE(LOAN,TMPLOOP) THEN
            DO
             SVCCODEFOUND=TRUE
             TMPLOOP=SVCCODEMAX
            END
          END
         BNODEBUGMSG=FORMAT("LOAN SVC CODE FOUND=9",SVCCODEFOUND)
         CALL BNODEBUGMSGADD
         IF SVCCODEFOUND=TRUE THEN
          DO
           TARGETSLIDFOUND=TRUE
           NEWTRANSLDESCRIPTION=LOAN:NICKNAME
           IF NEWTRANSLDESCRIPTION="" THEN
            NEWTRANSLDESCRIPTION=LOAN:DESCRIPTION
          END
        END
      END
    END

   NEWTRANFREQCHR=DATALINEFIELD(4)
   CALL FINDFREQNUM

   IF LOWERCASE(DATALINEFIELD(5))="soonest" THEN
    SOONESTAVAILABLE=TRUE
   ELSE
    NEWTRANSTARTDATE=DATEVALUE(DATALINEFIELD(5))

   NEWTRANDAY1=VALUE(DATALINEFIELD(6))
   NEWTRANDAY2=VALUE(DATALINEFIELD(7))
[* @RGUSERCHR2
*]
   DATALINE=@RGUSERCHR2
   CALL PARSEDATALINE
   NEWTRANFIRST3=DATALINEFIELD(1)
   NEWTRANNICKNAME=DATALINEFIELD(2)
[* @RGUSERCHR3
*]
   NLTSCHR=@RGUSERCHR3
   CALL NLS
   NEWTRANCOMMENT=NLTSCHR
[* @RGUSERCHR4
*]
   NLTSCHR=@RGUSERCHR4
   CALL NLTS
   TMPAMTCHR=NLTSCHR
   CALL AMTCHRTOMONEY
[* @RGUSERNUM1
*]
   NEWTRANRECIPLOC=@RGUSERNUM1
  END
 ELSE IF @RGSTATE=STATEEDITTRAN THEN
  DO
[* @RGUSERNUM1
*]
   TARGETSLTRANLOC=@RGUSERNUM1
   SLTRANSFERFOUND=FALSE
   FOR EACH SHARE
    DO
     FOR EACH SHARE TRANSFER WITH (SHARE TRANSFER:LOCATOR=TARGETSLTRANLOC)
      DO
       SLTRANSFERFOUND=TRUE
       NEWTRANSRCACCT=ACCOUNT:NUMBER
       NEWTRANSRCIDTYPE="S"
       NEWTRANSRCID=SHARE:ID
       NEWTRANSRCAMOUNT=SHARE TRANSFER:AMOUNT
       NEWTRANRECIPACCT=SHARE TRANSFER:ACCOUNTNUMBER
       IF SHARE TRANSFER:IDTYPE=0 THEN
        NEWTRANRECIPSLIDTYPEFOUND="S"
       ELSE
        NEWTRANRECIPSLIDTYPEFOUND="L"
       NEWTRANRECIPSLIDFOUND=SHARE TRANSFER:ID
      END
    END UNTIL SLTRANSFERFOUND=TRUE
   IF SLTRANSFERFOUND=FALSE THEN
    DO
     ERRORCODE=507
     @RGSTATE=STATEEND
     CALL JSONOPEN
     CALL PRINTPROGRAMINFO
     CALL ERRORHANDLER
     CALL JSONCLOSE
    END
   ELSE
    DO

[* @RGUSERCHR1
*]
     DATALINE=@RGUSERCHR1
     CALL PARSEDATALINE
     NEWTRANFREQCHR=DATALINEFIELD(1)
     CALL FINDFREQNUM
     NEWTRANSTARTDATE=DATEVALUE(DATALINEFIELD(2))
     NEWTRANDAY1=VALUE(DATALINEFIELD(3))
     NEWTRANDAY2=VALUE(DATALINEFIELD(4))

[* @RGUSERCHR2
*]
     NLTSCHR=@RGUSERCHR2
     CALL NTS
     NEWTRANCOMMENT=NLTSCHR

[* @RGUSERCHR3
*]
     NLTSCHR=@RGUSERCHR3
     CALL NLTS
     TMPAMTCHR=NLTSCHR
     CALL AMTCHRTOMONEY

     FOR ACCOUNT NEWTRANRECIPACCT
      DO
       NEWTRANRECIPLONGNAME=NAME:LONGNAME
       FOR EACH SHARE WITH (SHARE:ID=NEWTRANRECIPSLIDFOUND)
        DO
         NEWTRANSLDESCRIPTION=SHARE:NICKNAME
         IF NEWTRANSLDESCRIPTION="" THEN
          NEWTRANSLDESCRIPTION=SHARE:DESCRIPTION
        END
      END
    END
  END
 ELSE IF @RGSTATE=STATEDELETERECIP THEN
  DO
   RECIPLOCATOR=@RGUSERNUM1
  END
 ELSE IF @RGSTATE=STATEDELETETRAN THEN
  DO
   TARGETSLTRANLOC=@RGUSERNUM1
  END
END [PROCEDURE]

PROCEDURE VALIDATEACCOUNTNUM
 VALIDACCTNUM=TRUE

 NLTSCHR=TMPACCT
 CALL NLTS
 TMPACCT=NLTSCHR

 IF LENGTH(TMPACCT)<1 OR
    LENGTH(TMPACCT)>10 THEN
  VALIDACCTNUM=FALSE
 ELSE
  DO
   FOR TMPLOOP=1 TO LENGTH(TMPACCT)
    DO
     IF CHARACTERSEARCH("0123456789",SEGMENT(TMPACCT,TMPLOOP,TMPLOOP))=0 THEN
      DO
       VALIDACCTNUM=FALSE
       TMPLOOP=LENGTH(TMPACCT)
      END
    END
  END
 TMPACCT=REPEATCHR("0",10-LENGTH(TMPACCT))+TMPACCT
END

PROCEDURE EXPIRERECIPIENT
[* Delete targeted recipient record (External Account) and output
** success or error code detail. Include updated current state in
** output
**  PASS    RECIPLOCATOR  Locator code of record to delete
**  RETURN  FMERROR       Expiration attempt error attempt return
**  RETURN  ERRORCODE     Error code if attempt failed
*]
 FMPERFORM REVISE EXTERNALACCOUNT LOC RECIPLOCATOR (0,0,FMERROR)
  DO
   SET EXPIRATIONDATE TO SYSTEMDATE
  END
 IF FMERROR<>"" THEN
  DO
   ERRORCODE=506
   @RGSTATE=STATEEND
   CALL JSONOPEN
   CALL PRINTPROGRAMINFO
   CALL ERRORHANDLER
   CALL JSONCLOSE
  END
 ELSE
  DO
   NLTSCHR=FORMAT("#######9",RECIPLOCATOR)
   CALL NLS
   PRINT "{"
   NEWLINE
   PRINT "  "+Q+"results"+Q+": {"
   NEWLINE
   PRINT "    "+Q+"success"+Q+": true,"
   NEWLINE
   PRINT "    "+Q+"recipientLoc"+Q+": "+Q+NLTSCHR+Q+","
   NEWLINE

   WHILELIMIT=1000000
   FOR ACCOUNT ACCOUNT:NUMBER
    DO
     CALL READPREFSETTINGS
     CALL CALCLIMITS
     IF ERRORCODE=0 THEN
      DO
       CALL BUILDSHARELOANLIST

       CALL BUILDRECIPLIST
       CALL BUILDSLTRANSFERLIST
      END
    END
   BASEINDENT=1
   CALL PRINTPROGRAMINFO
   CALL PRINTCURRENTSTATE
   PRINT "}"
  END
END [PROCEDURE]

PROCEDURE FINDFREQNUM
[* Find the numeric frequency corresponding to the Banno text version of the frequency
**  PASS    NEWTRANFREQCHR    Transer frequency in character format
**  RETURN  NEWTRANFREQFOUND  Matching frequency found? Boolean TRUE/FALSE
**  RETURN  NEWTRANFREQ       Corresponding Share Transfer frequency number
*]
 NEWTRANFREQFOUND=FALSE
 NEWTRANFREQ=-1

 FOR FREQLOOP=0 TO TRANSFERFREQMAX
  DO
   IF UPPERCASE(NEWTRANFREQCHR)=UPPERCASE(TRANSFERFREQCHR(TRANFREQALT,FREQLOOP)) THEN
    DO
     NEWTRANFREQ=FREQLOOP
     NEWTRANFREQFOUND=TRUE
    END
  END
END [PROCEDURE]

PROCEDURE AMTCHRTOMONEY
[* Convert text monetary amount to money value. Text value may or may not
** have a decimal with or without trailing digits
**  PASS    TMPAMTCHR       Monetary value in character format
**  RETURN  NEWTRANAMOUNT   Converted monetary value in money format
*]
 NEWTRANAMOUNT=$0.00

 POS=CHARACTERSEARCH(TMPAMTCHR,".")
 IF POS>0 THEN
  DO
   IF POS=LENGTH(TMPAMTCHR)-1 THEN
    NEWTRANAMOUNT=MONEY(VALUE(TMPAMTCHR+"0"))
   ELSE
    NEWTRANAMOUNT=MONEY(VALUE(TMPAMTCHR))
  END
 ELSE
  NEWTRANAMOUNT=MONEY(VALUE(TMPAMTCHR)*100)
END [PROCEDURE]

PROCEDURE NORMALIZESLID
[* Trim or pad the user input to the required 2 or 4 digit S/L ID
**  PASS    TMPSLID   S/L ID user input
**  RETURN  TMPSLID   Correct length S/L ID
*]

 IF TMPSLID="na" THEN
  TMPSLID=""
 IF TMPSLID<>"" THEN
  DO
   TMPSLID="0000"+TMPSLID
   TMPSLID=SEGMENT(TMPSLID,(LENGTH(TMPSLID)-SLIDLEN)+1,LENGTH(TMPSLID))
  END
END [PROCEDURE]

#INCLUDE "BNO.INTERACTIVE.PRO"
#INCLUDE "RB.LISTEXPAND"

