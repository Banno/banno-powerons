	[*
**  PowerOn Name:       BANNO.M2MTRANSFERS.V3.POW
**  Letterfile Name:    BANNO.M2MTRANSFERS.V3.CFG
**
**  Copyright 2021-2024 Jack Henry and Associates
**
**  This Banno PowerOn allows the user to perform a transfer
**  (immediate or scheduled) to another CU member
**
**  For more information check
**  https://github.com/Banno/banno-powerons
**
**  Banno is not responsible for any modifications to this file
**  made by unauthorized personnel.
**
**  Modification History:
**   Ver. 1.0.0  07/21/21 T. Kainz - Original Programming
**   Ver. 1.1.0  10/11/21 T. Kainz - Adding check for service code for
**               transfer in on credited share. Added check for IRS code
**               on credited share - must be 0. Added parameter options
**               to allow transfers into clubs or certs. Corrected issue
**               preventing recurring transfers to loans. Set debugmode
**               to on as default for first 45 days after latest update.
**               Removed ability for the user to send funds to account
**               type only, now requiring a specific share or loan ID
**   Ver. 1.1.1  12/03/21 T. Kainz - Corrected transfer locator format
**               issue in JSON output when locator is over 999. Added
**               S/L ID Length to JSON output. Added procedure to
**               normalize S/L ID length. Added check for same account
**               transfer (not allowed). If tran counts are being
**               enforced, and transfer initiated on system date is
**               deleted (expired) or edited, adjust transfer count and
**               transfer amount total accordingly. Added immed. transfer
**               comment parameter.
**   Ver. 1.1.2  3/28/2022 J. Carson - Corrected issue with CREATETRANSFER
**               procedure where a stale transfer record is created if the
**               start date is before the system date (GOODNIGHT has changed
**               the date before midnight). Fix will perform an immediate
**               transfer in that case.
**   Ver. 1.1.3  03/29/2022 T. Kainz - Corrected issue where a saved
**               recipient with a loan as a target was being recalled
**               as a share
**   Ver. 3.0.0  10/10/2022 T. Kainz
**               * Program ver. bumped to v 3.0.0 to correspond with UX
**                 version update to v3.
**               * Added JSON flag for cross-accounts for UX use.
**               * Modified logic determining if a transfer is immediate or
**                  scheduled based upon UX request.
**               * Added Reg E flag to be set to true for immediate transfer
**               * Added Share transfer user created check to logic determining
**                  whether to allow edit of manually created share transfers.
**   Ver. 3.1.0  04/19/2023 R. Robison - Added support for label soft text on
**               the member name and id input.  These labels are for the sub-title
**               text under the main labels.
**   Ver. 3.2.0  11/02/2023 R. Robison - Code refactor including framework for
**               the optional share ID feature.
**   Ver. 3.2.1  01/31/2024 T. Kainz -
**               * Corrected issue where cross-account loans were being allowed
**                 when only shares were requested.
**               * Updated last name verification to properly process last names
**                 stored with one or more spaces at the beginning.
**               * Forced limitation of comment length for immediate transfers
**                 to 39 characters to avoid failed xfers.
**               * Updated procedures for building Share/Loan list.
**               * Check for double-quotes in Share/Loan description and
**                 nickname fields and replace with single-quotes.
**   Ver. 3.2.2  07/10/2024 J. Keenan -
**               * Corrected issue so that the loggingErrorMessage
**                 for ineligible account type now indicates when the
**                 account type is invalid and lists the account type.
**               * Added Program Installation Date parameter setting.
**               * Set debugmode to on as default for first 90 days after
**                 latest update. Can be overridden by hidden parameter  "DB:".
**   Ver. 3.2.3  09/04/2024 JuCarson - Banno
**               * Fixed error where backslashes from share nickname or description
**                 caused json error.
**   Ver. 3.2.4  10/14/2024 T. Kainz -
**               * Modified logic used to determine transfer record editability.
**                 * Program now matches the user number who created the transfer
**                   record against the SymXchange user number and if it matches, then
**                   transfer record is automatically editable.
**                 * Modified AE parameter setting to also allow a list entry in addition
**                   to a TRUE/FALSE entry. If the transfer record was created by one
**                   of the user numbers listed, transfer is editable.
**               * Modified external record creation to only occur when member elects
**                 to save the record (nickname field is not blank).
**               * Added additional checks for invalid characters in Share/Loan Nicknames
**                 and descriptions.
**   Ver. 3.2.5  10/28/2024 T. Kainz - Banno
**               * Modified displayed description of recipient S/L when existing transfer
**                 references a saved account with an external account record which has
**                 been expired or deleted.
**   Ver. 3.2.6  12/11/2024 T. Kainz - Banno
**               * Corrected issue where program was erring when no transfer record FM
**                 history was found indicating the record creation date
**   Ver. 3.3.0  02/04/2025 R. Robison - Banno
**               * Adding support for errorDisplayMessage to accomodate memo mode message
**
**  DO NOT MODIFY THIS FILE UNLESS YOU KNOW WHAT YOU'RE DOING!
*]
SYMCONNECT
STATELESS

TARGET=ACCOUNT

DEFINE
 #INCLUDE "RD.GETDATA.DEF"
 #INCLUDE "RB.LISTEXPAND.DEF"
 #INCLUDE "BNOLB.SLLISTBUILD.DEF"

 TRUE                      = 1
 FALSE                     = 0
 CONFIGFILENAME            = "BANNO.M2MTRANSFERS.V3.CFG"

 STATEPRELOADDATA          = "PRELOADDATA"
 STATEVERIFYMEMBER         = "VERIFYMEMBER"
 STATECREATETRAN           = "CREATETRAN"
 STATEEDITTRAN             = "EDITTRAN"
 STATEDELETERECIP          = "DELETERECIP"
 STATEDELETETRAN           = "DELETETRAN"
 STATEEND                  = "STATEEND"

 [* Error code setup
*]
 BNOERRCODEMEMOMODE        = 500
 BNOERRCODECONFIGREAD      = 501
  BNOERRMODOPEN            = "[configuration file name] open error - [system generated letter file read error message]"
  BNOERRMODREAD            = "[configuration file name] read error - [system generated letter file read error message]"
  BNOERRMODINVPARAM        =  "Invalid Parameter in CFG file"
 BNOERRCODEINVSOURCE       = 502
  BNOERRMODACCESSTYPE      = "Pref Access type 3 not found"
  BNOERRMODACCTWARN        = "Acct Warning [warning code]"
  BNOERRMODNOXFERFROM      = "No eligible transfer from shares/loans"
  BNOERRMODACCTTYPE        = "Acct Type [account type]"
 BNOERRCODEINVRECIP        = 503
 BNOERRCODEMISSINGINFO     = 504
  BNOERRMODCALCMBRLIMITS   = "Cannot calc member limits"
 BNOERRCODEINVINPUT        = 505
 BNOERRCODEPROCRECIP       = 506
 BNOERRCODEPROCXFER        = 507
  BNOERRMODXFRLOC          = "Target s/l xfer Loc [locator] not found"
  BNOERRMODTARGETID        = "Target ID not found or invalid"
 BNOERRCODEUNDEFINED       = 508
 BNOERRCODEMBRVERIFY       = 509
  BNOERRMODMBRNOTFOUND     = "Member account not found"
  BNOERRMODACCTCLOSED      = "Account Closed - [close date]"
  BNOERRMODNAMEVERIFY      = "Name verification failed"
  BNOERRMODSAMEMBR         = "Must be a different member account number"
  BNOERRMODSLCLOSED        = "S/L closed or charged-off - [date]"
  BNOERRMODSLNOTFOUND      = "S/L ID not found"
  BNOERRMODNOVALIDSL       = "No valid share or loan found"
  BNOERRMODNOSVCCODE       = "S/L missing service code"
  BNOERRMODINVSLTYPE       = "Invalid S/L type"
  BNOERRMODINVSLCODE       = "Invalid share code"
  BNOERRMODZEROPAYOFF      = " Loan has $0.00 payoff"
  BNOERRMODINVIRSCODE      = " Invalid IRS code" 
 BNOERRCODEINVACCTID       = 510
 BNOERRCODELIMITEXCEED     = 511

 DATENULL                  = '--/--/--'

 ACTUALLAST3               = CHARACTER
 BASEINDENT                = NUMBER
 BNODEBUGCOUNT             = NUMBER
 BNODEBUGMSG               = CHARACTER
 BNODEBUGMSGLIST           = CHARACTER ARRAY(199)
 BNODEBUGMSGMAX            = 199
 CAC                       = CHARACTER
 CN                        = CHARACTER
 DATAFIELDCOUNT            = NUMBER
 DATALINE                  = CHARACTER
 DATALINEFIELD             = CHARACTER ARRAY(10)
 DATALINEFIELDMAX          = 10
 DEBUGLOOP                 = NUMBER
 DEBUGMODE                 = NUMBER
 DEBUGMODEOFF              = 0
 DEBUGMODEON               = 1
 ERRORMSG                  = CHARACTER
 EXTACCTNUM                = CHARACTER
 EXTEXPIRE                 = DATE
 EXTFINAME                 = CHARACTER
 EXTPRIMARY                = CHARACTER
 EXTRECFOUND               = NUMBER
 EXTSTATUS                 = NUMBER
 FALSECHR                  = "false"
 FMERROR                   = CHARACTER
 FREQLOOP                  = NUMBER
 I                         = NUMBER
 IDTYPETOCHR               = CHARACTER ARRAY(3)
 INCLUDEPROGRAMINFO        = NUMBER
 INDENT                    = CHARACTER ARRAY(19)
 INDENTMAX                 = 19
 INVALIDACCTTYPEFOUND      = NUMBER
 INVALIDACCTYPES           = NUMBER ARRAY(9999)
 LASTMODDATE               = DATE
 LASTMODTIME               = CHARACTER
 LFERROR                   = CHARACTER
 LFLINE                    = CHARACTER
 LFNUMBER                  = NUMBER
 MAXWARNINGTYPES           = NUMBER
 MBRAMOUNTACTUAL           = MONEY
 MBRAMOUNTACTUALCHR        = CHARACTER
 MBRAMOUNTLIMIT            = MONEY
 MBRAMOUNTLIMITCALC        = MONEY
 MBRAMOUNTLIMITCALCCHR     = CHARACTER
 MBRAMOUNTLIMITCHR         = CHARACTER
 MBRCOUNTACTUAL            = NUMBER
 MBRCOUNTACTUALCHR         = CHARACTER
 MBRCOUNTLIMIT             = NUMBER
 MBRCOUNTLIMITCALC         = NUMBER
 MBRCOUNTLIMITCALCCHR      = CHARACTER
 MBRCOUNTLIMITCHR          = CHARACTER
 MBRINDIVIDUALLIMIT        = MONEY
 MBRINDIVIDUALLIMITCHR     = CHARACTER
 MBRINDIVLIMITCALC         = MONEY
 MBRINDIVLIMITCALCCHR      = CHARACTER
 MBRLASTTRANDATE           = DATE
 NAMEFOUND                 = NUMBER
 NEWLASTTRANDATE           = DATE
 NEWRECIPACCTLOC           = NUMBER
 NEWSLTRANSFERLOC          = NUMBER
 NEWTRANAMOUNT             = MONEY
 NEWTRANCOMMENT            = CHARACTER
 NEWTRANDAY1               = NUMBER
 NEWTRANDAY2               = NUMBER
 NEWTRANFIRST3             = CHARACTER
 NEWTRANFREQ               = NUMBER
 NEWTRANFREQCHR            = CHARACTER
 NEWTRANFREQFOUND          = NUMBER
 NEWTRANNICKNAME           = CHARACTER
 NEWTRANRECIPACCT          = CHARACTER
 NEWTRANRECIPLOC           = NUMBER
 NEWTRANRECIPLONGNAME      = CHARACTER
 NEWTRANRECIPSLID          = CHARACTER
 NEWTRANRECIPSLIDFOUND     = CHARACTER
 NEWTRANRECIPSLIDTYPE      = NUMBER
 NEWTRANRECIPSLIDTYPEFOUND = CHARACTER
 NEWTRANSLDESCRIPTION      = CHARACTER
 NEWTRANSOURCE             = CHARACTER
 NEWTRANSRCACCT            = CHARACTER
 NEWTRANSRCAMOUNT          = MONEY
 NEWTRANSRCID              = CHARACTER
 NEWTRANSRCIDTYPE          = CHARACTER
 NEWTRANSTARTDATE          = DATE
 NEWXFERAMOUNT             = MONEY
 NEWXFERCOUNT              = NUMBER
 TRANSFERCREATEDATE        = DATE
 TRANSFERCREATEUSER        = NUMBER
 PA3FOUND                  = NUMBER
 PAACCOUNTTEST             = CHARACTER
 JSONPROPNAME              = CHARACTER

 PARAMALLOWEDIT            = NUMBER
 PARAMEDITUSERLIST         = CHARACTER
 PARAMCROSSACCTACCESS      = NUMBER
 PARAMENFORCELIMITS        = NUMBER
 PARAMINELIGIBLEACCTS      = CHARACTER
 PARAMINSTAMOUNTLIMIT      = MONEY
 PARAMINSTCOUNTLIMIT       = NUMBER
 PARAMINSTINDIVLIMIT       = MONEY
 PARAMMEMOMODE             = NUMBER
 PARAMNAME                 = CHARACTER
 PARAMNTSLTYPE             = NUMBER
 PARAMVALIDATIONERROR      = NUMBER
 PARAMVALIDATIONNAMETYPES  = CHARACTER
 PARAMVALUE                = CHARACTER
 PARAMWARNINGSACCT         = CHARACTER
 PARAMALLOWABLESHARECODES  = NUMBER ARRAY(3)
 PARAMALLOWCLUBS           = NUMBER
 PARAMALLOWCERTS           = NUMBER
 PARAMSIDOPTIONAL          = NUMBER
 PARAMTRANCOMMENT          = CHARACTER
 PARAMIDLENTEST            = NUMBER
 PARAMLBLMEMBERNAME        = CHARACTER(80)
 PARAMLBLID                = CHARACTER(80)
 PARAMTESTMODE             = NUMBER
 PARAMTESTACCTLIST         = CHARACTER
 PARAMINSTALLDATE          = DATE
 PARAMDEBUGMODE            = NUMBER
 PARAMDEBUGMODECHR         = CHARACTER

 PASLIDTEST                = CHARACTER
 PASLIDTYPETEST            = NUMBER
 POS                       = NUMBER
 PREFACCESSMATCH           = NUMBER
 PREFFOUND                 = NUMBER
 PREFLOC                   = NUMBER
 PREFUPDATEERROR           = CHARACTER
 PROGRAMUPDATENOTE1        = CHARACTER
 PROGRAMUPDATENOTE2        = CHARACTER
 Q                         = CHARACTER
 QQ                        = CHARACTER
 RECIPACCOUNT              = CHARACTER ARRAY(99)
 RECIPCOUNT                = NUMBER
 RECIPEXPIREDATE           = DATE
 RECIPFOUND                = NUMBER
 RECIPINDEX                = NUMBER
 RECIPLASTUNEXPIREDINDEX   = NUMBER
 RECIPLISTEXPIREDATE       = DATE ARRAY(99)
 RECIPLOC                  = NUMBER ARRAY(99)
 RECIPLOCATOR              = NUMBER
 RECIPMAX                  = 99
 RECIPNAME                 = CHARACTER ARRAY(99)
 RECIPNICKNAME             = CHARACTER ARRAY(99)
 RESETPREFVALUES           = NUMBER
 SEQ1                      = NUMBER
 SEQ2                      = NUMBER
 SERVICEIN                 = NUMBER ARRAY(99)
 SLFOUND                   = NUMBER
 SLIDLEN                   = NUMBER
 SLLOOP                    = NUMBER
 SLTRANSFERFOUND           = NUMBER
 SYMXCLIENTNUM             = NUMBER
 SYMXINSTANCE              = NUMBER
 SYSTEMMEMOMODE            = NUMBER
 TARGETACCOUNT             = CHARACTER
 TARGETACCTCLOSEDATE       = DATE
 TARGETACCTTYPE            = CHARACTER
 TARGETSLCLOSECODATE       = DATE
 TARGETSLID                = CHARACTER
 TARGETSLTRANLOC           = NUMBER
 TARGETVERIFY3             = CHARACTER
 TESTCHR                   = CHARACTER
 TESTLOOP                  = NUMBER
 TESTNAME                  = CHARACTER
 THISACCOUNT               = CHARACTER
 TMPAMTCHR                 = CHARACTER
 TMPCHR                    = CHARACTER
 TMPDATE                   = DATE
 TMPEXPIREDATE             = DATE
 TMPLOOP                   = NUMBER
 TMPLOOP2                  = NUMBER
 TMPNUM                    = NUMBER
 TMPSID                    = CHARACTER
 TMPSLID                   = CHARACTER
 TRANACCOUNTNAME           = CHARACTER ARRAY(99)
 TRANCOUNT                 = NUMBER
 TRANCOUNTMAX              = 99
 TRANDAY1                  = NUMBER ARRAY(99)
 TRANDAY2                  = NUMBER ARRAY(99)
 TRANERROR                 = CHARACTER
 TRANFREQALT               = 1
 TRANFREQSTD               = 0
 TRANFREQUENCY             = NUMBER ARRAY(99)
 TRANLOC                   = NUMBER ARRAY(99)
 TRANCREATEDATE            = DATE ARRAY(99)
 TRANCREATEUSER            = NUMBER ARRAY(99)
 TRANNEXTTRANDATE          = DATE ARRAY(99)
 TRANREADONLYSTATUS        = CHARACTER ARRAY(99)
 TRANRECIPACCT             = CHARACTER ARRAY(99)
 TRANRECIPACCTID           = CHARACTER ARRAY(99)
 TRANRECIPACCTTYPE         = CHARACTER ARRAY(99)
 TRANRECIPEXPIREDATE       = DATE ARRAY(99)
 TRANRECIPMBRID            = CHARACTER ARRAY(99)
 TRANRECIPNAME             = CHARACTER ARRAY(99)
 TRANRECIPNICKNAME         = CHARACTER ARRAY(99)
 TRANRECIPTYPECHR          = CHARACTER ARRAY(5)
 TRANSFERFREQCHR           = CHARACTER ARRAY(1,15)
 TRANSFERFREQMAX           = 14
 TRANSOURCEACCT            = CHARACTER ARRAY(99)
 TRANSTARTDATE             = DATE ARRAY(99)
 TRANTYPE                  = NUMBER
 TRANTYPEIMMEDIATE         = 1
 TRANTYPEREGULAR           = 0
 TRANXFERAMOUNT            = MONEY ARRAY(99)
 TRUEFALSECHR              = CHARACTER ARRAY(1)
 VALIDACCOUNT              = NUMBER
 VALIDCHRINPUT1            = CHARACTER
 VALIDPARAMS               = NUMBER
 VALIDRANGEINPUT           = NUMBER
 WARNINGFOUND              = NUMBER
 WARNINGSACCT              = NUMBER ARRAY(999)

 TMPLOCATOR                = NUMBER
 VALIDDATA                 = NUMBER
 VALIDACCTNUM              = NUMBER
 TMPACCT                   = CHARACTER
 NLTSCHR                   = CHARACTER
 VALIDLIMITSEXCEEDED       = NUMBER
 SVCCODEFOUND              = NUMBER
 SVCCODEMAX                = 99
 SHARECODESAVINGS          = 0
 SHARECODEDRAFT            = 1
 SHARECODECERT             = 2
 SHARECODECLUB             = 3
 SHARECODEMAX              = 3
 TARGETSLIDFOUND           = NUMBER
 AUTODEBUGDAYS             = 90
 FOUND                     = NUMBER
 TESTIDLENGTH2             = 2
 TESTIDLENGTH4             = 4
 TMPCOMMENT1               = CHARACTER
 TMPAMOUNT                 = MONEY
 TRANCREATEDATEFOUND       = NUMBER
 TARGETTRANSFERLOC         = NUMBER
 PROGRAMVERSION            = CHARACTER

 BNOTRUEFALSECHR           = CHARACTER ARRAY(2)
 CROSSACCTFLAG             = NUMBER
 SOONESTAVAILABLE          = NUMBER
 VALIDATESTATUS            = NUMBER
 FINDSHARECODE             = NUMBER

 TARGETVERIFIED            = 0
 TARGETSAMEACCT            = 1
 TARGETACCTNOTFOUND        = 2
 TARGETACCTCLOSED          = 3
 TARGETSLCLOSED            = 4
 TARGETNAMENOMATCH         = 5
 TARGETNOTFOUNDBYSLID      = 6
 TARGETNOTFOUNDBYTYPE      = 7
 TARGETNOSERVICECODE       = 8
 TARGETINVALIDSLTYPE       = 9
 TARGETINVALIDSHARECODE    = 10
 TARGETLOANZEROPAYOFF      = 11
 TARGETINVALIDIRSCODE      = 12

 CHARCHECK                 = CHARACTER
 CHARCHECKRETURN           = CHARACTER
 CHARCHECKTMP              = CHARACTER
 CHARCHECKNUM              = NUMBER
 TMPCHAR                   = CHARACTER
 SYMXUSERNUMBER            = NUMBER
 USERSWHOCANEDIT           = NUMBER ARRAY(9999)
 ALLOWEDITFALSE            = 0
 ALLOWEDITTRUE             = 1
 ALLOWEDITUSER             = 2
 EXTERNALRECTOFIND         = CHARACTER

 TMPERRCODE=NUMBER
 TMPDISPLAYLINE=CHARACTER
 TMPLINECOUNT=NUMBER
 CHRVAL=NUMBER

 BNOERRORCODE=NUMBER
 BNOERRORMODIFIER=CHARACTER
 BNOTEXT=CHARACTER
 BNOPARAMFOUND=NUMBER
 BNOPARAMFOUNDINDEX=NUMBER

 PARAMERRDISPLAYMAX=10
 PARAMERRDISPLAYLINESMAX=5
 PARAMERRDISPLAY=NUMBER ARRAY(10,1)
  ERRDISPLAYERRCODE=0
  ERRDISPLAYLINECOUNT=1
 PARAMERRDISPLAYCOUNT=NUMBER
 PARAMERRDISPLAYLINES=CHARACTER ARRAY(10,5)

 BNOERRMAX=99
 BNOERRCODE=NUMBER
 BNOERRMESSAGE=CHARACTER
 BNOERRMODIFIER=CHARACTER
 BNOERRCOUNT=NUMBER
 BNOERRTMPCOUNT=NUMBER
 BNOERRTMPCOUNT2=NUMBER
 BNOERRDISPLAYLIST=CHARACTER
 BNOERRDISPLAYCODE=NUMBER
 BNOERRFOUND=NUMBER
 BNOERRCODES=NUMBER ARRAY(99)
 BNOERRMESSAGES=CHARACTER ARRAY(99)
 BNOERRUNDEFINED="**Undefined**"

 BNOERRDISPLAYMSGSMAX=5
 BNOERRDISPLAYMSG=CHARACTER ARRAY(5)
 BNOERRDISPLAYMSGCOUNT=NUMBER
 BNOERRDISPLAYLINE=CHARACTER
 BNOERRDISPLAYMSGS=CHARACTER ARRAY(99,5)
 BNOERRDISPLAYMSGSCOUNT=NUMBER ARRAY(99)

 CLEANUPVALIDCHRLIST="32-126,128-175,181-184,189,190,198,199,208-216,221,222,224-253"
 CLEANUPVALIDCHRS=NUMBER ARRAY(255)
 CLEANUPVALIDCHRMAX=255

 CHRVALQUOTE=34
 CHRVALBACKSLASH=92
END [DEFINE]

SETUP
 CALL BNOERRINIT

[* Register supported error messages
*] 
 BNOERRCODE=BNOERRCODEMEMOMODE       BNOERRMESSAGE="Program running in memo mode"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODECONFIGREAD     BNOERRMESSAGE="Config file error"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEINVSOURCE      BNOERRMESSAGE="Invalid Source Account"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEINVRECIP       BNOERRMESSAGE="Invalid Recipient Account"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEMISSINGINFO    BNOERRMESSAGE="Insufficient Information"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEINVINPUT       BNOERRMESSAGE="Invalid Input"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEPROCRECIP      BNOERRMESSAGE="Error Processing Recipient Record"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEPROCXFER       BNOERRMESSAGE="Error Processing Transfer Record"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEUNDEFINED      BNOERRMESSAGE="Undefined Error"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEMBRVERIFY      BNOERRMESSAGE="Member verification failed"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEINVACCTID      BNOERRMESSAGE="Account ID incorrect"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODELIMITEXCEED    BNOERRMESSAGE="Request exceeds limits"
 CALL BNOERRADD

 [*  Set any errors that support display messages
 *]
 BNOERRDISPLAYCODE=BNOERRCODEMEMOMODE
 CALL BNOERRDISPLAYLISTADD

 INCLUDEPROGRAMINFO        = TRUE
 PROGRAMVERSION            = "3.3.0"
 LASTMODDATE               = '02/04/2025'
 LASTMODTIME               = "17:30 MST"
 PROGRAMUPDATENOTE1        = "Support for error display message and memo mode restrict"
 PROGRAMUPDATENOTE2        = ""

 TRANRECIPTYPECHR(0)       = "savings"
 TRANRECIPTYPECHR(1)       = "checking"
 TRANRECIPTYPECHR(2)       = "certificate"
 TRANRECIPTYPECHR(3)       = "club"
 TRANRECIPTYPECHR(4)       = "loan"

 Q                         = CTRLCHR(34)
 QQ                        = CTRLCHR(34)
 SYSTEMMEMOMODE            = SYSMEMOMODE
 SYMXUSERNUMBER            = SYSUSERNUMBER
 VALIDCHRINPUT1            = "32-126,128-175,181-184,189,190,198,199,208-216,221,222,224-253"
 FOR TMPLOOP=1 TO INDENTMAX
  DO
   INDENT(TMPLOOP)=REPEATCHR(" ",TMPLOOP*2)
  END
 TRUEFALSECHR(TRUE)        = "true"
 TRUEFALSECHR(FALSE)       = "false"
 DEBUGMODE                 = DEBUGMODEOFF
 MAXWARNINGTYPES           = 999

 IDTYPETOCHR(0)            = "S"
 IDTYPETOCHR(1)            = "L"

 SLIDLEN                   = GETDATANUMBER(GETPARAMIDLENGTH)

[*the following freq references are defined twice because there are some differences
** between Episys and Banno in the frequency type declarations.
*]
 TRANSFERFREQCHR(TRANFREQSTD,0)="demand"
 TRANSFERFREQCHR(TRANFREQALT,0)="once"

 TRANSFERFREQCHR(TRANFREQSTD,1)="annual"
 TRANSFERFREQCHR(TRANFREQALT,1)=""

 TRANSFERFREQCHR(TRANFREQSTD,2)="semi-annual"
 TRANSFERFREQCHR(TRANFREQALT,2)=""

 TRANSFERFREQCHR(TRANFREQSTD,3)="quarterly"
 TRANSFERFREQCHR(TRANFREQALT,3)=""

 TRANSFERFREQCHR(TRANFREQSTD,4)="monthly"
 TRANSFERFREQCHR(TRANFREQALT,4)="monthly"

 TRANSFERFREQCHR(TRANFREQSTD,5)="semi-monthly"
 TRANSFERFREQCHR(TRANFREQALT,5)="semiMonthly"

 TRANSFERFREQCHR(TRANFREQSTD,6)="biweekly skip-first"
 TRANSFERFREQCHR(TRANFREQALT,6)=""

 TRANSFERFREQCHR(TRANFREQSTD,7)="biweekly skip-last"
 TRANSFERFREQCHR(TRANFREQALT,7)=""

 TRANSFERFREQCHR(TRANFREQSTD,8)="biweekly"
 TRANSFERFREQCHR(TRANFREQALT,8)="biWeekly"

 TRANSFERFREQCHR(TRANFREQSTD,9)="weekly"
 TRANSFERFREQCHR(TRANFREQALT,9)="weekly"

 TRANSFERFREQCHR(TRANFREQSTD,10)="immediate"
 TRANSFERFREQCHR(TRANFREQALT,10)="immediate"

 TRANSFERFREQCHR(TRANFREQSTD,11)="weekly skip-first"
 TRANSFERFREQCHR(TRANFREQALT,11)=""

 TRANSFERFREQCHR(TRANFREQSTD,12)="weekly skip-last"
 TRANSFERFREQCHR(TRANFREQALT,12)=""

 TRANSFERFREQCHR(TRANFREQSTD,13)="bimonthly"
 TRANSFERFREQCHR(TRANFREQALT,13)=""

 BNOTRUEFALSECHR(FALSE)="false"
 BNOTRUEFALSECHR(TRUE)="true"
END [SETUP]

PRINT TITLE=""
 CALL INITIALIZEDATA
 CALL SETMEMOMODE
 CALL READCONFIGFILESETTINGS
 IF BNOERRORCODE=0 THEN
  CALL PARAMPOSTPROCESS

 IF BNOERRORCODE=0 THEN
  CALL CHECKFORPA3

 IF BNOERRORCODE=0 THEN
  DO
   IF @RGSTATE=STATEPRELOADDATA THEN
    DO
     CALL READPREFSETTINGS  

     IF PARAMENFORCELIMITS=TRUE AND
      ((PARAMINSTCOUNTLIMIT=0 AND MBRCOUNTLIMIT=0) OR
       (PARAMINSTAMOUNTLIMIT=$0.00 AND MBRAMOUNTLIMIT=$0.00) OR
        PARAMINSTINDIVLIMIT=$0.00 AND MBRINDIVIDUALLIMIT=$0.00) THEN
      DO
       NEWLINE
       CALL JSONOPEN
       CALL PRINTPROGRAMINFO
       BNOERRORCODE=BNOERRCODECONFIGREAD
       BNOERRORMODIFIER=BNOERRMODINVPARAM
       CALL ERRORHANDLER
      END
     
     IF BNOERRORCODE=0 THEN
      CALL VALIDATEACCOUNT  

     IF BNOERRORCODE=0 THEN
      CALL CALCLIMITS

     IF BNOERRORCODE=0 THEN
      DO
       CALL BUILDSHARELOANLIST
       IF BNOSHARECOUNT=0 AND
          BNOLOANCOUNT=0 THEN
        DO
         NEWLINE
         CALL JSONOPEN
         CALL PRINTPROGRAMINFO
         BNOERRORCODE=BNOERRCODEINVSOURCE
         BNOERRORMODIFIER=BNOERRMODNOXFERFROM
         CALL ERRORHANDLER
        END
      END

     IF BNOERRORCODE=0 THEN
      DO  
       CALL BUILDRECIPLIST
       CALL BUILDSLTRANSFERLIST
       BASEINDENT=0
       CALL JSONOPEN
       CALL PRINTPROGRAMINFO
       CALL PRINTCURRENTSTATE
      END
    END
   ELSE IF @RGSTATE=STATEVERIFYMEMBER THEN
    DO
     CALL PULLRGDATA
     CALL VALIDATETARGETACCOUNT
     IF VALIDATESTATUS=TARGETVERIFIED THEN
      DO
       PRINT "{"
       NEWLINE
       PRINT "  "+Q+"results"+Q+": {"
       NEWLINE
       PRINT "    "+Q+"verified"+Q+": true,"
       NEWLINE
       PRINT "    "+Q+"recipientAccountId"+Q+": "+Q+TARGETSLID+Q
       NEWLINE
       PRINT "  }"
       NEWLINE
      END
     ELSE
      DO
       NEWLINE
       CALL JSONOPEN
       CALL PRINTPROGRAMINFO
       BNOERRORCODE=BNOERRCODEMBRVERIFY
       IF VALIDATESTATUS=TARGETACCTNOTFOUND THEN
        BNOERRORMODIFIER=BNOERRMODMBRNOTFOUND
       ELSE IF VALIDATESTATUS=TARGETACCTCLOSED THEN
        DO
         BNOERRORMODIFIER=BNOERRMODACCTCLOSED
         BNOERRORMODIFIER=FORMAT("Account Closed - 99/99/99",TARGETACCTCLOSEDATE)
        END 
       ELSE IF VALIDATESTATUS=TARGETNAMENOMATCH THEN
        BNOERRORMODIFIER=BNOERRMODNAMEVERIFY
       ELSE IF VALIDATESTATUS=TARGETSAMEACCT THEN
        BNOERRORMODIFIER=BNOERRMODSAMEMBR
       ELSE IF VALIDATESTATUS=TARGETSLCLOSED THEN
        DO
         BNOERRORMODIFIER=BNOERRMODSLCLOSED
         BNOERRORMODIFIER=FORMAT("S/L closed or charged-off - 99/99/99",TARGETSLCLOSECODATE)
        END 
       ELSE IF VALIDATESTATUS=TARGETNOTFOUNDBYSLID THEN
        BNOERRORMODIFIER=BNOERRMODSLNOTFOUND
       ELSE IF VALIDATESTATUS=TARGETNOTFOUNDBYTYPE THEN
        BNOERRORMODIFIER=BNOERRMODNOVALIDSL
       ELSE IF VALIDATESTATUS=TARGETNOSERVICECODE THEN
        BNOERRORMODIFIER=BNOERRMODNOSVCCODE
       ELSE IF VALIDATESTATUS=TARGETINVALIDSLTYPE THEN
        BNOERRORMODIFIER=BNOERRMODINVSLTYPE
       ELSE IF VALIDATESTATUS=TARGETINVALIDSHARECODE THEN
        BNOERRORMODIFIER=BNOERRMODINVSLCODE
       ELSE IF VALIDATESTATUS=TARGETLOANZEROPAYOFF THEN
        BNOERRORMODIFIER=BNOERRMODZEROPAYOFF
       ELSE IF VALIDATESTATUS=TARGETINVALIDIRSCODE THEN
        BNOERRORMODIFIER=BNOERRMODINVIRSCODE
        
       CALL ERRORHANDLER  
      END
    END
   ELSE IF @RGSTATE=STATECREATETRAN THEN
    DO
     CALL PULLRGDATA
     IF TARGETSLIDFOUND=FALSE OR
        NEWTRANRECIPSLIDTYPEFOUND="" OR
        NEWTRANRECIPSLIDFOUND="" THEN
      DO
       CALL JSONOPEN
       CALL PRINTPROGRAMINFO
       BNOERRORCODE=BNOERRCODEPROCXFER
       IF TARGETSLIDFOUND=FALSE THEN
        BNOERRORMODIFIER=BNOERRMODTARGETID
       CALL ERRORHANDLER
      END

     IF BNOERRORCODE=0 AND SYSTEMMEMOMODE=TRUE THEN
      DO
       CALL JSONOPEN
       CALL PRINTPROGRAMINFO
       BNOERRORCODE=BNOERRCODEMEMOMODE         
       CALL ERRORHANDLER
      END 
      
     IF BNOERRORCODE=0 THEN 
      DO
       CALL CREATETRANSFER
       IF VALIDLIMITSEXCEEDED=TRUE OR
          TRANERROR<>"" THEN
        DO
         CALL JSONOPEN
         CALL PRINTPROGRAMINFO
         PRINT INDENT(BASEINDENT+2)+Q+"results"+Q+": {"
         NEWLINE  

         IF VALIDLIMITSEXCEEDED=TRUE THEN
          BNOERRORCODE=BNOERRCODEINVINPUT
         ELSE
          BNOERRORCODE=BNOERRCODEPROCXFER
         CALL ERRORHANDLER
         PRINT INDENT(BASEINDENT+1)+"}"
         NEWLINE
        END
      END

     IF BNOERRORCODE=0 THEN 
      DO
       IF PARAMENFORCELIMITS=TRUE THEN
        CALL UPDATEPREFTOTALS
       IF NEWTRANRECIPLOC=0 AND     [Only save the recipient account if the user ]
          NEWTRANNICKNAME<>"" THEN  [has elected to (nickname is not blank)      ]
        CALL CREATERECIPACCT
       BASEINDENT=2
       CALL JSONOUTTRANSUCCESS
       NEWLINE
      END
    END
   ELSE IF @RGSTATE=STATEEDITTRAN THEN
    DO
     CALL PULLRGDATA
     IF SLTRANSFERFOUND=FALSE THEN
      DO
       BNOERRORCODE=BNOERRCODEPROCXFER
       BNOERRORMODIFIER=BNOERRMODXFRLOC
       BNOERRORMODIFIER=FORMAT("Target s/l xfer Loc ######9 not found",TARGETSLTRANLOC)
       CALL JSONOPEN
       CALL PRINTPROGRAMINFO
       CALL ERRORHANDLER
       CALL JSONCLOSE
      END

     IF BNOERRORCODE=0 THEN
      DO
  [* check for amounts before expiration process to avoid issues
  ** where transfer is expired but new transfer cannot be created due to limits.
  *]
       VALIDLIMITSEXCEEDED=FALSE
       IF PARAMENFORCELIMITS=TRUE THEN
        DO
         CALL SETUPLIMITS
         TMPAMOUNT=MBRAMOUNTACTUAL-NEWTRANSRCAMOUNT+NEWTRANAMOUNT
         IF TMPAMOUNT>MBRAMOUNTLIMITCALC OR
            NEWTRANAMOUNT>MBRINDIVLIMITCALC THEN
          VALIDLIMITSEXCEEDED=TRUE
        END  

       IF VALIDLIMITSEXCEEDED=TRUE THEN
        DO
         CALL JSONOPEN
         CALL PRINTPROGRAMINFO
         BNOERRORCODE=BNOERRCODELIMITEXCEED
         CALL ERRORHANDLER
        END
      END

     IF BNOERRORCODE=0 THEN
      CALL EXPIREEXISTINGXFER

     IF BNOERRORCODE=0 THEN
      DO 
       CALL CREATETRANSFER
       IF TRANERROR<>"" THEN
        DO
         CALL JSONOPEN
         CALL PRINTPROGRAMINFO
         BNOERRORCODE=BNOERRCODEPROCXFER
         CALL ERRORHANDLER
        END
       ELSE
        DO
         IF PARAMENFORCELIMITS=TRUE THEN
          CALL UPDATEPREFTOTALS
         BASEINDENT=2
         CALL JSONOUTTRANSUCCESS
        END
      END
    END
   ELSE IF @RGSTATE=STATEDELETERECIP THEN
    DO
     CALL PULLRGDATA
     CALL EXPIRERECIPIENT
    END
   ELSE IF @RGSTATE=STATEDELETETRAN THEN
    DO
     CALL PULLRGDATA
     CALL EXPIREEXISTINGXFER
    END  
  END

 CALL BNOPRINTDEBUG
 IF DEBUGMODE=DEBUGMODEOFF THEN
  NEWLINE
 PRINT INDENT(0)+"}"
 NEWLINE
END [PRINT]

PROCEDURE VALIDATETARGETACCOUNT
[*
]
 BNODEBUGMSG="PROCEDURE VALIDATETARGETACCOUNT - TARGETING - "+
             "ACCT "+TARGETACCOUNT+"  ACCT TYPE:"+
              UPPERCASE(TARGETACCTTYPE)+"  "+
             "TARGETSLID="+TARGETSLID
 CALL BNODEBUGMSGADD

 VALIDATESTATUS=TARGETVERIFIED

 IF TARGETACCOUNT=THISACCOUNT THEN
  VALIDATESTATUS=TARGETSAMEACCT

 IF VALIDATESTATUS=TARGETVERIFIED THEN
  DO
   VALIDATESTATUS=TARGETACCTNOTFOUND
   FOR ACCOUNT TARGETACCOUNT
    DO
     VALIDATESTATUS=TARGETVERIFIED
     TARGETACCTCLOSEDATE=ACCOUNT:CLOSEDATE
     IF TARGETACCTCLOSEDATE<>DATENULL THEN
      VALIDATESTATUS=TARGETACCTCLOSED

[* Validate the first three characters of the last name against eligible name records.
*]
     IF VALIDATESTATUS=TARGETVERIFIED THEN
      DO
       NAMEFOUND=FALSE
       FOR EACH NAME WITH (CHARACTERSEARCH(PARAMVALIDATIONNAMETYPES,FORMAT("99",NAME:TYPE))>0)
        DO
         TESTNAME=NAME:LAST
         CALL VALIDATENAME
        END
       UNTIL NAMEFOUND=TRUE

       IF NAMEFOUND=FALSE THEN
        VALIDATESTATUS=TARGETNAMENOMATCH

       BNODEBUGMSG=FORMAT("END OF NAME CHECK - NAME FOUND:9",NAMEFOUND)
       CALL BNODEBUGMSGADD
      END

[*Attempt to validate the share/loan account type and share/loan ID
*]

     IF UPPERCASE(TARGETACCTTYPE)<>"SHARE" AND
        UPPERCASE(TARGETACCTTYPE)<>"LOAN" THEN
      VALIDATESTATUS=TARGETINVALIDSLTYPE

     IF VALIDATESTATUS=TARGETVERIFIED AND
        UPPERCASE(TARGETACCTTYPE)="SHARE" AND
        TARGETSLID<>"" THEN
      DO
       SLFOUND=FALSE
       FOR EACH SHARE WITH (SHARE:ID=TARGETSLID)
        DO
         SLFOUND=TRUE
         IF SHARE:CLOSEDATE<>DATENULL OR SHARE:CHARGEOFFDATE<>DATENULL THEN
          DO
           VALIDATESTATUS=TARGETSLCLOSED
           IF SHARE:CLOSEDATE<>DATENULL THEN
            TARGETSLCLOSECODATE=SHARE:CLOSEDATE
           ELSE IF SHARE:CHARGEOFFDATE<>DATENULL THEN
            TARGETSLCLOSECODATE=SHARE:CHARGEOFFDATE
          END
         ELSE IF PARAMALLOWABLESHARECODES(SHARE:SHARECODE)=FALSE THEN
          VALIDATESTATUS=TARGETINVALIDSHARECODE
         ELSE IF SHARE:IRSCODE<>0 THEN
          VALIDATESTATUS=TARGETINVALIDIRSCODE


         IF VALIDATESTATUS=TARGETVERIFIED THEN
          DO
           SVCCODEFOUND=FALSE
           TMPLOOP=1
           WHILE TMPLOOP<=SVCCODEMAX AND SVCCODEFOUND=FALSE
            DO
             IF SERVICEIN(TMPLOOP)=TRUE AND ANYSERVICE(SHARE,TMPLOOP) THEN
              SVCCODEFOUND=TRUE

             TMPLOOP=TMPLOOP+1
            END
           IF SVCCODEFOUND=FALSE THEN
            VALIDATESTATUS=TARGETNOSERVICECODE
          END
        END
       UNTIL SLFOUND=TRUE

       IF SLFOUND=FALSE THEN
        VALIDATESTATUS=TARGETNOTFOUNDBYSLID
      END

     IF VALIDATESTATUS=TARGETVERIFIED AND
        UPPERCASE(TARGETACCTTYPE)="SHARE" AND
        TARGETSLID="" THEN
      DO
       CALL FINDBYACCTTYPESHARE
       IF SLFOUND=FALSE THEN
        VALIDATESTATUS=TARGETNOTFOUNDBYTYPE
      END

     IF VALIDATESTATUS=TARGETVERIFIED AND
        UPPERCASE(TARGETACCTTYPE)="LOAN" THEN
      DO
       SLFOUND=FALSE
       FOR EACH LOAN WITH (LOAN:ID=TARGETSLID)
        DO
         SLFOUND=TRUE
         IF LOAN:CLOSEDATE<>DATENULL OR LOAN:CHARGEOFFDATE<>DATENULL THEN
          DO
           VALIDATESTATUS=TARGETSLCLOSED
           IF LOAN:CLOSEDATE<>DATENULL THEN
            TARGETSLCLOSECODATE=LOAN:CLOSEDATE
           ELSE IF LOAN:CHARGEOFFDATE<>DATENULL THEN
            TARGETSLCLOSECODATE=LOAN:CHARGEOFFDATE
          END
         ELSE IF LOAN:PAYOFFAMOUNT<=$0.00 THEN
          VALIDATESTATUS=TARGETLOANZEROPAYOFF

         IF VALIDATESTATUS=TARGETVERIFIED THEN
          DO
           SVCCODEFOUND=FALSE
           TMPLOOP=1
           WHILE TMPLOOP<=SVCCODEMAX AND SVCCODEFOUND=FALSE
            DO
             IF SERVICEIN(TMPLOOP)=TRUE AND ANYSERVICE(LOAN,TMPLOOP) THEN
              SVCCODEFOUND=TRUE

             TMPLOOP=TMPLOOP+1
            END
           IF SVCCODEFOUND=FALSE THEN
            VALIDATESTATUS=TARGETNOSERVICECODE
           ELSE
            DO
             BNODEBUGMSG="Loan ID found - BY TARGET TYPE: "+LOAN:ID
             CALL BNODEBUGMSGADD
            END
          END
        END
       UNTIL SLFOUND=TRUE

       IF SLFOUND=FALSE THEN
        VALIDATESTATUS=TARGETNOTFOUNDBYSLID
      END
    END [FOR ACCOUNT]
  END

 BNODEBUGMSG=" END OF VALIDATETARGETACCOUNT - "+FORMAT("VALIDATESTATUS:99",VALIDATESTATUS)
 CALL BNODEBUGMSGADD

END [PROCEDURE]

PROCEDURE FINDBYACCTTYPESHARE
[*this procedure contains custom logic for finding the share account if the option share ID feature is enabled.
*]
 SLFOUND=FALSE
[
 FINDSHARECODE=1
 IF PARAMALLOWABLESHARECODES(FINDSHARECODE)=TRUE THEN
  CALL FINDBYSHARECODE
 FINDSHARECODE=0
 IF SLFOUND=FALSE AND
    PARAMALLOWABLESHARECODES(FINDSHARECODE)=TRUE THEN
  CALL FINDBYSHARECODE
]
END

PROCEDURE FINDBYSHARECODE

 SLFOUND=FALSE
 FOR EACH SHARE WITH (SHARE:CLOSEDATE=DATENULL AND
                      SHARE:CHARGEOFFDATE=DATENULL AND
                      SHARE:SHARECODE=FINDSHARECODE AND
                      SHARE:IRSCODE=0)
  DO
   TMPLOOP=1
   WHILE TMPLOOP<=SVCCODEMAX AND SLFOUND=FALSE
    DO
     IF SERVICEIN(TMPLOOP)=TRUE AND ANYSERVICE(SHARE,TMPLOOP) THEN
      DO
       SLFOUND=TRUE
       TARGETSLID=SHARE:ID
      END
     TMPLOOP=TMPLOOP+1
    END
  END
 UNTIL SLFOUND=TRUE
END

PROCEDURE VALIDATENAME
[* Validate the primary member's last name against user input
** 3.2.1 - remove leading spaces from last name
**
** PASS    TESTNAME   target account last name
** RETURN  NAMEFOUND  BOOLOEAN name found?
*]
 NLTSCHR=TESTNAME
 CALL NLS
 TESTNAME=NLTSCHR

 ACTUALLAST3=UPPERCASE(SEGMENT(TESTNAME,1,3))
 IF ACTUALLAST3=TARGETVERIFY3 THEN
  NAMEFOUND=TRUE
END [PROCEDURE]

PROCEDURE JSONOUTTRANSUCCESS
[* Generate JSON output for a successful transaction.
*]

 PRINT INDENT(BASEINDENT+0)+"{"
 NEWLINE
 CALL PRINTPROGRAMINFO
 PRINT INDENT(BASEINDENT+1)+Q+",history"+Q+": {"
 NEWLINE
 PRINT INDENT(BASEINDENT+2)+Q+"change"+Q+": {"
 NEWLINE
 PRINT INDENT(BASEINDENT+3)+Q+"application"+Q+": "+Q+"member-to-member-transfers-poweron"+Q+","
 NEWLINE
 IF @RGSTATE=STATECREATETRAN THEN
  DO
   IF TRANTYPE=TRANTYPEIMMEDIATE THEN
    PRINT INDENT(BASEINDENT+3)+Q+"name"+Q+": "+Q+"MemberToMemberTransferScheduled"+Q+","
   ELSE
    PRINT INDENT(BASEINDENT+3)+Q+"name"+Q+": "+Q+"MemberToMemberTransferScheduled"+Q+","
   NEWLINE

  END
 ELSE IF @RGSTATE=STATEDELETETRAN THEN
  DO
   PRINT INDENT(BASEINDENT+3)+Q+"name"+Q+": "+Q+"MemberToMemberTransferDeleted"+Q+","
   NEWLINE
  END
 ELSE IF @RGSTATE=STATEEDITTRAN THEN
  DO
   PRINT INDENT(BASEINDENT+3)+Q+"name"+Q+": "+Q+"MemberToMemberTransferUpdated"+Q+","
   NEWLINE
  END

 PRINT INDENT(BASEINDENT+3)+Q+"toMemberName"+Q+": "+Q+NEWTRANRECIPLONGNAME+Q+","
 NEWLINE
 NLTSCHR=FORMAT("##########9.99",NEWTRANAMOUNT)
 CALL NLS
 PRINT INDENT(BASEINDENT+3)+Q+"amount"+Q+": "+NLTSCHR+","
 NEWLINE

 PRINT INDENT(BASEINDENT+3)+Q+"toAccountName"+Q+": "+Q+NEWTRANSLDESCRIPTION+Q+","
 NEWLINE
 TMPCHR=NEWTRANSRCACCT+NEWTRANSRCIDTYPE+NEWTRANSRCID
 TMPCHR="X"+SEGMENT(TMPCHR,LENGTH(TMPCHR)-6,LENGTH(TMPCHR))
 PRINT INDENT(BASEINDENT+3)+Q+"fromAccountNumberMasked"+Q+": "+Q+TMPCHR+Q+","
 NEWLINE
 TMPCHR=NEWTRANRECIPACCT+NEWTRANRECIPSLIDTYPEFOUND+NEWTRANRECIPSLIDFOUND
 TMPCHR="X"+SEGMENT(TMPCHR,LENGTH(TMPCHR)-6,LENGTH(TMPCHR))
 PRINT INDENT(BASEINDENT+3)+Q+"toAccountNumberMasked"+Q+": "+Q+TMPCHR+Q+","
 NEWLINE

 PRINT INDENT(BASEINDENT+3)+Q+"nextTransferDate"+Q+": "+Q+ FORMAT("99/99/9999",NEWTRANSTARTDATE)+Q

 IF NEWTRANFREQ<>0 THEN
  DO
   PRINT ","
   NEWLINE
   PRINT INDENT(BASEINDENT+3)+Q+"frequency"+Q+": "+Q+NEWTRANFREQCHR+Q+","
   NEWLINE
   NLTSCHR=""
   IF NEWTRANDAY1>0 THEN
    DO
     NLTSCHR=FORMAT("#9",NEWTRANDAY1)
     CALL NLS
    END
   PRINT INDENT(BASEINDENT+3)+Q+"day1"+Q+": "+Q+NLTSCHR+Q+","
   NEWLINE
   NLTSCHR=""
   IF NEWTRANDAY2>0 THEN
    DO
     NLTSCHR=FORMAT("#9",NEWTRANDAY2)
     CALL NLS
    END
   PRINT INDENT(BASEINDENT+3)+Q+"day2"+Q+": "+Q+NLTSCHR+Q
   NEWLINE
  END
 ELSE
  NEWLINE

 PRINT INDENT(BASEINDENT+2)+"}"
 NEWLINE
 PRINT INDENT(BASEINDENT+1)+"},"
 NEWLINE
 PRINT INDENT(BASEINDENT+2)+Q+"results"+Q+": {"
 NEWLINE
 PRINT INDENT(BASEINDENT+3)+Q+"success"+Q+": true"
 NEWLINE
 PRINT INDENT(BASEINDENT+3)+Q+",memoMode"+Q+": "+TRUEFALSECHR(SYSTEMMEMOMODE)
 NEWLINE

 NLTSCHR=FORMAT("#######9",NEWSLTRANSFERLOC)
 CALL NLS
 PRINT INDENT(BASEINDENT+3)+Q+",transferLoc"+Q+": "+Q+NLTSCHR+Q
 NEWLINE

 IF NEWTRANRECIPLOC>0 THEN
  NLTSCHR=FORMAT("#######9",NEWTRANRECIPLOC)
 ELSE
  NLTSCHR=FORMAT("#######9",NEWRECIPACCTLOC)
 IF LENGTH(NLTSCHR)>0 THEN
  CALL NLS

 IF @RGSTATE<>STATEEDITTRAN AND
    @RGSTATE<>STATEDELETETRAN THEN
  DO
   PRINT INDENT(BASEINDENT+3)+Q+",recipientLoc"+Q+": "+Q+NLTSCHR+Q
   NEWLINE
  END

 WHILELIMIT=1000000
 FOR ACCOUNT ACCOUNT:NUMBER
  DO
   CALL READPREFSETTINGS
   CALL CALCLIMITS
   IF BNOERRORCODE=0 THEN
    DO
     CALL BUILDSHARELOANLIST

     CALL BUILDRECIPLIST
     CALL BUILDSLTRANSFERLIST
    END
  END
 BASEINDENT=2
 CALL PRINTCURRENTSTATE
 PRINT "    }"
END [PROCEDURE]

PROCEDURE CREATERECIPACCT
[* Create a new recipient's account for future use
** PASS   NEWTRANNICKNAME
*]
 BNODEBUGMSG="** PROCEDURE CREATERECIPACCT"
 CALL BNODEBUGMSGADD

 TMPEXPIREDATE=DATENULL

 EXTFINAME="M2M:"+NEWTRANNICKNAME
 EXTACCTNUM=NEWTRANRECIPACCT+NEWTRANRECIPSLIDTYPEFOUND+NEWTRANRECIPSLIDFOUND

 BNODEBUGMSG="NEWTRANNICKNAME:"+NEWTRANNICKNAME
 CALL BNODEBUGMSGADD
 EXTPRIMARY=UPPERCASE(NEWTRANFIRST3)
 EXTSTATUS=2
 RECIPFOUND=FALSE
 RECIPEXPIREDATE=DATENULL
 TMPLOCATOR=0
 FOR EACH EXTERNALACCOUNT WITH (EXTERNALACCOUNT:NUMBER=EXTACCTNUM AND
                                EXTERNALACCOUNT:PRIMARYACCOUNTHOLDERNAME=EXTPRIMARY AND
                                EXTERNALACCOUNT:STATUS=EXTSTATUS)
  DO
   BNODEBUGMSG=FORMAT("TESTING EXT REC:9999",EXTERNALACCOUNT:LOCATOR)+
               "  FINAME:"+EXTERNALACCOUNT:FINANCIALINSTITUTIONNAME+
               "  NUMBER:"+EXTERNALACCOUNT:NUMBER+
               "  ACCTHLDRNAME:"+EXTERNALACCOUNT:PRIMARYACCOUNTHOLDERNAME+
               FORMAT("  STATUS:9",EXTERNALACCOUNT:STATUS)
   CALL BNODEBUGMSGADD
   RECIPFOUND=TRUE
   RECIPEXPIREDATE=EXTERNALACCOUNT:EXPIRATIONDATE
   TMPLOCATOR=EXTERNALACCOUNT:LOCATOR
  END UNTIL RECIPFOUND=TRUE

 IF RECIPFOUND=TRUE AND
    RECIPEXPIREDATE<>TMPEXPIREDATE THEN
  DO
   FMPERFORM REVISE EXTERNALACCOUNT LOC TMPLOCATOR (0,0,FMERROR)
    DO
     SET EXPIRATIONDATE TO TMPEXPIREDATE
    END
  END
 ELSE IF RECIPFOUND=FALSE THEN
  DO
   FMPERFORM CREATE EXTERNALACCOUNT LOC AFTERLAST (0,0,NEWRECIPACCTLOC,FMERROR)
    DO
     SET FINANCIALINSTITUTIONNAME TO EXTFINAME
     SET NUMBER TO EXTACCTNUM
     SET PRIMARYACCOUNTHOLDERNAME TO EXTPRIMARY
     SET STATUS TO EXTSTATUS
     SET EXPIRATIONDATE TO TMPEXPIREDATE
    END
  END
 BNODEBUGMSG=FORMAT("RECIPFOUND:9",RECIPFOUND)+FORMAT("   RECIPEXPIREDATE:99/99/99",RECIPEXPIREDATE)
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="CREATE RECIP - EXTFINAME:"+EXTFINAME
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="  EXTACCTNUM:"+EXTACCTNUM+
             "  EXTPRIMARY:"+EXTPRIMARY+FORMAT("  EXTSTATUS:9",EXTSTATUS)+
             FORMAT("  TMPEXPIREDATE:99/99/99",TMPEXPIREDATE)

 CALL BNODEBUGMSGADD
 BNODEBUGMSG="FMERROR:"+FMERROR
 CALL BNODEBUGMSGADD
END [PROCEDURE]

PROCEDURE EXPIREEXISTINGXFER
[* Expire an existing transfer
**
*]
 IF @RGSTATE=STATEEDITTRAN THEN
  DO
   FMPERFORM REVISE SHARE NEWTRANSRCID TRANSFER LOC TARGETSLTRANLOC (0,0,TRANERROR)
    DO
     SET EFFECTIVEDATE TO DATENULL
     SET EXPIRATIONDATE TO SYSTEMDATE
    END
   IF TRANERROR<>"" THEN
    DO
     NEWLINE
     CALL JSONOPEN
     CALL PRINTPROGRAMINFO
     BNOERRORCODE=BNOERRCODEPROCXFER
     CALL ERRORHANDLER
     CALL JSONCLOSE
    END
  END
 ELSE IF @RGSTATE=STATEDELETETRAN THEN
  DO
   SLTRANSFERFOUND=FALSE
   FOR EACH SHARE
    DO
     FOR EACH SHARE TRANSFER WITH (SHARE TRANSFER:LOCATOR=TARGETSLTRANLOC)
      DO
       SLTRANSFERFOUND=TRUE
       NEWTRANRECIPACCT=SHARE TRANSFER:ACCOUNTNUMBER
       NEWTRANRECIPSLIDTYPE=SHARE TRANSFER:IDTYPE
       NEWTRANRECIPSLIDFOUND=SHARE TRANSFER:ID
       NEWTRANSRCACCT=ACCOUNT:NUMBER
       NEWTRANSRCID=SHARE:ID
       NEWTRANFREQ=SHARE TRANSFER:FREQUENCY
       NEWTRANFREQCHR=TRANSFERFREQCHR(TRANFREQALT,NEWTRANFREQ)
       NEWTRANSTARTDATE=SHARE TRANSFER:EFFECTIVEDATE
       IF NEWTRANSTARTDATE=DATENULL THEN
        NEWTRANSTARTDATE=SHARE TRANSFER:NEXTDATE
       NEWTRANDAY1=SHARE TRANSFER:DAY1
       NEWTRANDAY2=SHARE TRANSFER:DAY2
       NEWTRANAMOUNT=SHARE TRANSFER:AMOUNT
       NEWTRANSRCIDTYPE="S"

       NEWTRANRECIPLONGNAME=NAME:LONGNAME
       CALL GETRECIPSLDATA
      END
    END

   IF SLTRANSFERFOUND=FALSE THEN
    DO
     BNOERRORCODE=BNOERRCODEPROCXFER
     CALL JSONOPEN
     CALL PRINTPROGRAMINFO
     CALL ERRORHANDLER
     CALL JSONCLOSE
    END
   ELSE
    DO
     FMPERFORM REVISE SHARE NEWTRANSRCID TRANSFER LOC TARGETSLTRANLOC (0,0,TRANERROR)
      DO
       SET EFFECTIVEDATE TO DATENULL
       SET EXPIRATIONDATE TO SYSTEMDATE
      END
     IF TRANERROR<>"" THEN
      DO
       NEWLINE
       CALL JSONOPEN
       CALL PRINTPROGRAMINFO
       BNOERRORCODE=BNOERRCODEPROCXFER
       CALL ERRORHANDLER
       CALL JSONCLOSE
      END
     ELSE
      DO
       IF PARAMENFORCELIMITS=TRUE THEN
        DO
         CALL UPDATEPREFTOTALS
         CALL SETUPLIMITS
        END
       CALL JSONOUTTRANSUCCESS
      END
    END
  END
END [PROCEDURE]

PROCEDURE FINDTRANCREATEDATE
[* Find the date on which the transfer was created
**
**  PASS   TARGETTRANSFERLOC          The S/L Transfer Locator to lookup
**  RETURN TRANCREATEDATEFOUND        Boolean - Was record found
**  RETURN TRANSFERCREATEDATE         Record created date
*]
 TRANSFERCREATEDATE=DATENULL
 TRANSFERCREATEUSER=9999
 TRANCREATEDATEFOUND=FALSE

 FOR ACCOUNT ACCOUNT:NUMBER
  DO
   FOR EACH FMHISTORY
    DO
     IF FMHISTORY:ACCOUNTNUMBER=ACCOUNT:NUMBER AND
        FMHISTORY:RECORDTYPE=8 AND
        UPPERCASE(FMHISTORY:FIELDNAME)="NEW LOCATOR" THEN
      DO
       IF FMHISTORY:NEWNUMBER=TARGETTRANSFERLOC THEN
        DO
         TRANCREATEDATEFOUND=TRUE
         TRANSFERCREATEDATE=FMHISTORY:POSTDATE
         TRANSFERCREATEUSER=FMHISTORY:USERNUMBER
         BNODEBUGMSG=FORMAT("CREATE DATE FOUND:99/99/9999    ",TRANSFERCREATEDATE)+
                     FORMAT("CREATE USER:9999+",TRANSFERCREATEUSER)
         CALL BNODEBUGMSGADD
        END
      END
    END
   UNTIL TRANCREATEDATEFOUND=TRUE
  END
END [PROCEDURE]

PROCEDURE GETRECIPSLDATA
 FOR ACCOUNT NEWTRANRECIPACCT
  DO
   IF NEWTRANRECIPSLIDTYPE=0 THEN
    DO
     FOR EACH SHARE WITH (SHARE:ID=NEWTRANRECIPSLIDFOUND)
      DO
       NEWTRANRECIPSLIDTYPEFOUND="S"
       NEWTRANSLDESCRIPTION=SHARE:NICKNAME
       IF NEWTRANSLDESCRIPTION="" THEN
        NEWTRANSLDESCRIPTION=SHARE:DESCRIPTION

       CHARCHECK=NEWTRANSLDESCRIPTION
       CALL CHECKFORINVALIDCHARS
       NEWTRANSLDESCRIPTION=CHARCHECKRETURN
      END
    END
   ELSE [recip is a loan]
    DO
     FOR EACH LOAN WITH (LOAN:ID=NEWTRANRECIPSLIDFOUND)
      DO
       NEWTRANRECIPSLIDTYPEFOUND="L"
       NEWTRANSLDESCRIPTION=LOAN:NICKNAME
       IF NEWTRANSLDESCRIPTION="" THEN
        NEWTRANSLDESCRIPTION=LOAN:DESCRIPTION

       CHARCHECK=NEWTRANSLDESCRIPTION
       CALL CHECKFORINVALIDCHARS
       NEWTRANSLDESCRIPTION=CHARCHECKRETURN
      END
    END
  END
END [PROCEDURE]

PROCEDURE SETUPLIMITS
[* Establish current transfer limits
*]
 BNODEBUGMSG="*** PROCEDURE SETUPLIMITS"
 CALL BNODEBUGMSGADD

 CALL READPREFSETTINGS
 CALL CALCLIMITS
END [PROCEDURE]

PROCEDURE CREATETRANSFER
[* Create Transfer Record. If creating a new transfer record as a result
** of an edit, validate net increase/decrease against daily limits..
*]
 BNODEBUGMSG="*** PROCEDURE CREATETRANSFER"
 CALL BNODEBUGMSGADD

 VALIDLIMITSEXCEEDED=FALSE
 IF PARAMENFORCELIMITS=TRUE THEN
  DO
   CALL SETUPLIMITS

   IF @RGSTATE=STATEEDITTRAN THEN
    DO
     TMPAMOUNT=MBRAMOUNTACTUAL-NEWTRANSRCAMOUNT+NEWTRANAMOUNT
     IF TMPAMOUNT>MBRAMOUNTLIMITCALC OR
        NEWTRANAMOUNT>MBRINDIVLIMITCALC THEN
      VALIDLIMITSEXCEEDED=TRUE
    END
   ELSE
    DO
     IF MBRCOUNTACTUAL+1>MBRCOUNTLIMITCALC OR
        MBRAMOUNTACTUAL+NEWTRANAMOUNT>MBRAMOUNTLIMITCALC OR
        NEWTRANAMOUNT>MBRINDIVLIMITCALC THEN
      VALIDLIMITSEXCEEDED=TRUE
    END
  END

 IF VALIDLIMITSEXCEEDED=FALSE THEN
  DO

   IF NEWTRANFREQ=0 AND
      SOONESTAVAILABLE=TRUE AND
      NEWTRANDAY1=0 AND
      NEWTRANDAY2=0 THEN
    TRANTYPE=TRANTYPEIMMEDIATE
   ELSE
    TRANTYPE=TRANTYPEREGULAR

   IF TRANTYPE=TRANTYPEIMMEDIATE THEN
    CALL CREATEIMMEDIATETRANSFER
   ELSE
    CALL CREATEFUTURETRANSFER
  END
END [PROCEDURE]

PROCEDURE CREATEIMMEDIATETRANSFER
[* Perform an immediate transfer
*]
 BNODEBUGMSG="*** PROCEDURE CREATEIMMEDIATETRANSFER"
 CALL BNODEBUGMSGADD

 BNODEBUGMSG=FORMAT("NEWTRANAMOUNT:###,##9.99",NEWTRANAMOUNT)+
             "   NEWTRANCOMMENT:"+NEWTRANCOMMENT
 CALL BNODEBUGMSGADD

 BNODEBUGMSG="SOURCE - NEWTRANSRCACCT:"+NEWTRANSRCACCT+
            "   NEWTRANSRCIDTYPE:"+NEWTRANSRCIDTYPE+
            "   NEWTRANSRCID: "+NEWTRANSRCID
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="RECIP - NEWTRANRECIPACCT:"+NEWTRANRECIPACCT+
            "   NEWTRANRECIPSLIDTYPEFOUND:"+NEWTRANRECIPSLIDTYPEFOUND+
            "   NEWTRANRECIPSLIDFOUND:"+NEWTRANRECIPSLIDFOUND
 CALL BNODEBUGMSGADD

[* If comment is 16 characters or less, it will be stored as a transaction
** description. PARMTRANCOMMENT allows the CU to seed the comment with
** a std value to force the comment to be over 16 characters and thus
** always be a tran comment instead of a tran description.
*]
 TMPCOMMENT1=PARAMTRANCOMMENT
 IF TMPCOMMENT1<>"" AND
    NEWTRANCOMMENT<>"" THEN
  TMPCOMMENT1=TMPCOMMENT1+" "
 TMPCOMMENT1=TMPCOMMENT1+
             NEWTRANCOMMENT
[* 3.2.1 - Enforce max length on comment to avoid tran error.
*]
 TRANPERFORM XF (0,SEQ1,SEQ2,CAC,CN,TRANERROR)
  DO
   SET FMACCT TO NEWTRANSRCACCT
   SET FMTYPE TO NEWTRANSRCIDTYPE
   SET FMID   TO NEWTRANSRCID

   SET TOACCT TO NEWTRANRECIPACCT
   SET TOTYPE TO NEWTRANRECIPSLIDTYPEFOUND
   SET TOID   TO NEWTRANRECIPSLIDFOUND
   SET REGE   TO 1
   SET AMOUNT TO NEWTRANAMOUNT
   SET COMMENT:1 TO SEGMENT(TMPCOMMENT1,1,39)
  END [TRANPERFORM]

 BNODEBUGMSG="S/L TRANPERFORM TRANERROR:"+TRANERROR
 CALL BNODEBUGMSGADD
END [PROCEDURE]

PROCEDURE CREATEFUTURETRANSFER
[* NEED TO ADD >> Perform a final check to make sure limits aren't being exceeded and if so
** return an error message
*]

 TMPNUM=0
 IF UPPERCASE(NEWTRANRECIPSLIDTYPEFOUND)="L" THEN
  TMPNUM=1
 IF TRANERROR="" THEN
  DO
   FMPERFORM CREATE SHARE NEWTRANSRCID TRANSFER LOC AFTERLAST (0,0,NEWSLTRANSFERLOC,TRANERROR)
    DO
     SET TYPE TO 3
     SET ACCOUNTNUMBER TO NEWTRANRECIPACCT
     SET IDTYPE TO TMPNUM
     SET ID TO NEWTRANRECIPSLIDFOUND
     SET AMOUNT TO NEWTRANAMOUNT
     SET EFFECTIVEDATE TO NEWTRANSTARTDATE
     SET NEXTDATE TO NEWTRANSTARTDATE
     SET FREQUENCY TO NEWTRANFREQ
     SET DAY1 TO NEWTRANDAY1
     SET DAY2 TO NEWTRANDAY2
    END
  END

 BNODEBUGMSG="S/L CREATE TRANSFER TRANERROR:"+TRANERROR
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="NEWTRANSRCID:"+NEWTRANSRCID+"  "+
             "NEWTRANRECIPACCT:"+NEWTRANRECIPACCT+"  "+
             "NEWTRANRECIPSLIDFOUND:"+NEWTRANRECIPSLIDFOUND+"  "+
             "NEWTRANRECIPSLIDTYPEFOUND:"+NEWTRANRECIPSLIDTYPEFOUND
 CALL BNODEBUGMSGADD
END [PROCEDURE]

PROCEDURE UPDATEPREFTOTALS
[* Update Preference record totals based upon the tran type and amount
*]
 BNODEBUGMSG="*** PROCEDURE UPDATEPREFTOTALS"
 CALL BNODEBUGMSGADD

 CALL READPREFSETTINGS
 BNODEBUGMSG=FORMAT("PRE UPDATE XFER AMOUNT:###,##9.99",MBRAMOUNTACTUAL)
 CALL BNODEBUGMSGADD

 IF @RGSTATE=STATECREATETRAN THEN
  DO
   IF SYSTEMDATE=MBRLASTTRANDATE THEN
    DO
     NEWXFERCOUNT=MBRCOUNTACTUAL+1
     NEWXFERAMOUNT=MBRAMOUNTACTUAL+NEWTRANAMOUNT
     NEWLASTTRANDATE=SYSTEMDATE
    END
   ELSE
    DO
     NEWXFERCOUNT=1
     NEWXFERAMOUNT=NEWTRANAMOUNT
     NEWLASTTRANDATE=SYSTEMDATE
    END
  END
 ELSE IF @RGSTATE=STATEDELETETRAN THEN
  DO
[* Determine if transfer being deleted was created on the system date and
** if so, deduct the transfer values from the daily totals.
*]
   TARGETTRANSFERLOC=TARGETSLTRANLOC
   CALL FINDTRANCREATEDATE


   IF TRANCREATEDATEFOUND=TRUE AND
      TRANSFERCREATEDATE=SYSTEMDATE THEN
    DO
[*reduce the ttl transfer count by 1 and the ttl amount by transfer amount
*]
     NEWXFERCOUNT=MBRCOUNTACTUAL-1
     NEWXFERAMOUNT=MBRAMOUNTACTUAL-NEWTRANAMOUNT
     NEWLASTTRANDATE=SYSTEMDATE
    END
  END
 ELSE IF @RGSTATE=STATEEDITTRAN THEN
  DO
   TARGETTRANSFERLOC=TARGETSLTRANLOC
   CALL FINDTRANCREATEDATE

   NEWXFERCOUNT=MBRCOUNTACTUAL
   NEWXFERAMOUNT=MBRAMOUNTACTUAL-NEWTRANSRCAMOUNT+NEWTRANAMOUNT
   NEWLASTTRANDATE=SYSTEMDATE
  END

 BNODEBUGMSG=FORMAT("NEWXFERCOUNT:###,##9.99",NEWTRANSRCAMOUNT)+
             FORMAT("  NEWXFERCOUNT:999   ",NEWXFERCOUNT)+
             FORMAT("  XFERAMOUNT:###,##9.99",NEWXFERAMOUNT)+
             FORMAT("  NEWLASTTRANDATE:99/99/99",NEWLASTTRANDATE)
 CALL BNODEBUGMSGADD

 IF @RGSTATE=STATECREATETRAN OR
   (@RGSTATE=STATEEDITTRAN AND
    TRANCREATEDATEFOUND=TRUE AND
    TRANSFERCREATEDATE=SYSTEMDATE) OR
   (@RGSTATE=STATEDELETETRAN AND
    TRANCREATEDATEFOUND=TRUE AND
    TRANSFERCREATEDATE=SYSTEMDATE) THEN
  DO
   FMPERFORM REVISE PREFERENCE LOC @PREFLOCATOR (0,0,PREFUPDATEERROR)
    DO
     SET XFERCOUNT TO NEWXFERCOUNT
     SET XFERAMOUNT TO NEWXFERAMOUNT
     SET LASTTRANDATE TO NEWLASTTRANDATE
    END
  END
 BNODEBUGMSG="PREFUPDATEERROR:"+PREFUPDATEERROR
 CALL BNODEBUGMSGADD

 CALL READPREFSETTINGS

 BNODEBUGMSG=FORMAT("POST UPDATE XFER AMOUNT:###,##9.99",MBRAMOUNTACTUAL)
 CALL BNODEBUGMSGADD
END

PROCEDURE PRINTCURRENTSTATE
[* Member's Preference Record limits and counts
*]

 PRINT ","
 PRINT INDENT(BASEINDENT+1)+Q+"currentState"+Q+": {"
 NEWLINE
[* Pass S/L ID length value to UX for user input enforcement
*]
 PRINT INDENT(BASEINDENT+1)+Q+"slidLength"+Q+": "
 IF PARAMIDLENTEST>0 THEN
  PRINT PARAMIDLENTEST
 ELSE
  PRINT SLIDLEN
 PRINT ","
 NEWLINE

 PRINT INDENT(BASEINDENT+1)+Q+"systemDate"+Q+": "+Q+FORMAT("99/99/9999",SYSTEMDATE)+Q+","
 NEWLINE

 PRINT INDENT(BASEINDENT+2)+Q+"transferLimits"+Q+": {"
 NEWLINE
 PRINT INDENT(BASEINDENT+3)+Q+"enforceLimits"+Q+": "+TRUEFALSECHR(PARAMENFORCELIMITS)+","
 NEWLINE
 PRINT INDENT(BASEINDENT+3)+Q+"countLimit"+Q+": "+Q+MBRCOUNTLIMITCALCCHR+Q+","
 NEWLINE
 PRINT INDENT(BASEINDENT+3)+Q+"memberCount"+Q+": "+Q+MBRCOUNTACTUALCHR+Q+","
 NEWLINE
 PRINT INDENT(BASEINDENT+3)+Q+"amountLimit"+Q+": "+Q+MBRAMOUNTLIMITCALCCHR+Q+","
 NEWLINE
 PRINT INDENT(BASEINDENT+3)+Q+"memberAmount"+Q+": "+Q+MBRAMOUNTACTUALCHR+Q+","
 NEWLINE
 PRINT INDENT(BASEINDENT+3)+Q+"perTransferLimit"+Q+": "+Q+MBRINDIVLIMITCALCCHR+Q
 NEWLINE
 PRINT INDENT(BASEINDENT+3)+"},"
 NEWLINE

[* Start Available Transfer Shares
*]
 PRINT INDENT(BASEINDENT+2)+Q+"availableShares"+Q+": ["
 NEWLINE

 FOR SLLOOP=1 TO BNOSHARECOUNT
  DO
   IF BNOSHAREACCTNUM(SLLOOP)<>THISACCOUNT THEN
    CROSSACCTFLAG=TRUE
   ELSE
    CROSSACCTFLAG=FALSE

   PRINT INDENT(BASEINDENT+3)+"{"
   NEWLINE

   PRINT INDENT(BASEINDENT+4)+Q+"transferSLId"+Q+": "+Q+
         BNOSHAREACCTNUM(SLLOOP)+"S"+BNOSHAREID(SLLOOP)+Q+","
   NEWLINE

   TMPNUM=BNOSHARECODE(SLLOOP)
   IF TMPNUM>1 THEN
    TMPNUM=0

   PRINT INDENT(BASEINDENT+4)+Q+"type"+Q+": "+Q+TRANRECIPTYPECHR(TMPNUM)+Q+","
   NEWLINE

   IF BNOSHARENICKNAME(SLLOOP)<>"" THEN
    TMPCHR=UPPERCASE(BNOSHARENICKNAME(SLLOOP))
   ELSE
    TMPCHR=UPPERCASE(BNOSHAREDESC(SLLOOP))

   CHARCHECK=TMPCHR
   CALL CHECKFORINVALIDCHARS
   TMPCHR=CHARCHECKRETURN
   PRINT INDENT(BASEINDENT+4)+Q+"name"+Q+": "+Q+TMPCHR+Q+","
   NEWLINE

   NLTSCHR=FORMAT("#############9.99",BNOSHAREAVAILBAL(SLLOOP))
   CALL NLS
   PRINT INDENT(BASEINDENT+4)+Q+"available"+Q+": "+Q+NLTSCHR+Q+","
   NEWLINE
   PRINT INDENT(BASEINDENT+4)+Q+"accountOwnerName"+Q+": "+Q+
         BNOSHAREXACCTPRIMARYNAME(SLLOOP)+Q+","
   NEWLINE

   PRINT INDENT(BASEINDENT+4)+Q+"crossAccount"+Q+": "+BNOTRUEFALSECHR(CROSSACCTFLAG)
   NEWLINE


   PRINT INDENT(BASEINDENT+3)+"}"
   IF SLLOOP<BNOSHARECOUNT OR
     (SLLOOP=BNOSHARECOUNT AND
      BNOLOANCOUNT>0) THEN
    PRINT ","
   NEWLINE
  END

[* Start Available Transfer Loans
*]
 FOR SLLOOP=1 TO BNOLOANCOUNT
  DO
   IF BNOLOANACCTNUM(SLLOOP)<>THISACCOUNT THEN
    CROSSACCTFLAG=TRUE
   ELSE
    CROSSACCTFLAG=FALSE

   PRINT INDENT(BASEINDENT+3)+"{"
   NEWLINE

   PRINT INDENT(BASEINDENT+4)+Q+"transferSLId"+Q+": "+Q+
         BNOLOANACCTNUM(SLLOOP)+"L"+BNOLOANID(SLLOOP)+Q+","
   NEWLINE

   PRINT INDENT(BASEINDENT+4)+Q+"type"+Q+": "+Q+"loan"+Q+","
   NEWLINE

   IF BNOLOANNICKNAME(SLLOOP)<>"" THEN
    TMPCHR=UPPERCASE(BNOLOANNICKNAME(SLLOOP))
   ELSE
    TMPCHR=UPPERCASE(BNOLOANDESC(SLLOOP))
   CHARCHECK=TMPCHR
   CALL CHECKFORINVALIDCHARS
   TMPCHR=CHARCHECKRETURN

   PRINT INDENT(BASEINDENT+4)+Q+"name"+Q+": "+Q+TMPCHR+Q+","
   NEWLINE
   NLTSCHR=FORMAT("#############9.99",BNOLOANAVAILCREDIT(SLLOOP))
   CALL NLS
   PRINT INDENT(BASEINDENT+4)+Q+"available"+Q+": "+Q+NLTSCHR+Q+","
   NEWLINE
   PRINT INDENT(BASEINDENT+4)+Q+"accountOwnerName"+Q+": "+Q+
         BNOLOANXACCTPRIMARYNAME(SLLOOP)+Q+","
   NEWLINE
   PRINT INDENT(BASEINDENT+4)+Q+"crossAccount"+Q+": "+
         BNOTRUEFALSECHR(CROSSACCTFLAG)
   NEWLINE

   PRINT INDENT(BASEINDENT+3)+"}"
   IF SLLOOP<BNOLOANCOUNT THEN
    PRINT ","
   NEWLINE
  END

[* End available transfer Shares/Loans
*]
 PRINT INDENT(BASEINDENT+3)+"],"
 NEWLINE

[* Start Existing Transfers
*]
 PRINT INDENT(BASEINDENT+2)+Q+"scheduledTransfers"+Q+": ["
 NEWLINE

 FOR TMPLOOP=1 TO TRANCOUNT
  DO

   PRINT INDENT(BASEINDENT+3)+"{"
   NEWLINE
   PRINT INDENT(BASEINDENT+4)+Q+"transferLoc"+Q+": "+Q
[* Format locator to remove comma(s)
*]
   NLTSCHR=FORMAT("#######9",TRANLOC(TMPLOOP))
   CALL NLS
   PRINT NLTSCHR
   PRINT Q+","
   NEWLINE
[* Send transfer creation date to UX for user input logic
*]
   PRINT INDENT(BASEINDENT+4)+Q+"transferCreateDate"+Q+": "+Q+FORMAT("99/99/9999",TRANCREATEDATE(TMPLOOP))+Q+","
   NEWLINE

   PRINT INDENT(BASEINDENT+4)+Q+"sourceAccount"+Q+": "+Q+TRANSOURCEACCT(TMPLOOP)+Q+","
   NEWLINE

   CHARCHECK=TRANACCOUNTNAME(TMPLOOP)
   CALL CHECKFORINVALIDCHARS
   TRANACCOUNTNAME(TMPLOOP)=CHARCHECKRETURN
   PRINT INDENT(BASEINDENT+4)+Q+"accountName"+Q+": "+Q+TRANACCOUNTNAME(TMPLOOP)+Q+","
   NEWLINE
   PRINT INDENT(BASEINDENT+4)+Q+"transferAmt"+Q+": "+Q

   NLTSCHR=FORMAT("##########9.99",TRANXFERAMOUNT(TMPLOOP))
   CALL NLS

   PRINT NLTSCHR
   PRINT Q+","
   NEWLINE
   PRINT INDENT(BASEINDENT+4)+Q+"recipientName"+Q+": "+Q+TRANRECIPNAME(TMPLOOP)+Q+","
   NEWLINE
   PRINT INDENT(BASEINDENT+4)+Q+"recipientMemberId"+Q+": "+Q+TRANRECIPACCT(TMPLOOP)+Q+","
   NEWLINE
   PRINT INDENT(BASEINDENT+4)+Q+"recipientAccountType"+Q+": "+Q+TRANRECIPACCTTYPE(TMPLOOP)+Q+","
   NEWLINE
   PRINT INDENT(BASEINDENT+4)+Q+"recipientAccountId"+Q+": "+Q+TRANRECIPACCTID(TMPLOOP)+Q+","
   NEWLINE
   PRINT INDENT(BASEINDENT+4)+Q+"recipientNickname"+Q+": "+Q+TRANRECIPNICKNAME(TMPLOOP)+Q+","
   NEWLINE

   PRINT INDENT(BASEINDENT+4)+Q+"startDate"+Q+": "+Q+FORMAT("99/99/9999",TRANSTARTDATE(TMPLOOP))+Q+","
   NEWLINE
   PRINT INDENT(BASEINDENT+4)+Q+"nextTransferDate"+Q+": "+Q+FORMAT("99/99/9999",TRANNEXTTRANDATE(TMPLOOP))+Q+","
   NEWLINE


   IF TRANSFERFREQCHR(TRANFREQALT,TRANFREQUENCY(TMPLOOP))<>"" THEN
    PRINT INDENT(BASEINDENT+4)+Q+"transferFrequency"+Q+": "+Q+TRANSFERFREQCHR(TRANFREQALT,TRANFREQUENCY(TMPLOOP))+Q+","
   ELSE
    PRINT INDENT(BASEINDENT+4)+Q+"transferFrequency"+Q+": "+Q+TRANSFERFREQCHR(TRANFREQSTD,TRANFREQUENCY(TMPLOOP))+Q+","
   NEWLINE

   NLTSCHR=""
   IF TRANDAY1(TMPLOOP)>0 THEN
    DO
     NLTSCHR=FORMAT("#9",TRANDAY1(TMPLOOP))
     CALL NLS
    END
   PRINT INDENT(BASEINDENT+4)+Q+"day1"+Q+": "+Q+NLTSCHR+Q+","
   NEWLINE

   NLTSCHR=""
   IF TRANDAY2(TMPLOOP)>0 THEN
    DO
     NLTSCHR=FORMAT("#9",TRANDAY2(TMPLOOP))
     CALL NLS
    END

   PRINT INDENT(BASEINDENT+4)+Q+"day2"+Q+": "+Q+NLTSCHR+Q+","
   NEWLINE
   PRINT INDENT(BASEINDENT+4)+Q+"readOnly"+Q+": "+TRANREADONLYSTATUS(TMPLOOP)
   NEWLINE

   PRINT INDENT(BASEINDENT+3)+"}"
   IF TMPLOOP<TRANCOUNT THEN
    PRINT ","
   NEWLINE
  END
[* End Existing Transfers
*]

 PRINT INDENT(BASEINDENT+3)+"],"
 NEWLINE

[* Start Saved Recipients
*]
 PRINT INDENT(BASEINDENT+2)+Q+"savedRecipients"+Q+": ["
 NEWLINE

 RECIPLASTUNEXPIREDINDEX=0
 FOR TMPLOOP=1 TO RECIPCOUNT
  DO
   IF RECIPLISTEXPIREDATE(TMPLOOP)=DATENULL THEN
    RECIPLASTUNEXPIREDINDEX=TMPLOOP
  END

 IF RECIPLASTUNEXPIREDINDEX>0 THEN
  DO
   FOR TMPLOOP=1 TO RECIPCOUNT
    DO
     IF RECIPLISTEXPIREDATE(TMPLOOP)=DATENULL THEN
      DO
       PRINT INDENT(BASEINDENT+3)+"{"
       NEWLINE

       NLTSCHR=FORMAT("########9",RECIPLOC(TMPLOOP))
       CALL NLS
       PRINT INDENT(BASEINDENT+4)+Q+"recipientLoc"+Q+": "+Q+NLTSCHR+Q+","
       NEWLINE

       PRINT INDENT(BASEINDENT+4)+Q+"recipientName"+Q+": "+Q+RECIPNAME(TMPLOOP)+Q+","
       NEWLINE

       PRINT INDENT(BASEINDENT+4)+Q+"recipientMemberId"+Q+": "+Q+SEGMENT(RECIPACCOUNT(TMPLOOP),1,10)+Q+","
       NEWLINE

       TMPCHR=""
[tek 03/29/22]
       IF UPPERCASE(SEGMENT(RECIPACCOUNT(TMPLOOP),11,11))="L" THEN
        TMPCHR="loan"
       ELSE
        TMPCHR="share"

       PRINT INDENT(BASEINDENT+4)+Q+"recipientAccountType"+Q+": "+Q+TMPCHR+Q+","
       NEWLINE

       PRINT INDENT(BASEINDENT+4)+Q+"recipientAccountId"+Q+": "+Q+SEGMENT(RECIPACCOUNT(TMPLOOP),12,LENGTH(RECIPACCOUNT(TMPLOOP)))+Q+","
       NEWLINE

       PRINT INDENT(BASEINDENT+4)+Q+"recipientNickname"+Q+": "+Q+RECIPNICKNAME(TMPLOOP)+Q
       NEWLINE

       PRINT INDENT(BASEINDENT+3)+"}"
       IF TMPLOOP<RECIPLASTUNEXPIREDINDEX THEN
        PRINT ","
       NEWLINE

      END [IF RECIPLISTEXPIREDATE(TMPLOOP)=DATENULL]
    END [FOR TMPLOOP=1 TO RECIPCOUNT]
  END [IF RECIPLASTUNEXPIREDINDEX>0]

[* End Saved Recipients
*]
 PRINT INDENT(BASEINDENT+3)+"]"
 NEWLINE

[* Start labels
*]
 IF PARAMLBLMEMBERNAME<>"" OR PARAMLBLID<>"" THEN
  DO
   PRINT ","+Q+"labels"+Q+": {"
   NEWLINE
   PRINT Q+"memberNameSubTitle"+Q+": "+Q+PARAMLBLMEMBERNAME+Q+","
   NEWLINE
   PRINT Q+"idSubTitle"+Q+": "+Q+PARAMLBLID+Q
   NEWLINE
   PRINT "}"
   NEWLINE
  END
[* End labels
*]

[* The share ID optional feature is not currently supported in baseline PowerOn.
 PRINT ","+Q+"shareAcctIdOptional"+Q+": "+TRUEFALSECHR(PARAMSIDOPTIONAL)
 NEWLINE
*]

[* End currentState
*]
 PRINT INDENT(BASEINDENT+2)+"}"
 NEWLINE
END

PROCEDURE CHECKFORPA3

 FOR EACH PREFERENCE WITH (PREFERENCE:LOCATOR=@PREFLOCATOR)
  DO
   FOR EACH PREFERENCE ACCESS WITH (PREFERENCE ACCESS:ACCESSTYPE=3)
    DO
     PA3FOUND=TRUE
    END
  END
 IF PA3FOUND=FALSE THEN
  DO
   NEWLINE
   CALL JSONOPEN
   CALL PRINTPROGRAMINFO
   BNOERRORCODE=BNOERRCODEINVSOURCE
   BNOERRORMODIFIER=BNOERRMODACCESSTYPE
   CALL ERRORHANDLER
  END
END

PROCEDURE READPREFSETTINGS
[* Reset the preference record calculation settings for the day
*]
 BNODEBUGMSG="*** PROCEDURE READPREFSETTINGS"
 CALL BNODEBUGMSGADD

 PREFFOUND=FALSE
 MBRCOUNTLIMIT=0
 MBRAMOUNTLIMIT=$0.00
 MBRINDIVIDUALLIMIT=$0.00
 MBRCOUNTACTUAL=0
 MBRAMOUNTACTUAL=$0.00
 RESETPREFVALUES=FALSE

 FOR EACH PREFERENCE WITH (PREFERENCE:LOCATOR=@PREFLOCATOR)
  DO
   IF PREFERENCE:LASTTRANDATE<SYSTEMDATE THEN
    RESETPREFVALUES=TRUE

   BNODEBUGMSG=FORMAT("PREFERENCE:LASTTRANDATE = 99/99/99",PREFERENCE:LASTTRANDATE)+
                FORMAT("  RESETPREFVALUES:9",RESETPREFVALUES)
   CALL BNODEBUGMSGADD
  END

 IF RESETPREFVALUES=TRUE THEN
  DO
   FMPERFORM REVISE PREFERENCE LOC @PREFLOCATOR(1,0,PREFUPDATEERROR)
    DO
     SET XFERCOUNT TO 0
     SET XFERAMOUNT TO $0.00
     SET DEPCOUNT TO 0
     SET DEPAMOUNT TO $0.00
     SET WDCHECKCOUNT TO 0
     SET WDCHECKAMOUNT TO $0.00
     SET WDCASHCOUNT TO 0
     SET WDCASHAMOUNT TO $0.00
     SET BILLPAYCOUNT TO 0
     SET BILLPAYAMOUNT TO $0.00
     SET LASTTRANDATE TO SYSTEMDATE
    END
  END

 FOR EACH PREFERENCE WITH (PREFERENCE:LOCATOR=@PREFLOCATOR)
  DO
   PREFFOUND=TRUE
   MBRCOUNTLIMIT=PREFERENCE:XFERCOUNTLIMIT
   MBRAMOUNTLIMIT=PREFERENCE:XFERLIMIT
   MBRINDIVIDUALLIMIT=PREFERENCE:XFERMAX
   MBRCOUNTACTUAL=PREFERENCE:XFERCOUNT
   MBRAMOUNTACTUAL=PREFERENCE:XFERAMOUNT
   MBRLASTTRANDATE=PREFERENCE:LASTTRANDATE
  END

 NLTSCHR=FORMAT("#####9",MBRCOUNTLIMIT)
 CALL NLS
 MBRCOUNTLIMITCHR=NLTSCHR

 NLTSCHR=FORMAT("##########9.99",MBRAMOUNTLIMIT)
 CALL NLS
 MBRAMOUNTLIMITCHR=NLTSCHR

 NLTSCHR=FORMAT("##########9.99",MBRINDIVIDUALLIMIT)
 CALL NLS
 MBRINDIVIDUALLIMITCHR=NLTSCHR

 NLTSCHR=FORMAT("#####9",MBRCOUNTACTUAL)
 CALL NLS
 MBRCOUNTACTUALCHR=NLTSCHR

 NLTSCHR=FORMAT("##########9.99",MBRAMOUNTACTUAL)
 CALL NLS
 MBRAMOUNTACTUALCHR=NLTSCHR
END [PROCEDURE ]

PROCEDURE CALCLIMITS
[* Calculate member's current Preference record limits
*]
 BNODEBUGMSG="*** PROCEDURE CALCLIMITS"
 CALL BNODEBUGMSGADD

 MBRCOUNTLIMITCALC=-1
 MBRAMOUNTLIMITCALC=-$0.01
 MBRINDIVLIMITCALC=-$0.01

 MBRCOUNTLIMITCALCCHR=""
 MBRAMOUNTLIMITCALCCHR=""
 MBRINDIVLIMITCALCCHR=""

 BNODEBUGMSG="PROCEDURE CALCLIMITS (START)"
 CALL BNODEBUGMSGADD
 BNODEBUGMSG=FORMAT("MBRCOUNTLIMIT:###9+   ",MBRCOUNTLIMIT)+
            FORMAT("MBRAMOUNTLIMIT:###,##9.99+   ",MBRAMOUNTLIMIT)+
            FORMAT("MBRINDIVIDUALLIMIT:###,##9.99+   ",MBRINDIVIDUALLIMIT)
 CALL BNODEBUGMSGADD

 IF (PARAMINSTCOUNTLIMIT>0 AND PARAMINSTCOUNTLIMIT<9999) THEN
  DO
   IF MBRCOUNTLIMIT=0 THEN
    MBRCOUNTLIMITCALC=PARAMINSTCOUNTLIMIT
   ELSE IF (MBRCOUNTLIMIT>0 AND MBRCOUNTLIMIT<9999) THEN
    MBRCOUNTLIMITCALC=MBRCOUNTLIMIT
   ELSE IF MBRCOUNTLIMIT>=9999 THEN
    MBRCOUNTLIMITCALC=9999
  END
 ELSE IF PARAMINSTCOUNTLIMIT>=9999 THEN
  DO
   IF MBRCOUNTLIMIT=0 THEN
    MBRCOUNTLIMITCALC=9999
   ELSE IF (MBRCOUNTLIMIT>0 AND MBRCOUNTLIMIT<9999) THEN
    MBRCOUNTLIMITCALC=MBRCOUNTLIMIT
   ELSE IF MBRCOUNTLIMIT>=9999 THEN
    MBRCOUNTLIMITCALC=9999
  END
 ELSE IF PARAMINSTCOUNTLIMIT=0 THEN
  DO
   IF MBRCOUNTLIMIT=0 THEN
    MBRCOUNTLIMITCALC=MBRCOUNTLIMIT
   IF (MBRCOUNTLIMIT>0 AND MBRCOUNTLIMIT<9999) THEN
    MBRCOUNTLIMITCALC=MBRCOUNTLIMIT
   ELSE IF MBRCOUNTLIMIT>=9999 THEN
    MBRCOUNTLIMITCALC=9999
  END

 IF (PARAMINSTAMOUNTLIMIT>$0.00 AND PARAMINSTAMOUNTLIMIT<$999,999.99) THEN
  DO
   IF MBRAMOUNTLIMIT=$0.00 THEN
    MBRAMOUNTLIMITCALC=PARAMINSTAMOUNTLIMIT
   ELSE IF (MBRAMOUNTLIMIT>$0.00 AND MBRAMOUNTLIMIT<$999,999.99) THEN
    MBRAMOUNTLIMITCALC=MBRAMOUNTLIMIT
   ELSE IF MBRAMOUNTLIMIT>=$999,999.99 THEN
    MBRAMOUNTLIMITCALC=$999,999.99
  END
 ELSE IF PARAMINSTAMOUNTLIMIT>=$999,999.99 THEN
  DO
   IF MBRAMOUNTLIMIT=$0.00 THEN
    MBRAMOUNTLIMITCALC=$999,999.99
   ELSE IF (MBRAMOUNTLIMIT>$0.00 AND MBRAMOUNTLIMIT<$999,999.99) THEN
    MBRAMOUNTLIMITCALC=MBRAMOUNTLIMIT
   ELSE IF MBRAMOUNTLIMIT>=$999,999.99 THEN
    MBRCOUNTLIMITCALC=9999
  END
 ELSE IF PARAMINSTAMOUNTLIMIT=$0.00 THEN
  DO
   IF (MBRAMOUNTLIMIT>$0.00 AND MBRAMOUNTLIMIT<$999,999.99) THEN
    MBRAMOUNTLIMITCALC=MBRAMOUNTLIMIT
   ELSE IF MBRAMOUNTLIMIT>=$999,999.99 THEN
    MBRAMOUNTLIMITCALC=$999,999.99
   ELSE IF MBRAMOUNTLIMIT>=$999,999.99 THEN
    MBRAMOUNTLIMITCALC=$999,999.99
  END
 IF (PARAMINSTINDIVLIMIT>$0.00 AND PARAMINSTINDIVLIMIT<$999,999.99) THEN
  DO
   IF MBRINDIVIDUALLIMIT=$0.00 THEN
    MBRINDIVLIMITCALC=PARAMINSTINDIVLIMIT
   ELSE IF (MBRINDIVIDUALLIMIT>$0.00 AND MBRINDIVIDUALLIMIT<$999,999.99) THEN
    MBRINDIVLIMITCALC=MBRINDIVIDUALLIMIT
   ELSE IF MBRINDIVIDUALLIMIT>=$999,999.99 THEN
    MBRINDIVLIMITCALC=$999,999.99
  END
 ELSE IF PARAMINSTINDIVLIMIT>=$999,999.99 THEN
  DO
   IF MBRINDIVIDUALLIMIT=$0.00 THEN
    MBRINDIVLIMITCALC=$999,999.99
   ELSE IF (MBRINDIVIDUALLIMIT>$0.00 AND MBRINDIVIDUALLIMIT<$999,999.99) THEN
    MBRINDIVLIMITCALC=MBRINDIVIDUALLIMIT
   ELSE IF MBRINDIVIDUALLIMIT>=$999,999.99 THEN
    MBRINDIVLIMITCALC=$999,999.99
  END
 ELSE IF PARAMINSTINDIVLIMIT=$0.00 THEN
  DO
   IF (MBRINDIVIDUALLIMIT>$0.00 AND MBRINDIVIDUALLIMIT<$999,999.99) THEN
    MBRINDIVLIMITCALC=MBRINDIVIDUALLIMIT
   ELSE IF MBRINDIVIDUALLIMIT>=$999,999.99 THEN
    MBRINDIVLIMITCALC=$999,999.99
   ELSE IF MBRINDIVIDUALLIMIT>=$999,999.99 THEN
    MBRINDIVLIMITCALC=$999,999.99
  END
 IF MBRINDIVLIMITCALC>=$999,999.99 AND
    MBRCOUNTLIMITCALC>=9999 AND
    MBRAMOUNTLIMITCALC>=$999,999.99 THEN
  PARAMENFORCELIMITS=FALSE
 IF PARAMENFORCELIMITS=TRUE AND
   (MBRCOUNTLIMITCALC<0 OR
    MBRAMOUNTLIMITCALC<$0.00 OR
    MBRINDIVLIMITCALC<$0.00) THEN
  DO
   NEWLINE
   CALL JSONOPEN
   CALL PRINTPROGRAMINFO
   BNOERRORCODE=BNOERRCODEMISSINGINFO
   BNOERRORMODIFIER=BNOERRMODCALCMBRLIMITS
   CALL ERRORHANDLER
  END
 NLTSCHR=FORMAT("######9+",MBRCOUNTLIMITCALC)
 CALL NLS
 MBRCOUNTLIMITCALCCHR=NLTSCHR

 NLTSCHR=FORMAT("########9.99+",MBRAMOUNTLIMITCALC)
 CALL NLS
 MBRAMOUNTLIMITCALCCHR=NLTSCHR

 NLTSCHR=FORMAT("########9.99+",MBRINDIVLIMITCALC)
 CALL NLS
 MBRINDIVLIMITCALCCHR=NLTSCHR

 BNODEBUGMSG="MBRCOUNTLIMITCALC:"+MBRCOUNTLIMITCALCCHR+
             "   MBRAMOUNTLIMITCALC:"+MBRAMOUNTLIMITCALCCHR+
             "   MBRINDIVLIMITCALC:"+MBRINDIVLIMITCALCCHR
 CALL BNODEBUGMSGADD
END [PROCEDURE]

PROCEDURE BUILDSHARELOANLIST
[* Build a list of eligible Shares/Loans from which to transfer the
** funds from
** 3.2.1 - Updated procedures being called
*]
 CALL BNOBUILDSHARELOANLISTINIT

 BNOSLTYPE=PARAMNTSLTYPE
 BNOCROSSACCTACCESS=PARAMCROSSACCTACCESS
 BNOSLCODE(BNOSHARECODESHARE)=TRUE
 BNOSLCODE(BNOSHARECODEDRAFT)=TRUE
 BNOSLCODE(BNOSHARECODECERTIFICATE)=TRUE
 BNOSLCODE(BNOSHARECODECLUB)=TRUE
 BNOEXCLUDESHARETYPELIST="none"
 BNOEXCLUDELOANTYPELIST="none"
 BNOINCLUDECLOSED=FALSE
 BNOINCLUDECHARGEDOFF=FALSE
 BNOINCLUDEEXTLOANS=FALSE
 BNOACCESSTYPE=BNOACCESSTYPEXFEROUT
 BNOAVAILCALCMETHOD=0

 CALL BNOBUILDSHARELOANLIST

 BNODEBUGMSG=FORMAT("1 BNOSHARECOUNT=999",BNOSHARECOUNT)+
             FORMAT("   BNOLOANCOUNT=999",BNOLOANCOUNT)
 CALL BNODEBUGMSGADD

END

PROCEDURE BUILDRECIPLIST
[* Build a list of saved recipients for the member to reuse
*]
 RECIPCOUNT=0
 FOR EACH EXTERNALACCOUNT WITH (SEGMENT(EXTERNALACCOUNT:FINANCIALINSTITUTIONNAME,1,4)="M2M:" AND
                                EXTERNALACCOUNT:RT="" AND
                                EXTERNALACCOUNT:STATUS=2 [AND
                                EXTERNALACCOUNT:EXPIRATIONDATE=DATENULL])
  DO
   IF RECIPCOUNT<RECIPMAX THEN
    DO
     RECIPCOUNT=RECIPCOUNT+1
     RECIPLOC(RECIPCOUNT)=EXTERNALACCOUNT:LOCATOR
     RECIPNAME(RECIPCOUNT)=UPPERCASE(EXTERNALACCOUNT:PRIMARYACCOUNTHOLDERNAME)
     NLTSCHR=SEGMENT(EXTERNALACCOUNT:FINANCIALINSTITUTIONNAME,5,
            LENGTH(EXTERNALACCOUNT:FINANCIALINSTITUTIONNAME))
     CALL NLS
     CHARCHECK=NLTSCHR
     CALL CHECKFORINVALIDCHARS
     RECIPNICKNAME(RECIPCOUNT)=CHARCHECKRETURN
     RECIPACCOUNT(RECIPCOUNT)=EXTERNALACCOUNT:NUMBER
     RECIPLISTEXPIREDATE(RECIPCOUNT)=EXTERNALACCOUNT:EXPIRATIONDATE
    END
  END
END

PROCEDURE BUILDSLTRANSFERLIST
[* Build a list of existing transfers for the member to use/edit or delete
*]
 WHILELIMIT=2000000
 TRANCOUNT=0
 FOR EACH SHARE WITH (SHARE:CLOSEDATE=DATENULL)
  DO
   FOR EACH SHARE TRANSFER WITH (SHARE TRANSFER:TYPE=3 AND
                                (SHARE TRANSFER:EXPIRATIONDATE=DATENULL OR
                                 SHARE TRANSFER:EXPIRATIONDATE>SYSTEMDATE) AND
                                 SHARE TRANSFER:ACCOUNTNUMBER<>ACCOUNT:NUMBER)
    DO
     IF TRANCOUNT<TRANCOUNTMAX THEN
      DO
       PAACCOUNTTEST=SHARE TRANSFER:ACCOUNTNUMBER
       PASLIDTYPETEST=SHARE TRANSFER:IDTYPE
       PASLIDTEST=SHARE TRANSFER:ID

       EXTERNALRECTOFIND=PAACCOUNTTEST+
                         IDTYPETOCHR(PASLIDTYPETEST)+
                         PASLIDTEST

       CALL FINDEXTERNALRECORD    [EXTRECFOUND=RECIPINDEX]
       CALL FINDPREFACCESSMATCH
       IF PREFACCESSMATCH=FALSE THEN
        DO
         TMPNUM=0
         TRANCOUNT=TRANCOUNT+1

         TRANLOC(TRANCOUNT)=SHARE TRANSFER:LOCATOR
         TRANSOURCEACCT(TRANCOUNT)=ACCOUNT:NUMBER+"S"+SHARE:ID

         TARGETTRANSFERLOC=TRANLOC(TRANCOUNT)
         CALL FINDTRANCREATEDATE
         TRANCREATEDATE(TRANCOUNT)=TRANSFERCREATEDATE
         TRANCREATEUSER(TRANCOUNT)=TRANSFERCREATEUSER

         BNODEBUGMSG=FORMAT("**** TESTING FOR READONLY DATA - SHARE TRANSFER LOC ########9",TARGETTRANSFERLOC)
         CALL BNODEBUGMSGADD
         BNODEBUGMSG=FORMAT("EXTRECFOUND:9  ",EXTRECFOUND)+
                     FORMAT("PARAMALLOWEDIT:9  ",PARAMALLOWEDIT)+
                    "   SHARE TRAN FREQ:"+
                     TRANSFERFREQCHR(TRANFREQALT,SHARE TRANSFER:FREQUENCY)+
                    FORMAT("  TRANSFERCREATEUSER:,###9+  ",TRANSFERCREATEUSER)+
                    FORMAT("USERSWHOCANEDIT 9999",USERSWHOCANEDIT(TRANSFERCREATEUSER))
         CALL BNODEBUGMSGADD

[* Determine if existing transfer is editable or not
*]
         IF TRANSFERFREQCHR(TRANFREQALT,SHARE TRANSFER:FREQUENCY)<>"" AND
           (PARAMALLOWEDIT=ALLOWEDITTRUE OR
           (PARAMALLOWEDIT=ALLOWEDITUSER AND USERSWHOCANEDIT(TRANSFERCREATEUSER)=TRUE) OR
            TRANSFERCREATEUSER=SYMXUSERNUMBER) THEN
             TRANREADONLYSTATUS(TRANCOUNT)="false"
            ELSE
             TRANREADONLYSTATUS(TRANCOUNT)="true"

         TRANACCOUNTNAME(TRANCOUNT)=SHARE:NICKNAME
         IF SHARE:NICKNAME="" THEN
          TRANACCOUNTNAME(TRANCOUNT)=SHARE:DESCRIPTION

         CHARCHECK=TRANACCOUNTNAME(TRANCOUNT)
         CALL CHECKFORINVALIDCHARS
         TRANACCOUNTNAME(TRANCOUNT)=CHARCHECKRETURN

         TRANXFERAMOUNT(TRANCOUNT)=SHARE TRANSFER:AMOUNT
         TRANRECIPNAME(TRANCOUNT)=RECIPNAME(EXTRECFOUND) [First three letters of last/business name]
         TRANRECIPMBRID(TRANCOUNT)=SHARE TRANSFER:ACCOUNTNUMBER
         TRANRECIPACCT(TRANCOUNT)=SHARE TRANSFER:ACCOUNTNUMBER

         IF SHARE TRANSFER:IDTYPE=1 THEN
          TMPNUM=4
         ELSE
          DO
           TMPSID=SHARE TRANSFER:ID
           FOR ACCOUNT SHARE TRANSFER:ACCOUNTNUMBER
            DO
             FOR EACH SHARE WITH (SHARE:ID=TMPSID)
              DO
               TMPNUM=SHARE:SHARECODE
              END
            END
          END
         IF SHARE TRANSFER:IDTYPE=1 THEN
          TRANRECIPACCTTYPE(TRANCOUNT)="loan"
         ELSE
          TRANRECIPACCTTYPE(TRANCOUNT)="share"
         TRANRECIPEXPIREDATE(TRANCOUNT)=RECIPLISTEXPIREDATE(EXTRECFOUND)

         BNODEBUGMSG=FORMAT("SHARECODE (TMPNUM) :#9  ",TMPNUM)+
                    "TRANRECIPTYPECHR(TMPNUM):"+TRANRECIPTYPECHR(TMPNUM)
         CALL BNODEBUGMSGADD

         TRANRECIPACCTID(TRANCOUNT)=SHARE TRANSFER:ID
         TRANRECIPNICKNAME(TRANCOUNT)=RECIPNICKNAME(EXTRECFOUND)
[* Use 'x'+last 2 of member number+'L' or 'S'+S/L ID format instead of description/nickname
*]
         IF TRANRECIPNICKNAME(TRANCOUNT)="" THEN
          DO
           TRANRECIPNICKNAME(TRANCOUNT)="x"+SEGMENT(SHARE TRANSFER:ACCOUNTNUMBER,
                                            LENGTH(SHARE TRANSFER:ACCOUNTNUMBER)-1,
                                            LENGTH(SHARE TRANSFER:ACCOUNTNUMBER))+
                                            UPPERCASE(SEGMENT(TRANRECIPACCTTYPE(TRANCOUNT),1,1))+
                                            SHARE TRANSFER:ID
          END

         TRANSTARTDATE(TRANCOUNT)=SHARE TRANSFER:EFFECTIVEDATE
         IF TRANSTARTDATE(TRANCOUNT)=DATENULL THEN
          TRANSTARTDATE(TRANCOUNT)=SHARE TRANSFER:NEXTDATE
         TRANNEXTTRANDATE(TRANCOUNT)=SHARE TRANSFER:NEXTDATE

         TRANFREQUENCY(TRANCOUNT)=SHARE TRANSFER:FREQUENCY

         TRANDAY1(TRANCOUNT)=SHARE TRANSFER:DAY1
         TRANDAY2(TRANCOUNT)=SHARE TRANSFER:DAY2

        END
      END
    END
  END
END [BUILDSLTRANSFERLIST]

PROCEDURE FINDPREFACCESSMATCH
 PREFACCESSMATCH=FALSE
 FOR ACCOUNT ACCOUNT:NUMBER
  DO

   FOR EACH PREFERENCE WITH (PREFERENCE:LOCATOR=@PREFLOCATOR)
    DO

     FOR EACH PREFERENCE ACCESS WITH  (PREFERENCE ACCESS:ACCESSTYPE=0 OR
                                       PREFERENCE ACCESS:ACCESSTYPE=2) AND
                                      ((PREFERENCE ACCESS:ACCOUNTNUMBER=PAACCOUNTTEST AND
                                       PREFERENCE ACCESS:IDTYPE=PASLIDTYPETEST AND
                                       PREFERENCE ACCESS:ID=PASLIDTEST) OR

                                      (PREFERENCE ACCESS:ACCOUNTNUMBER=PAACCOUNTTEST AND
                                       PREFERENCE ACCESS:IDTYPE=2))
      DO
       PREFACCESSMATCH=TRUE
      END
    END
  END
END

PROCEDURE FINDEXTERNALRECORD
[* PASS    EXTERNALRECTOFIND    Recipient account to search for
*]
 EXTRECFOUND=FALSE

 FOR RECIPINDEX=1 TO RECIPCOUNT
  DO
   IF EXTERNALRECTOFIND=RECIPACCOUNT(RECIPINDEX) THEN
    EXTRECFOUND=RECIPINDEX
  END
 BNODEBUGMSG="EXTERNALRECTOFIND:"+EXTERNALRECTOFIND+FORMAT("   EXTRECFOUND:9",EXTRECFOUND)
 CALL BNODEBUGMSGADD
END

PROCEDURE INITIALIZEDATA
[* Initialize state variables
*]
 WHILELIMIT=100000
 PA3FOUND=FALSE
 LFNUMBER=0
 LFERROR=""
 VALIDACCOUNT=FALSE
 VALIDPARAMS=TRUE
 LFERROR=""
 LFNUMBER=0
 PREFLOC=@PREFLOCATOR

 BNOERRORCODE=0
 BNOERRORMODIFIER=""

 THISACCOUNT=ACCOUNT:NUMBER
 SYMXINSTANCE=@SYMXINSTANCEID

 SYMXCLIENTNUM=@CLIENTNUMBER
 LELISTINPUT=GETDATACHARACTER(GETPARAMSYMXCHCLSERVICESXIN,SYMXINSTANCE,SYMXCLIENTNUM)
 BNODEBUGMSG="SVCS XFER IN:"+LELISTINPUT
 CALL BNODEBUGMSGADD
 CALL LISTEXPAND
 FOR TMPLOOP=1 TO SVCCODEMAX
  DO
   SERVICEIN(TMPLOOP)=LELIST(TMPLOOP)
  END

 FOR TMPLOOP=0 TO MAXWARNINGTYPES
  DO
   WARNINGSACCT(TMPLOOP)=FALSE
  END
END [PROCEDURE]

PROCEDURE SETMEMOMODE
[* Check to see if the system is in memo mode
*]
 SYSTEMMEMOMODE=SYSMEMOMODE
 IF PARAMMEMOMODE=DEBUGMODEON THEN
  SYSTEMMEMOMODE=TRUE
END [PROCEDURE]

PROCEDURE READCONFIGFILESETTINGS
[* Read parameter settings from the configuration Letter file.
**
**  PASS   CONFIGFILENAME             The name of the configuration Letter file
**  RETURN PARAMENFORCELIMITS         Should the program honor Preference record limits TRUE/FALSE
**  RETURN PARAMINELIGIBLEACCTS       Ineligible account Type(s) (in LISTEXPAND format)
**  RETURN PARAMWARNINGSACCT          Ineligible account warning(s) (in LISTEXPAND format)
**  RETURN PARAMINSTCOUNTLIMIT        Institution level aggregate transfer count limit
**  RETURN PARAMINSTAMOUNTLIMIT       Institution level aggregate transfer amount limit
**  RETURN PARAMINSTINDIVLIMIT        Institution level single transfer limit
**  RETURN PARAMCROSSACCTACCESS       Can transfers be made from cross accounts
**  RETURN PARAMNTSLTYPE              Transfer from types (shares, loans or both)
**  RETURN PARAMALLOWEDIT             Can the member edit manually created transfers
**  RETURN PARAMVALIDATIONNAMETYPES   Valid name types (Internal parameter setting only)
**  RETURN PARAMALLOWABLESHARECODES() Share codes allowed to transfer into (boolean)
**  RETURN MEMOMODE                   Is the system in memo mode (boolean)
**  RETURN DEBUGMODE                  Add debugging code to JSON Ouput (boolean)

*]
 PARAMINELIGIBLEACCTS=""
 PARAMWARNINGSACCT=""
 PARAMENFORCELIMITS=FALSE
 PARAMINSTCOUNTLIMIT=0
 PARAMINSTAMOUNTLIMIT=$0.00
 PARAMINSTINDIVLIMIT=$0.00
 PARAMCROSSACCTACCESS=FALSE
 PARAMNTSLTYPE=BNOSLTYPESHARE
 PARAMMEMOMODE=FALSE
 PARAMALLOWEDIT=ALLOWEDITFALSE
 PARAMEDITUSERLIST="none"
 PARAMVALIDATIONNAMETYPES="00,01,05,06,07,08,09"
 PARAMALLOWABLESHARECODES(SHARECODESAVINGS)=TRUE
 PARAMALLOWABLESHARECODES(SHARECODEDRAFT)=TRUE
 PARAMALLOWABLESHARECODES(SHARECODECERT)=FALSE
 PARAMALLOWABLESHARECODES(SHARECODECLUB)=FALSE
 PARAMSIDOPTIONAL=FALSE
 PARAMIDLENTEST=0
 PARAMTRANCOMMENT=""
 PARAMLBLMEMBERNAME=""
 PARAMLBLID=""
 PARAMTESTMODE=FALSE
 PARAMTESTACCTLIST=""
 PARAMINSTALLDATE=DATENULL
 PARAMDEBUGMODE=-1
 PARAMDEBUGMODECHR=""
 PARAMERRDISPLAYCOUNT=0

 FILEOPEN("LETTER",CONFIGFILENAME,"READ",LFNUMBER,LFERROR)
 IF LFERROR<>"" THEN
  DO
   BNOERRORCODE=BNOERRCODECONFIGREAD
   BNOERRORMODIFIER=BNOERRMODOPEN
   BNOERRORMODIFIER=CONFIGFILENAME+" open error - "+LFERROR
  END
 ELSE
  DO
   FILEREADLINE(LFNUMBER,LFLINE,LFERROR)
   IF LFERROR<>"" AND
      LFERROR<>"EOF" THEN
    DO
     BNOERRORCODE=BNOERRCODECONFIGREAD
     BNOERRORMODIFIER=BNOERRMODREAD
     BNOERRORMODIFIER=CONFIGFILENAME+" read error - "+LFERROR
    END
   WHILE LFERROR=""
    DO
     CALL NORMALIZEDATA
     
     IF PARAMNAME<>"" THEN
      DO
       IF SEGMENT(PARAMNAME,1,3)="EDM" THEN
        DO
         TMPERRCODE=VALUE(SEGMENT(PARAMNAME,4,6))
         IF CHARACTERSEARCH(BNOERRDISPLAYLIST,FORMAT("999",TMPERRCODE))>0 THEN
          DO
           BNOTEXT=PARAMVALUE
           CALL BNONTS
           CALL BNOCLEANUPTEXT
           TMPDISPLAYLINE=BNOTEXT
           CALL PARAMERRDISPLAYADD
          END
        END

[* Enforce Limits
*]
       IF PARAMNAME="EL" THEN
        DO
         IF CHARACTERSEARCH("1YESTRUE",UPPERCASE(PARAMVALUE))>0 THEN
          PARAMENFORCELIMITS=TRUE
        END
[* Ineligible Account Type(s)
*]
       IF PARAMNAME="IAT" AND
          PARAMVALUE<>"" THEN
        PARAMINELIGIBLEACCTS=PARAMVALUE
[* Account Warnings
*]
       ELSE IF PARAMNAME="IAW" AND
               PARAMVALUE<>"" THEN
        PARAMWARNINGSACCT=PARAMVALUE
[* Global Count Limit
*]
       IF PARAMNAME="GCL" AND
          PARAMVALUE<>"" THEN
        DO
         PARAMINSTCOUNTLIMIT=VALUE(PARAMVALUE)
        END

[* Global Amount Limit
*]
       IF PARAMNAME="GAL" AND
          PARAMVALUE<>"" THEN
        DO
         PARAMINSTAMOUNTLIMIT=MONEY(VALUE(PARAMVALUE))
        END

[* Global Individual Limit
*]
       IF PARAMNAME="GIL" AND
          PARAMVALUE<>"" THEN
        DO
         PARAMINSTINDIVLIMIT=MONEY(VALUE(PARAMVALUE))
        END

[* Cross-Account Access
*]
       ELSE IF PARAMNAME="XA" THEN
        DO
         IF CHARACTERSEARCH("1YESTRUE",UPPERCASE(PARAMVALUE))>0 THEN
          PARAMCROSSACCTACCESS=TRUE
        END
[* Transfer From Type - If parameter is not 'SHARE[S]',
** 'LOAN[S]' or 'BOTH' then defaults to NTSLTYPESHARE ('SHARES')
*]
       ELSE IF PARAMNAME="XT" AND
               PARAMVALUE<>"" THEN
        DO
         IF UPPERCASE(PARAMVALUE)="LOAN" OR
            UPPERCASE(PARAMVALUE)="LOANS" THEN
          PARAMNTSLTYPE=BNOSLTYPELOAN
         ELSE IF UPPERCASE(PARAMVALUE)="SHARE" OR
                 UPPERCASE(PARAMVALUE)="SHARES" THEN
          PARAMNTSLTYPE=BNOSLTYPESHARE
         ELSE IF UPPERCASE(PARAMVALUE)="BOTH" THEN
          PARAMNTSLTYPE=BNOSLTYPESHARELOAN
         ELSE
          PARAMNTSLTYPE=BNOSLTYPESHARE
        END
[* Allow manual transfer edits. If "TRUE" then ALL edits are allowed, else if NOT
** false then edits are allowed by user number, otherwise, edits allowed
** defaults to FALSE
*]
       ELSE IF PARAMNAME="AE" THEN
        DO
         IF CHARACTERSEARCH("YESTRUE",UPPERCASE(PARAMVALUE))>0 THEN
          PARAMALLOWEDIT=ALLOWEDITTRUE
         ELSE IF (CHARACTERSEARCH("NOFALSE",UPPERCASE(PARAMVALUE))=0 AND
                  PARAMVALUE<>"") THEN
          DO
           PARAMALLOWEDIT=ALLOWEDITUSER
           IF PARAMVALUE<>"" THEN
           PARAMEDITUSERLIST=PARAMVALUE
          END
        END
[* Validation name types
*]
       ELSE IF PARAMNAME="VNT" AND
               PARAMVALUE<>"" THEN
        DO
         PARAMVALIDATIONNAMETYPES=PARAMVALUE
        END
[* Allow transfers to certificates IF member elects to transfer to a
** specific ID
*]
       ELSE IF PARAMNAME="ACE" THEN
        DO
         IF CHARACTERSEARCH("1YESTRUE",UPPERCASE(PARAMVALUE))>0 THEN
          DO
           PARAMALLOWCERTS=TRUE
           PARAMALLOWABLESHARECODES(SHARECODECERT)=TRUE
          END
        END
[* Allow transfers to club shares IF member elects to transfer to a
** specific ID
*]
       ELSE IF PARAMNAME="ACL" THEN
        DO
         IF CHARACTERSEARCH("1YESTRUE",UPPERCASE(PARAMVALUE))>0 THEN
          DO
           PARAMALLOWCLUBS=TRUE
           PARAMALLOWABLESHARECODES(SHARECODECLUB)=TRUE
          END
        END
[* Share ID optional on new member transfers
*]
       ELSE IF PARAMNAME="SIDO" THEN
        DO
         IF CHARACTERSEARCH("1YESTRUE",UPPERCASE(PARAMVALUE))>0 THEN
          PARAMSIDOPTIONAL=TRUE
        END
[* Share/Loan ID Length Test
*]
       ELSE IF PARAMNAME="IL" AND
               PARAMVALUE<>"" THEN
        DO
         IF VALUE(PARAMVALUE)=2 THEN
          PARAMIDLENTEST=TESTIDLENGTH2
         ELSE IF VALUE(PARAMVALUE)=4 THEN
          PARAMIDLENTEST=TESTIDLENGTH4
        END
[* Default Transaction Comment
*]
       ELSE IF PARAMNAME="TC" THEN
        DO
         PARAMTRANCOMMENT=SEGMENT(PARAMVALUE,1,19)
        END
[* Member Name sub-title label
*]
       ELSE IF PARAMNAME="LBLMN" THEN
        DO
         PARAMLBLMEMBERNAME=PARAMVALUE
        END
[* ID sub-title label
*]
       ELSE IF PARAMNAME="LBLID" THEN
        DO
         PARAMLBLID=PARAMVALUE
        END
[* Debug mode. This is a hidden parameter setting which can override the default Debug
** mode setting. Use this "DB:" parameter setting in the CFG Letter file with "YES"
** or "NO" to force the Debug mode setting to be other than the default value of being on for
** the first [AUTODEBUGDAYS] days after the most recent program modification date or
** program installation date, whichever is more recent.
*]
       ELSE IF PARAMNAME="DB" THEN
        DO
         PARAMDEBUGMODECHR=PARAMVALUE [Used later in DEBUG output]
         IF PARAMVALUE<>"" THEN
          DO
           IF CHARACTERSEARCH("TRUEYES1DEBUGON",UPPERCASE(PARAMVALUE))>0 THEN
            PARAMDEBUGMODE=DEBUGMODEON
           ELSE
            PARAMDEBUGMODE=DEBUGMODEOFF
          END
        END
[* Program Installation Date
*]
       ELSE IF PARAMNAME="PID" AND
               PARAMVALUE<>"" THEN
        PARAMINSTALLDATE=DATEVALUE(PARAMVALUE)
[* Memo mode
*]
       ELSE IF PARAMNAME="MM" THEN
        DO
         IF CHARACTERSEARCH("1YESTRUE",UPPERCASE(PARAMVALUE))>0 THEN
         PARAMMEMOMODE=DEBUGMODEON
        END
[* Test Mode
*]
       ELSE IF PARAMNAME="TESTMODE" AND
               UPPERCASE(PARAMVALUE)="TRUE" THEN
        PARAMTESTMODE=TRUE
[* Test Account List
*]
       ELSE IF PARAMNAME="TESTACCOUNTLIST" THEN
        PARAMTESTACCTLIST=PARAMVALUE
      END
     PARAMNAME=""
     PARAMVALUE=""
     FILEREADLINE(LFNUMBER,LFLINE,LFERROR)
     IF LFERROR<>"" AND
        LFERROR<>"EOF" THEN
      DO
       BNOERRORCODE=BNOERRCODECONFIGREAD
       BNOERRORMODIFIER=BNOERRMODREAD
       BNOERRORMODIFIER=CONFIGFILENAME+" read error - "+LFERROR
      END
    END [WHILE LFERROR=""]
   FILECLOSE(LFNUMBER,LFERROR)
  END

 BNODEBUGMSG="EL:"+TRUEFALSECHR(PARAMENFORCELIMITS)
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="IAT:"+PARAMINELIGIBLEACCTS
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="IAW:"+PARAMWARNINGSACCT
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="GCL:"+FORMAT("######9",PARAMINSTCOUNTLIMIT)
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="GAL:"+FORMAT("##########9.99",PARAMINSTAMOUNTLIMIT)
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="XA (NTCROSSACCTACCESS):"+TRUEFALSECHR(BNOCROSSACCTACCESS)
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="XT (NTSLTYPE):"+FORMAT("9",BNOSLTYPE)
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="VNT:"+PARAMVALIDATIONNAMETYPES
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="ACE:"+TRUEFALSECHR(PARAMALLOWCERTS)
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="ACL:"+TRUEFALSECHR(PARAMALLOWCLUBS)
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="SIDO:"+TRUEFALSECHR(PARAMSIDOPTIONAL)
 CALL BNODEBUGMSGADD

 BNODEBUGMSG="AE:"+FORMAT("9",PARAMALLOWEDIT)
 CALL BNODEBUGMSGADD

 BNODEBUGMSG="PARAMEDITUSERLIST:"+PARAMEDITUSERLIST
 CALL BNODEBUGMSGADD

 BNODEBUGMSG="VALID SHARE CODES:"
 FOR TMPLOOP=0 TO SHARECODEMAX
  DO
   IF PARAMALLOWABLESHARECODES(TMPLOOP)=TRUE THEN
    BNODEBUGMSG=BNODEBUGMSG+FORMAT("9",TMPLOOP)
  END
 CALL BNODEBUGMSGADD

 IF PARAMDEBUGMODE<>-1 THEN
  DO
   BNODEBUGMSG="DB:"+PARAMDEBUGMODECHR
   CALL BNODEBUGMSGADD
  END
 BNODEBUGMSG="PID:"+FORMAT("99/99/9999",PARAMINSTALLDATE)
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="MM:"+FORMAT("9",PARAMMEMOMODE)
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="TESTMODE:"+BNOTRUEFALSECHR(PARAMTESTMODE)
 CALL BNODEBUGMSGADD
 BNODEBUGMSG="TESTACCOUNTLIST:"+PARAMTESTACCTLIST
 CALL BNODEBUGMSGADD

 LELISTINPUT=PARAMINELIGIBLEACCTS
 IF LELISTINPUT="" THEN
  LELISTINPUT="NONE"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO 9999
  DO
   INVALIDACCTYPES(TMPLOOP)=LELIST(TMPLOOP)
  END

 LELISTINPUT=PARAMWARNINGSACCT
 IF LELISTINPUT="" THEN
  LELISTINPUT="NONE"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO MAXWARNINGTYPES
  DO
   WARNINGSACCT(TMPLOOP)=LELIST(TMPLOOP)
  END

 IF PARAMALLOWEDIT=ALLOWEDITUSER THEN
  DO
   LELISTINPUT=PARAMEDITUSERLIST
   CALL LISTEXPAND
   FOR TMPLOOP=0 TO 9999
    DO
     USERSWHOCANEDIT(TMPLOOP)=LELIST(TMPLOOP)
    END
  END

 IF BNOERRORCODE<>0 THEN
  DO
   NEWLINE
   CALL JSONOPEN
   CALL PRINTPROGRAMINFO
   CALL ERRORHANDLER
  END
END [PROCEDURE]

PROCEDURE NORMALIZEDATA
[* Read in a line from the parameter Letter file and segment it into
** the parameter name and the parameter value
** PASS    LFLINE          Character line read in
** RETURN  PARAMNAME       Parameter name found
** RETURN  PARAMVALUE      Parameter value
**
*]
 PARAMNAME=""
 PARAMVALUE=""

 POS=CHARACTERSEARCH(LFLINE,":")
 IF LFLINE<>"" AND
    SEGMENT(LFLINE,1,1)<>"*" AND
    POS>1 THEN
  DO
   NLTSCHR=SEGMENT(LFLINE,1,POS-1)
   CALL NLTS
   PARAMNAME=UPPERCASE(NLTSCHR)

   NLTSCHR=SEGMENT(LFLINE,POS+1,LENGTH(LFLINE))
   CALL NLTS
   PARAMVALUE=NLTSCHR
  END
END [PROCEDURE]

PROCEDURE NLTS
[* Remove leading AND trailing spaces
**  PASS       NLTSCHR
**  RETURN     NLTSCHR
*]
 CALL NTS
 IF NLTSCHR<>"" THEN
  CALL NLS
END [PROCEDURE]

PROCEDURE NLS
[* Remove leading spaces
**  PASS       NLTSCHR
**  RETURN     NLTSCHR
*]
 WHILE (LENGTH(NLTSCHR)>0 AND
        SEGMENT(NLTSCHR,1,1)=" ")
  DO
   IF LENGTH(NLTSCHR)=1 THEN
    NLTSCHR=""
   ELSE
    NLTSCHR=SEGMENT(NLTSCHR,2,LENGTH(NLTSCHR))
  END
 IF LENGTH(NLTSCHR)=0 THEN
  NLTSCHR=""
END [PROCEDURE]

PROCEDURE NTS
[* Remove trailing spaces
**  PASS       NLTSCHR
**  RETURN     NLTSCHR
*]
 IF NLTSCHR<>"" THEN
  NLTSCHR=SEGMENT(NLTSCHR,1,LENGTH(NLTSCHR))
 IF LENGTH(NLTSCHR)=0 THEN
  NLTSCHR=""
END [PROCEDURE]

PROCEDURE PARSEDATALINE
[* Parse through a line of delimited data and store individual fields into an array
**  PASS    DATALINE  Line of data to be parsed.
**  RETURN  DATALINEFIELD  Array of data elements rom the parsed DATALINE
**  RETURN  DATAFIELDCOUNT  Number of elements in the DATALINEFIELD array
*]

 FOR TMPLOOP=0 TO DATALINEFIELDMAX
  DO
   DATALINEFIELD(TMPLOOP)=""
  END
 DATAFIELDCOUNT=0

 WHILE DATALINE<>""
  DO
   POS=CHARACTERSEARCH(DATALINE,"|")
   DATAFIELDCOUNT=DATAFIELDCOUNT+1
   IF POS=0 THEN
    DO
     DATALINEFIELD(DATAFIELDCOUNT)=DATALINE
     DATALINE=""
    END
   ELSE
    DO
     DATALINEFIELD(DATAFIELDCOUNT)=SEGMENT(DATALINE,1,POS-1)
     DATALINE=SEGMENT(DATALINE,POS+1,LENGTH(DATALINE))
    END
  END
END [PROCEDURE]

PROCEDURE BNOPRINTDEBUG
[* Add debug messages to JSON output
**  If the "DB:" parameter is set to false, then force Debug mode
**    setting to off (overrides all other Debug mode logic settings).
**  If the "DB:" parameter is set to true or the installation date was found and
**    less than [AUTODEBUGDAYS] days prior, set the Debug mode setting to true.
**  PASS    DEBUGMODE  Boolean
**  PASS    BNODEBUGCOUNT  Number of debut lines to send to JSON output
**  RETURN  BNODEBUGMSGLIST  debug output
*]
 IF LASTMODDATE+AUTODEBUGDAYS>SYSTEMDATE THEN
  DEBUGMODE=DEBUGMODEON

 IF PARAMDEBUGMODE=DEBUGMODEOFF THEN
  DEBUGMODE=DEBUGMODEOFF
 ELSE
  DO
   IF PARAMDEBUGMODE=DEBUGMODEON OR
     (PARAMINSTALLDATE<>DATENULL AND
      PARAMINSTALLDATE+AUTODEBUGDAYS>SYSTEMDATE) THEN
    DEBUGMODE=DEBUGMODEON
  END

 IF DEBUGMODE=DEBUGMODEON THEN
  DO
   FOR DEBUGLOOP=1 TO BNODEBUGCOUNT
    DO

     IF DEBUGLOOP=1 THEN
      DO
       PRINT ","
       NEWLINE

       PRINT INDENT(2)+Q+"debugData"+Q+": ["
       NEWLINE
      END
[*Limit debugoutput to 120 characters to allow for indent and JSON formatting
*]
     PRINT INDENT(2)+Q+SEGMENT(BNODEBUGMSGLIST(DEBUGLOOP),1,120)+Q
     IF DEBUGLOOP<BNODEBUGCOUNT THEN
      PRINT ","
     NEWLINE
    END
   PRINT INDENT(2)+"]"
   NEWLINE
  END
END [PROCEDURE]

PROCEDURE BNODEBUGMSGADD
[* Add debug line output to array for later display in JSON output
**  PASS    BNODEBUGMSG  Line of debug output
**  RETURN  BNODEBUGMSGLIST  Array of debug messages to display
**  RETURN  BNODEBUGCOUNT  number of debug lines to display
**
*]
 IF BNODEBUGCOUNT<BNODEBUGMSGMAX THEN
  DO
   BNODEBUGCOUNT=BNODEBUGCOUNT+1
   BNODEBUGMSGLIST(BNODEBUGCOUNT)=BNODEBUGMSG
   BNODEBUGMSG=""
  END
END [PROCEDURE]

PROCEDURE VALIDATERANGEINPUT
[* Validate user input as valid listexpand input
**  PASS       TESTCHR          User input
**  RETURN     VALIDRANGEINPUT  Boolean T/F
*]
 VALIDRANGEINPUT=TRUE
 FOR TESTLOOP=1 TO LENGTH(TESTCHR)
  DO
   IF CHARACTERSEARCH("0123456789,- ALLNONE",UPPERCASE(SEGMENT(TESTCHR,TESTLOOP,TESTLOOP)))=0 THEN
    DO
     VALIDRANGEINPUT=FALSE
     TESTLOOP=LENGTH(TESTCHR)
    END
  END
 BNODEBUGMSG="Range Input Test ("+TESTCHR+"):"+TRUEFALSECHR(VALIDRANGEINPUT)
 CALL BNODEBUGMSGADD
END [PROCEDURE]

PROCEDURE ERRORHANDLER

 CALL BNOERRGETMESSAGE

 PRINT ","
 JSONPROPNAME="errorCode"
 CALL JSONPROP
 PRINT FORMAT("999",BNOERRCODE)
 NEWLINE

 PRINT ","
 JSONPROPNAME="loggingErrorMessage"
 CALL JSONPROP
 PRINT QQ+BNOERRMESSAGE
 IF BNOERRMODIFIER<>"" THEN
  PRINT ": "+BNOERRMODIFIER
 PRINT QQ
 NEWLINE

 IF BNOERRDISPLAYMSGCOUNT>0 THEN
  DO
   PRINT ","
   JSONPROPNAME="errorDisplayMessage"
   CALL JSONPROP

   CALL JSONARRAY
   FOR TMPLOOP=1 TO BNOERRDISPLAYMSGCOUNT
    DO
     BNOTEXT=BNOERRDISPLAYMSG(TMPLOOP)
     CALL BNONTS
     PRINT QQ+BNOTEXT+QQ
     IF TMPLOOP<BNOERRDISPLAYMSGCOUNT THEN
      PRINT ","
     NEWLINE
    END
   CALL JSONARRAYEND
  END 

END

PROCEDURE VALIDATEACCOUNT
[* Validate the account against targeted account warning codes
** and validate account type
**  PASS    INVALIDACCTYPES  Array of invalid account types (indexed by ACCOUNT:TYPE)
**  RETURN  INVALIDACCTTYPEFOUND  Boolean - targeted account type found
**  RETURN  WARNINGFOUND Boolean - targeted account warning found
*]
 INVALIDACCTTYPEFOUND=FALSE
 IF INVALIDACCTYPES(ACCOUNT:TYPE)=TRUE THEN
  INVALIDACCTTYPEFOUND=TRUE

 WARNINGFOUND=FALSE
 FOR TMPLOOP=1 TO MAXWARNINGTYPES
  DO
   IF WARNINGSACCT(TMPLOOP)=TRUE AND
      ANYWARNING(ACCOUNT,TMPLOOP) THEN
    DO
     WARNINGFOUND=TMPLOOP
     TMPLOOP=MAXWARNINGTYPES
    END
  END
 IF INVALIDACCTTYPEFOUND=TRUE OR
    WARNINGFOUND<>FALSE THEN
  DO
   BNOERRORCODE=BNOERRCODEINVSOURCE
   IF INVALIDACCTTYPEFOUND=TRUE THEN
    DO
     BNOERRORMODIFIER=BNOERRMODACCTTYPE
     BNOERRORMODIFIER=FORMAT("Acct Type ###9",ACCOUNT:TYPE)
    END
   ELSE
    DO
     BNOERRORMODIFIER=BNOERRMODACCTWARN
     BNOERRORMODIFIER=FORMAT("Acct Warning ###9",WARNINGFOUND)
    END 
   CALL JSONOPEN
   CALL PRINTPROGRAMINFO
   CALL ERRORHANDLER
  END
END [PROCEDURE]

PROCEDURE PRINTPROGRAMINFO
[* Print program info to JSON output
*]
 IF INCLUDEPROGRAMINFO=TRUE THEN
  DO
   PRINT INDENT(BASEINDENT+1)+Q+"programInfo"+Q+": {"
   NEWLINE
   PRINT INDENT(BASEINDENT+2)+Q+"programName"+Q+": "+Q+"BANNO.M2MTRANSFERS.V3.POW"+Q+","
   NEWLINE
   PRINT INDENT(BASEINDENT+2)+Q+"programVersion"+Q+": "+Q+PROGRAMVERSION+Q+","
   NEWLINE
   PRINT INDENT(BASEINDENT+2)+Q+"programLastModDate"+Q+": "+Q+FORMAT("99/99/99-",LASTMODDATE)+LASTMODTIME+Q+","
   NEWLINE
   PRINT INDENT(BASEINDENT+2)+Q+"programNote1"+Q+": "+Q+PROGRAMUPDATENOTE1+Q+","
   NEWLINE
   PRINT INDENT(BASEINDENT+2)+Q+"programNote2"+Q+": "+Q+PROGRAMUPDATENOTE2+Q
   NEWLINE
   PRINT INDENT(BASEINDENT+1)+"}"
   NEWLINE
 END
END [PROCEDURE]

PROCEDURE PULLRGDATA
[* Parse through the data passed back from the UI. Data will be delimited
** with a pipe character. Data passed back will vary based upon the current
** state.
**
** STATE VERIFYMEMBER
**   PASS    @RGUSERCHR1     Member ID | First 3 of last name or business | account type | account ID
** STATE CREATETRAN
**   PASS    @RGUSERCHR1  Source Account | Recip Member ID | Acct Type or ID |
**                        Frequency | Start Date | Day 1 | Day 2
**   PASS    @RGUSERCHR2  First 3 | Nickname
**   PASS    @RGUSERCHR3  Immediate Transfer Comment
**   PASS    @RGUSERCHR4  Transaction Amount
**   PASS    @RGUSERNUM1  Recipient Locator Code (if available)
** STATE EDITTRAN
**   PASS    @RGUSERCHR1  TransferFrequency | Start Date | Day 1| Day 2
**   PASS    @RGUSERCHR2  Internal memo for immediate transfers
**   PASS    @RGUSERCHR3  Transfer Amount
** STATE DELETERECIP
**   PASS    @RGUSERNUM1  Recipient Record Locator
** STATE DELETETRAN
**   PASS    @RGUSERNUM1  Share Transfer Locator
**
**   RETURN  TARGETACCOUNT   Account Number being tested
**   RETURN  TARGETVERIFY3   First three characters of the primary/busines name on the
**                           target account.
**   RETURN  TARGETACCTTYPE
**   RETURN  TARGETSLID
**   RETURN  NEWTRANSRCACCT
**   RETURN  NEWTRANSRCIDTYPE
**   RETURN  NEWTRANSRCID
**   RETURN  NEWTRANRECIPACCT
**   RETURN  NEWTRANRECIPSLID
**   RETURN  NEWTRANRECIPLONGNAME
**   RETURN  NEWTRANRECIPSLIDTYPEFOUND
**   RETURN  NEWTRANSLDESCRIPTION
**   RETURN  NEWTRANRECIPSLIDFOUND
**   RETURN  NEWTRANFREQ
**   RETURN  NEWTRANFREQCHR
**   RETURN  NEWTRANSTARTDATE  Transfer start date
**   RETURN  NEWTRANDAY1 Transfer day 1
**   RETURN  NEWTRANDAY2 Transfer Day 2
**   RETURN  NEWTRANCOMMENT  Transfer comment for immediate transfers
**   RETURN  NEWTRANAMOUNT  Transfer amount
**   RETURN  NEWTRANRECIPLOC  Transfer recipient locator code (External Account)
**   RETURN  TARGETSLTRANLOC  Locator code of the transfer record which is being edited
**   RETURN  SLTRANSFERFOUND  Targeted S/L Transfer locator found (boolean)
**   RETURN  NEWTRANRECIPLOC  Transfer recipient locator code (External Account)
**   RETURN  RECIPLOCATOR  Recipient Record Locator
**   RETURN  TARGETSLTRANLOC  Share Transfer Locator
*]

 VALIDDATA=TRUE

 IF @RGSTATE=STATEVERIFYMEMBER THEN
  DO
[* @RGUSERCHR1
*]
   DATALINE=@RGUSERCHR1
   CALL PARSEDATALINE
   TARGETACCOUNT=DATALINEFIELD(1)
   TARGETVERIFY3=UPPERCASE(DATALINEFIELD(2))
   TARGETACCTTYPE=DATALINEFIELD(3)

   TMPSLID=DATALINEFIELD(4)
   CALL NORMALIZESLID
   TARGETSLID=TMPSLID

   IF LENGTH(TARGETACCOUNT)<10 THEN
    TARGETACCOUNT=REPEATCHR("0",10-LENGTH(TARGETACCOUNT))+TARGETACCOUNT
  END
 ELSE IF @RGSTATE=STATECREATETRAN THEN
  DO
[* @RGUSERCHR1
*]
   SOONESTAVAILABLE=FALSE
   DATALINE=@RGUSERCHR1

   BNODEBUGMSG="@RGUSERCHR1='"+@RGUSERCHR1+"'"
   CALL BNODEBUGMSGADD
   BNODEBUGMSG="DATALINE='"+DATALINE+"'"
   CALL BNODEBUGMSGADD

   CALL PARSEDATALINE

   BNODEBUGMSG="PROCEDURE CREATETRAN...:"
   CALL BNODEBUGMSGADD
   BNODEBUGMSG="  DATALINEFIELD(1):"+DATALINEFIELD(1)
   CALL BNODEBUGMSGADD
   BNODEBUGMSG="  DATALINEFIELD(2):"+DATALINEFIELD(2)
   CALL BNODEBUGMSGADD
   BNODEBUGMSG="  DATALINEFIELD(3):"+DATALINEFIELD(3)
   CALL BNODEBUGMSGADD
   BNODEBUGMSG="  DATALINEFIELD(4):"+DATALINEFIELD(4)
   CALL BNODEBUGMSGADD
   BNODEBUGMSG="  DATALINEFIELD(5):"+DATALINEFIELD(5)
   CALL BNODEBUGMSGADD
   BNODEBUGMSG="  DATALINEFIELD(6):"+DATALINEFIELD(6)
   CALL BNODEBUGMSGADD
   BNODEBUGMSG="  DATALINEFIELD(7):"+DATALINEFIELD(7)
   CALL BNODEBUGMSGADD

[* Source Acct Detail *]
   NEWTRANSOURCE=DATALINEFIELD(1)
   NEWTRANSRCACCT=SEGMENT(NEWTRANSOURCE,1,10)
   NEWTRANSRCIDTYPE=SEGMENT(NEWTRANSOURCE,11,11)
   NEWTRANSRCID=SEGMENT(NEWTRANSOURCE,12,LENGTH(NEWTRANSOURCE))


   BNODEBUGMSG="NEWTRANSOURCE:"+NEWTRANSOURCE+"   "+
               "NEWTRANSRCACCT:"+NEWTRANSRCACCT+"   "+
               "NEWTRANSRCIDTYPE:"+NEWTRANSRCIDTYPE+"   "+
               "NEWTRANSRCID:"+NEWTRANSRCID
   CALL BNODEBUGMSGADD


[* Recipent Acct Detail]
   NEWTRANRECIPACCT=DATALINEFIELD(2)
   IF LENGTH(NEWTRANRECIPACCT)<10 THEN
    NEWTRANRECIPACCT=REPEATCHR("0",10-LENGTH(NEWTRANRECIPACCT))+NEWTRANRECIPACCT
   NEWTRANRECIPSLID=DATALINEFIELD(3)

[* Recipient is either "S" or "L" and share/loan ID
*]


   TARGETSLIDFOUND=FALSE
   NEWTRANRECIPSLIDTYPEFOUND=UPPERCASE(SEGMENT(NEWTRANRECIPSLID,1,1))
   TMPSLID=SEGMENT(NEWTRANRECIPSLID,2,LENGTH(NEWTRANRECIPSLID))
   CALL NORMALIZESLID
   NEWTRANRECIPSLIDFOUND=TMPSLID

   BNODEBUGMSG="NEWTRANRECIPSLID:"+NEWTRANRECIPSLID+
               "   NEWTRANRECIPSLIDTYPEFOUND:"+NEWTRANRECIPSLIDTYPEFOUND+
               "   TMPSLID:"+TMPSLID
   CALL BNODEBUGMSGADD

   BNODEBUGMSG="Targeting by specific ID: "+NEWTRANRECIPACCT+" "+UPPERCASE(NEWTRANRECIPSLIDTYPEFOUND)+" '"+NEWTRANRECIPSLIDFOUND+"'"
   CALL BNODEBUGMSGADD

   FOR ACCOUNT NEWTRANRECIPACCT
    DO
     NEWTRANRECIPLONGNAME=NAME:LONGNAME
     IF UPPERCASE(NEWTRANRECIPSLIDTYPEFOUND)="S" THEN
      DO
       FOR EACH SHARE WITH (SHARE:ID=NEWTRANRECIPSLIDFOUND AND
                            SHARE:IRSCODE=0 AND
                            PARAMALLOWABLESHARECODES(SHARE:SHARECODE)=TRUE)
        DO
         SVCCODEFOUND=FALSE
         FOR TMPLOOP=1 TO SVCCODEMAX
          DO
           IF SERVICEIN(TMPLOOP)=TRUE AND
              ANYSERVICE(SHARE,TMPLOOP) THEN
            DO
             SVCCODEFOUND=TRUE
             TMPLOOP=SVCCODEMAX
            END
          END
         BNODEBUGMSG=FORMAT("SHARE SVC CODE FOUND=9",SVCCODEFOUND)
         CALL BNODEBUGMSGADD
         IF SVCCODEFOUND=TRUE THEN
          DO
           TARGETSLIDFOUND=TRUE
           NEWTRANSLDESCRIPTION=SHARE:NICKNAME
           IF NEWTRANSLDESCRIPTION="" THEN
            NEWTRANSLDESCRIPTION=SHARE:DESCRIPTION

           CHARCHECK=NEWTRANSLDESCRIPTION
           CALL CHECKFORINVALIDCHARS
           NEWTRANSLDESCRIPTION=CHARCHECKRETURN
          END
        END

      END [IF UPPERCASE(NEWTRANRECIPSLIDTYPEFOUND)="S" THEN]
     ELSE
      DO
       FOR EACH LOAN WITH LOAN:ID=NEWTRANRECIPSLIDFOUND
        DO
         SVCCODEFOUND=FALSE
         FOR TMPLOOP=1 TO SVCCODEMAX
          DO
           IF SERVICEIN(TMPLOOP)=TRUE AND
              ANYSERVICE(LOAN,TMPLOOP) THEN
            DO
             SVCCODEFOUND=TRUE
             TMPLOOP=SVCCODEMAX
            END
          END
         BNODEBUGMSG=FORMAT("LOAN SVC CODE FOUND=9",SVCCODEFOUND)
         CALL BNODEBUGMSGADD
         IF SVCCODEFOUND=TRUE THEN
          DO
           TARGETSLIDFOUND=TRUE
           NEWTRANSLDESCRIPTION=LOAN:NICKNAME
           IF NEWTRANSLDESCRIPTION="" THEN
            NEWTRANSLDESCRIPTION=LOAN:DESCRIPTION

           CHARCHECK=NEWTRANSLDESCRIPTION
           CALL CHECKFORINVALIDCHARS
           NEWTRANSLDESCRIPTION=CHARCHECKRETURN
          END
        END
      END
    END

   NEWTRANFREQCHR=DATALINEFIELD(4)
   CALL FINDFREQNUM

   IF LOWERCASE(DATALINEFIELD(5))="soonest" THEN
    SOONESTAVAILABLE=TRUE
   ELSE
    NEWTRANSTARTDATE=DATEVALUE(DATALINEFIELD(5))

   NEWTRANDAY1=VALUE(DATALINEFIELD(6))
   NEWTRANDAY2=VALUE(DATALINEFIELD(7))
[* @RGUSERCHR2
*]
   DATALINE=@RGUSERCHR2
   CALL PARSEDATALINE
   NEWTRANFIRST3=DATALINEFIELD(1)
   NEWTRANNICKNAME=DATALINEFIELD(2)
[* @RGUSERCHR3
*]
   NLTSCHR=@RGUSERCHR3
   CALL NLS
   NEWTRANCOMMENT=NLTSCHR
[* @RGUSERCHR4
*]
   NLTSCHR=@RGUSERCHR4
   CALL NLTS
   TMPAMTCHR=NLTSCHR
   CALL AMTCHRTOMONEY
[* @RGUSERNUM1
*]
   NEWTRANRECIPLOC=@RGUSERNUM1
  END
 ELSE IF @RGSTATE=STATEEDITTRAN THEN
  DO
[* @RGUSERNUM1
*]
   TARGETSLTRANLOC=@RGUSERNUM1
   SLTRANSFERFOUND=FALSE
   FOR EACH SHARE
    DO
     FOR EACH SHARE TRANSFER WITH (SHARE TRANSFER:LOCATOR=TARGETSLTRANLOC)
      DO
       SLTRANSFERFOUND=TRUE
       NEWTRANSRCACCT=ACCOUNT:NUMBER
       NEWTRANSRCIDTYPE="S"
       NEWTRANSRCID=SHARE:ID
       NEWTRANSRCAMOUNT=SHARE TRANSFER:AMOUNT
       NEWTRANRECIPACCT=SHARE TRANSFER:ACCOUNTNUMBER
       IF SHARE TRANSFER:IDTYPE=0 THEN
        NEWTRANRECIPSLIDTYPEFOUND="S"
       ELSE
        NEWTRANRECIPSLIDTYPEFOUND="L"
       NEWTRANRECIPSLIDFOUND=SHARE TRANSFER:ID
      END
    END UNTIL SLTRANSFERFOUND=TRUE
   
   IF SLTRANSFERFOUND=TRUE THEN
    DO

[* @RGUSERCHR1
*]
     DATALINE=@RGUSERCHR1
     CALL PARSEDATALINE
     NEWTRANFREQCHR=DATALINEFIELD(1)
     CALL FINDFREQNUM
     NEWTRANSTARTDATE=DATEVALUE(DATALINEFIELD(2))
     NEWTRANDAY1=VALUE(DATALINEFIELD(3))
     NEWTRANDAY2=VALUE(DATALINEFIELD(4))

[* @RGUSERCHR2
*]
     NLTSCHR=@RGUSERCHR2
     CALL NTS
     NEWTRANCOMMENT=NLTSCHR

[* @RGUSERCHR3
*]
     NLTSCHR=@RGUSERCHR3
     CALL NLTS
     TMPAMTCHR=NLTSCHR
     CALL AMTCHRTOMONEY

     FOR ACCOUNT NEWTRANRECIPACCT
      DO
       NEWTRANRECIPLONGNAME=NAME:LONGNAME
       FOR EACH SHARE WITH (SHARE:ID=NEWTRANRECIPSLIDFOUND)
        DO
         NEWTRANSLDESCRIPTION=SHARE:NICKNAME
         IF NEWTRANSLDESCRIPTION="" THEN
          NEWTRANSLDESCRIPTION=SHARE:DESCRIPTION

         CHARCHECK=NEWTRANSLDESCRIPTION
         CALL CHECKFORINVALIDCHARS
         NEWTRANSLDESCRIPTION=CHARCHECKRETURN
        END
      END
    END
  END
 ELSE IF @RGSTATE=STATEDELETERECIP THEN
  DO
   RECIPLOCATOR=@RGUSERNUM1
  END
 ELSE IF @RGSTATE=STATEDELETETRAN THEN
  DO
   TARGETSLTRANLOC=@RGUSERNUM1
  END
END [PROCEDURE]

PROCEDURE VALIDATEACCOUNTNUM
 VALIDACCTNUM=TRUE

 NLTSCHR=TMPACCT
 CALL NLTS
 TMPACCT=NLTSCHR

 IF LENGTH(TMPACCT)<1 OR
    LENGTH(TMPACCT)>10 THEN
  VALIDACCTNUM=FALSE
 ELSE
  DO
   FOR TMPLOOP=1 TO LENGTH(TMPACCT)
    DO
     IF CHARACTERSEARCH("0123456789",SEGMENT(TMPACCT,TMPLOOP,TMPLOOP))=0 THEN
      DO
       VALIDACCTNUM=FALSE
       TMPLOOP=LENGTH(TMPACCT)
      END
    END
  END
 TMPACCT=REPEATCHR("0",10-LENGTH(TMPACCT))+TMPACCT
END

PROCEDURE EXPIRERECIPIENT
[* Delete targeted recipient record (External Account) and output
** success or error code detail. Include updated current state in
** output
**  PASS    RECIPLOCATOR  Locator code of record to delete
**  RETURN  FMERROR       Expiration attempt error attempt return
**  RETURN  BNOERRORCODE     Error code if attempt failed
*]
 FMPERFORM REVISE EXTERNALACCOUNT LOC RECIPLOCATOR (0,0,FMERROR)
  DO
   SET EXPIRATIONDATE TO SYSTEMDATE
  END
 IF FMERROR<>"" THEN
  DO
   BNOERRORCODE=BNOERRCODEPROCRECIP
   CALL JSONOPEN
   CALL PRINTPROGRAMINFO
   CALL ERRORHANDLER
   CALL JSONCLOSE
  END
 ELSE
  DO
   NLTSCHR=FORMAT("#######9",RECIPLOCATOR)
   CALL NLS
   PRINT "{"
   NEWLINE
   PRINT "  "+Q+"results"+Q+": {"
   NEWLINE
   PRINT "    "+Q+"success"+Q+": true,"
   NEWLINE
   PRINT "    "+Q+"recipientLoc"+Q+": "+Q+NLTSCHR+Q+","
   NEWLINE

   WHILELIMIT=1000000
   FOR ACCOUNT ACCOUNT:NUMBER
    DO
     CALL READPREFSETTINGS
     CALL CALCLIMITS
     IF BNOERRORCODE=0 THEN
      DO
       CALL BUILDSHARELOANLIST

       CALL BUILDRECIPLIST
       CALL BUILDSLTRANSFERLIST
      END
    END
   BASEINDENT=1
   CALL PRINTPROGRAMINFO
   CALL PRINTCURRENTSTATE
   PRINT "}"
  END
END [PROCEDURE]

PROCEDURE FINDFREQNUM
[* Find the numeric frequency corresponding to the Banno text version of the frequency
**  PASS    NEWTRANFREQCHR    Transer frequency in character format
**  RETURN  NEWTRANFREQFOUND  Matching frequency found? Boolean TRUE/FALSE
**  RETURN  NEWTRANFREQ       Corresponding Share Transfer frequency number
*]
 NEWTRANFREQFOUND=FALSE
 NEWTRANFREQ=-1

 FOR FREQLOOP=0 TO TRANSFERFREQMAX
  DO
   IF UPPERCASE(NEWTRANFREQCHR)=UPPERCASE(TRANSFERFREQCHR(TRANFREQALT,FREQLOOP)) THEN
    DO
     NEWTRANFREQ=FREQLOOP
     NEWTRANFREQFOUND=TRUE
    END
  END
END [PROCEDURE]

PROCEDURE AMTCHRTOMONEY
[* Convert text monetary amount to money value. Text value may or may not
** have a decimal with or without trailing digits
**  PASS    TMPAMTCHR       Monetary value in character format
**  RETURN  NEWTRANAMOUNT   Converted monetary value in money format
*]
 NEWTRANAMOUNT=$0.00

 POS=CHARACTERSEARCH(TMPAMTCHR,".")
 IF POS>0 THEN
  DO
   IF POS=LENGTH(TMPAMTCHR)-1 THEN
    NEWTRANAMOUNT=MONEY(VALUE(TMPAMTCHR+"0"))
   ELSE
    NEWTRANAMOUNT=MONEY(VALUE(TMPAMTCHR))
  END
 ELSE
  NEWTRANAMOUNT=MONEY(VALUE(TMPAMTCHR)*100)
END [PROCEDURE]

PROCEDURE NORMALIZESLID
[* Trim or pad the user input to the required 2 or 4 digit S/L ID
**  PASS    TMPSLID   S/L ID user input
**  RETURN  TMPSLID   Correct length S/L ID
*]

 IF TMPSLID="na" THEN
  TMPSLID=""
 IF TMPSLID<>"" THEN
  DO
   TMPSLID="0000"+TMPSLID
   TMPSLID=SEGMENT(TMPSLID,(LENGTH(TMPSLID)-SLIDLEN)+1,LENGTH(TMPSLID))
  END
END [PROCEDURE]

PROCEDURE CHECKFORINVALIDCHARS
[* Check the passed character value for any double-quotes (ascii 34)
** or backslashes (ascii 92) and if found prepend with an escape
** character (ascii 92).
**
**  PASS    CHARCHECK  Character value being tested
**  RETURN  CHARCHECKRETURN  Updated CHARCHECK character value
*]
 CHARCHECKRETURN=""


 FOR CHARCHECKNUM=1 TO LENGTH(CHARCHECK)
  DO
   CHARCHECKTMP=SEGMENT(CHARCHECK,CHARCHECKNUM,CHARCHECKNUM)
   IF CHARCHECKTMP=CTRLCHR(34) THEN
    CHARCHECKRETURN=CHARCHECKRETURN+CTRLCHR(92)+CTRLCHR(34)
   ELSE IF CHARCHECKTMP=CTRLCHR(92) THEN
    CHARCHECKRETURN=CHARCHECKRETURN+CTRLCHR(92)+CTRLCHR(92)
   ELSE
    CHARCHECKRETURN=CHARCHECKRETURN+CHARCHECKTMP
  END
END [PROCEDURE]

[*
**  --------------------------------------------------------------------
**  Debug/Error Processing Procedures
**  --------------------------------------------------------------------
*]

PROCEDURE BNOERRINIT
[* Initialize BNOERR variables
*]

 BNOERRCOUNT=0
 BNOERRMESSAGE=""
 BNOERRDISPLAYMSGCOUNT=0
END [PROCEDURE]

PROCEDURE BNOERRADD
[* Adds an error code to the valid list of error codes
**
**  PASS    BNOERRCODE       Numeric error code
**  PASS    BNOERRMESSAGE    Error description
*]

 IF BNOERRCOUNT<BNOERRMAX THEN
  DO
   BNOERRCOUNT=BNOERRCOUNT+1
   BNOERRCODES(BNOERRCOUNT)=BNOERRCODE
   BNOERRMESSAGES(BNOERRCOUNT)=BNOERRMESSAGE
  END
END [PROCEDURE]

PROCEDURE BNOERRUPDATE
[* Updates an error code error message.  Used to override the error code
** message that was assigned in the SETUP division of the PowerOn.
**
**  PASS    BNOERRCODE       Numeric error code
**  PASS    BNOERRMESSAGE    Error description
*]

 BNOERRTMPCOUNT=1
 BNOERRFOUND=FALSE
 WHILE BNOERRTMPCOUNT<=BNOERRCOUNT AND 
       BNOERRFOUND=FALSE
  DO
   IF BNOERRCODES(BNOERRTMPCOUNT)=BNOERRCODE THEN
    DO
     BNOERRFOUND=TRUE
     BNOERRMESSAGES(BNOERRTMPCOUNT)=BNOERRMESSAGE
    END
   BNOERRTMPCOUNT=BNOERRTMPCOUNT+1
  END
 BNOERRMESSAGE=""
END [PROCEDURE]

PROCEDURE BNOERRDISPLAYAPPEND
[* Append an error display line (from the config) to the temporary BNOERRDISPLAYMSG array.
** Procedure BNOERRDISPLAYUPDATE is called after this to commit the set of message lines.
*]

 IF BNOERRDISPLAYMSGCOUNT<BNOERRDISPLAYMSGSMAX THEN
  DO
   BNOERRDISPLAYMSGCOUNT=BNOERRDISPLAYMSGCOUNT+1
   BNOERRDISPLAYMSG(BNOERRDISPLAYMSGCOUNT)=BNOERRDISPLAYLINE
  END 
END [PROCEDURE]

PROCEDURE BNOERRDISPLAYUPDATE
[* Commits the BNOERRDISPLAYMSG tmp array to the BNOERRDISPLAYMSGS array.
*]

 BNOERRTMPCOUNT=1
 BNOERRFOUND=FALSE
 WHILE BNOERRTMPCOUNT<=BNOERRCOUNT AND 
       BNOERRFOUND=FALSE
  DO
   IF BNOERRCODES(BNOERRTMPCOUNT)=BNOERRCODE THEN
    DO
     BNOERRFOUND=TRUE
     BNOERRDISPLAYMSGSCOUNT(BNOERRTMPCOUNT)=BNOERRDISPLAYMSGCOUNT
     FOR BNOERRTMPCOUNT2=1 TO BNOERRDISPLAYMSGCOUNT
      DO
       BNOERRDISPLAYMSGS(BNOERRTMPCOUNT,BNOERRTMPCOUNT2)=BNOERRDISPLAYMSG(BNOERRTMPCOUNT2)
      END
    END
   BNOERRTMPCOUNT=BNOERRTMPCOUNT+1
  END
 BNOERRDISPLAYMSGCOUNT=0
END [PROCEDURE]

PROCEDURE BNOERRGETMESSAGE
[* Gets the error message associated with the BNOERRORCODE
**
**  PASS    BNOERRORCODE     Numeric error code
**  PASS    BNOERRORMODIFIER Msg modifier
**
**  RETURN  BNOERRCODE       Error code
**  RETURN  BNOERRMESSAGE    Error description
**  RETURN  BNOERRMODIFIER   Msg modifier
*]

 BNOERRMESSAGE=BNOERRUNDEFINED
 BNOERRMODIFIER=""
 BNOERRCODE=BNOERRORCODE
 BNOERRTMPCOUNT=1
 WHILE BNOERRTMPCOUNT<=BNOERRCOUNT AND 
       BNOERRMESSAGE=BNOERRUNDEFINED
  DO
   IF BNOERRCODES(BNOERRTMPCOUNT)=BNOERRORCODE THEN
    DO
     BNOERRMESSAGE=BNOERRMESSAGES(BNOERRTMPCOUNT)
     IF BNOERRORMODIFIER<>"" THEN
      BNOERRMODIFIER=BNOERRORMODIFIER

     BNOERRDISPLAYMSGCOUNT=BNOERRDISPLAYMSGSCOUNT(BNOERRTMPCOUNT)
     FOR BNOERRTMPCOUNT2=1 TO BNOERRDISPLAYMSGCOUNT
      DO
       BNOERRDISPLAYMSG(BNOERRTMPCOUNT2)=BNOERRDISPLAYMSGS(BNOERRTMPCOUNT,BNOERRTMPCOUNT2)
      END
 
    END 
   BNOERRTMPCOUNT=BNOERRTMPCOUNT+1
  END
END [PROCEDURE]

[*
**  --------------------------------------------------------------------
**  Utility Procedures
**  --------------------------------------------------------------------
*]
PROCEDURE BNONLTS
[* Remove leading and trailing spaces
**  PASS       BNOTEXT
**  RETURN     BNOTEXT
*]
 CALL BNONTS
 CALL BNONLS
END [PROCEDURE]

PROCEDURE BNONLS
[* Remove leading spaces
**  PASS       BNOTEXT
**  RETURN     BNOTEXT
*]
 IF LENGTH(BNOTEXT)=0 THEN
  BNOTEXT=""
 ELSE
  DO
   WHILE (LENGTH(BNOTEXT)>0 AND
          SEGMENT(BNOTEXT,1,1)=" ")
    DO
     BNOTEXT=SEGMENT(BNOTEXT,2,LENGTH(BNOTEXT))
    END
  END
END [PROCEDURE]

PROCEDURE BNONTS
[* Remove trailing spaces
**  PASS       BNOTEXT
**  RETURN     BNOTEXT
*]
 IF BNOTEXT<>"" THEN
  BNOTEXT=SEGMENT(BNOTEXT,1,LENGTH(BNOTEXT))
END [PROCEDURE]

PROCEDURE BNONLZ
[* Removes leading zeros. Does not remove leading spaces.
** '00123' results in '123'.
** ' 0123' results in ' 0123'
** '00000' results in ''.
** As a byproduct, trailing spaces are also removed.
**
**  PASS       BNOTEXT
**  RETURN     BNOTEXT
*]
 IF BNOTEXT<>"" THEN
  DO
   WHILE (SEGMENT(BNOTEXT,1,1)="0")
    DO
     IF LENGTH(BNOTEXT)=1 THEN
      BNOTEXT=""
     ELSE
      BNOTEXT=SEGMENT(BNOTEXT,2,LENGTH(BNOTEXT))
    END
  END
END [PROCEDURE]

PROCEDURE BNOCLEANUPTEXT
[* Check character string and remove out any characters or hidden
** characters which have an ASCII value which is not established in
** the VALIDCHRINPUT1 string in the SETUP division . This is to avoid
** display issues with displaying the terms or conditions. Additionally,
** if a back-slash or double quote is encountered, add a preceding
** backslash
**  PASS       BNOTEXT   String to test
**  RETURN     BNOTEXT   Updated string
*]
 LELISTINPUT=CLEANUPVALIDCHRLIST
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO CLEANUPVALIDCHRMAX
  DO
   CLEANUPVALIDCHRS(TMPLOOP)=LELIST(TMPLOOP)
  END
 
 TMPCHR=""
 IF BNOTEXT<>"" THEN
  DO
   FOR TMPLOOP=1 TO LENGTH(BNOTEXT)
    DO
     CHRVAL=CHRVALUE(SEGMENT(BNOTEXT,TMPLOOP,TMPLOOP))
     IF  CLEANUPVALIDCHRS(CHRVAL)=TRUE THEN
      DO
[* Check for back-slash or double-quote. If found, precede with a back-slash
*]
       IF CHRVAL=CHRVALBACKSLASH OR CHRVAL=CHRVALQUOTE THEN
        TMPCHR=TMPCHR+CTRLCHR(CHRVALBACKSLASH)+SEGMENT(BNOTEXT,TMPLOOP,TMPLOOP)
       ELSE
        TMPCHR=TMPCHR+SEGMENT(BNOTEXT,TMPLOOP,TMPLOOP)
      END
    END
  END
 BNOTEXT=TMPCHR
END [PROCEDURE]

PROCEDURE PARAMERRDISPLAYADD
[* Add individual EDM display error lines to the correct PARAMERRORDISPLAY array
*]

 BNOPARAMFOUNDINDEX=1
 BNOPARAMFOUND=FALSE
 WHILE BNOPARAMFOUNDINDEX<=PARAMERRDISPLAYCOUNT AND 
       BNOPARAMFOUND=FALSE
  DO
   IF PARAMERRDISPLAY(BNOPARAMFOUNDINDEX,ERRDISPLAYERRCODE)=TMPERRCODE THEN
    BNOPARAMFOUND=TRUE
   ELSE 
    BNOPARAMFOUNDINDEX=BNOPARAMFOUNDINDEX+1
  END

 IF BNOPARAMFOUNDINDEX<=PARAMERRDISPLAYMAX THEN
  DO
   IF BNOPARAMFOUND=FALSE THEN
    DO
     PARAMERRDISPLAYCOUNT=BNOPARAMFOUNDINDEX
     PARAMERRDISPLAY(BNOPARAMFOUNDINDEX,ERRDISPLAYERRCODE)=TMPERRCODE
     PARAMERRDISPLAY(BNOPARAMFOUNDINDEX,ERRDISPLAYLINECOUNT)=1
     PARAMERRDISPLAYLINES(BNOPARAMFOUNDINDEX,1)=TMPDISPLAYLINE
    END
   ELSE 
    DO
     TMPLINECOUNT=PARAMERRDISPLAY(BNOPARAMFOUNDINDEX,ERRDISPLAYLINECOUNT)
     IF TMPLINECOUNT<PARAMERRDISPLAYLINESMAX THEN
      DO
       TMPLINECOUNT=TMPLINECOUNT+1
       PARAMERRDISPLAY(BNOPARAMFOUNDINDEX,ERRDISPLAYLINECOUNT)=TMPLINECOUNT
       PARAMERRDISPLAYLINES(BNOPARAMFOUNDINDEX,TMPLINECOUNT)=TMPDISPLAYLINE
      END 
    END 
  END
END [PROCEDURE]

PROCEDURE BNOERRDISPLAYLISTADD
[* Add to the list of errors that support error display messages.  Used to 
** register those error codes that support display messages.
*]

 IF BNOERRDISPLAYLIST<>"" THEN
  BNOERRDISPLAYLIST=BNOERRDISPLAYLIST+","
 BNOERRDISPLAYLIST=BNOERRDISPLAYLIST+FORMAT("999",BNOERRDISPLAYCODE)
END [PROCEDURE]

PROCEDURE PARAMPOSTPROCESS
[* Post-processing of the param/cfg variables
*]

[* Ignore if only one blank line is configured
*]
 FOR TMPLOOP=1 TO PARAMERRDISPLAYCOUNT
  DO
   IF PARAMERRDISPLAY(TMPLOOP,ERRDISPLAYLINECOUNT)=1 AND 
      PARAMERRDISPLAYLINES(TMPLOOP,1)="" THEN
    PARAMERRDISPLAY(TMPLOOP,ERRDISPLAYLINECOUNT)=0
  END

 FOR TMPLOOP=1 TO PARAMERRDISPLAYCOUNT
  DO
   FOR TMPLOOP2=1 TO PARAMERRDISPLAY(TMPLOOP,ERRDISPLAYLINECOUNT)
    DO
     BNOTEXT=PARAMERRDISPLAYLINES(TMPLOOP,TMPLOOP2)
     CALL BNONTS
     BNOERRDISPLAYLINE=BNOTEXT
     CALL BNOERRDISPLAYAPPEND
    END
   BNOERRCODE=PARAMERRDISPLAY(TMPLOOP,ERRDISPLAYERRCODE) 
   CALL BNOERRDISPLAYUPDATE
  END
END [PROCEDURE]

[*
**  --------------------------------------------------------------------
**  JSON Procedures - Common
**  --------------------------------------------------------------------
*]
PROCEDURE JSONOPEN
[* Output JSON open char
*]
 PRINT "{"
 NEWLINE
END [PROCEDURE]

PROCEDURE JSONCLOSE
[* Output JSON close char
*]
 PRINT "}"
 NEWLINE
END [PROCEDURE]

PROCEDURE JSONOBJ
[* Output JSON object open char
*]
 PRINT "{"
END [PROCEDURE]

PROCEDURE JSONOBJEND
[* Output JSON object close char
*]
 PRINT "}"
 NEWLINE
END [PROCEDURE]

PROCEDURE JSONARRAY
[* Output JSON array open char
*]
 PRINT "["
END [PROCEDURE]

PROCEDURE JSONARRAYEND
[* Output JSON array close char
*]
 PRINT "]"
 NEWLINE
END [PROCEDURE]

PROCEDURE JSONPROP
[* Output JSON property name
*]
 PRINT QQ+JSONPROPNAME+QQ+":"
END [PROCEDURE]


#INCLUDE "RB.LISTEXPAND"
#INCLUDE "BNOLB.SLLISTBUILD.PRO"

