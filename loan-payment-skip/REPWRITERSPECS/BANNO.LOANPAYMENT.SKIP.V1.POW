[*  Copyright 2019-2022 Jack Henry and Associates
**
**  PowerOn Name:                   BANNO.LOANPAYMENT.SKIP.V1.POW
**  Configuration Letterfile Name:  BANNO.LOANPAYMENT.SKIP.CFG
**
**  Program Summary
**  --------------------------------------------------------------------
**  This Banno service PowerOn allow the user to select one or more
**  eligible loans and, for a fee, have the loan due date advanced
**  by 28 days, 1 month or one payment cycle, depending upon the
**  parameter settings. Once the new due date has been calculated, the
**  loan maturity date will also be advanced accordingly.
**
**  Modification History
**  --------------------------------------------------------------------
**  Ver. 1.0.0  Original Programming
**  Ver. 1.0.1  03/24/2020: fixes for no fee and skip period
**  Ver. 1.0.2  04/16/2020: fixes for invalid punctuation in share
**              descriptions
**  Ver. 1.0.3  06/16/2020: Correct new due date and maturity date to
**              insure it falls on the correct day of the week.
**  Ver. 1.0.4  10/28/2021: Correct processing of disclosure blank lines.
**              Added forced space between consecutive lines of text
**  Ver. 1.0.5  11/30/2021: TKainz - Banno
**              Changed max DQ grace days from 30 to unlimited
**  Ver. 1.1.0  02/04/2022: TKainz - Banno
**              Added parameter to allow loan eligibility to also be based
**               upon loan payment frequencies.
**              Added parameter to allow CU to keep new payment due date
**               calc. as it currently operates (28 days/1 month) or allow
**               the new due date calculation to be based upon the
**               actual payment frequency.
**              Added additional logic for skip first/skip last loan
**               frequencies even though they may be set for the "M"
**               (1 month/28 day) due date advance option.
**              Added parameter setting for min. number of payments
**               requirement (LOAN:PAYMENTHISTORY:1)
**              Added parameter for loan eligibility to be based upon loan
**               not having a certain approval code (LOAN:APPROVALCODE)
**              Added parameter to allow loan eligibility to be based upon
**               max number of DQ payment counts (LOAN:PAYMENTHISTORY:[2-6])
**              Added parameter allowing program to be run in test mode.
**               With test mode on, only accounts listed as a test account
**               will have these newest changes processed on the account
**               when the member runs the program.
**              Added JSON output of debug code, parameter file settings
**               and current program test mode and account's test status.
**
**  For more information check
**  https://github.com/Banno/banno-powerons
**
**  Banno is not responsible for any modifications to this file
**  made by unauthorized personnel.
**
**  DO NOT MODIFY THIS FILE UNLESS YOU KNOW WHAT YOU'RE DOING!
*]

SYMCONNECT
STATELESS

TARGET=ACCOUNT

DEFINE
 #INCLUDE "RB.LISTEXPAND.DEF"

 Q                   = CHARACTER
 I                   = NUMBER
 J                   = NUMBER
 TOTALLOANS          = NUMBER
 ELIGIBLELOANS       = NUMBER
 WARNINGLOOP         = NUMBER
 SERVICEFOUND        = NUMBER
 SERVICELOOP         = NUMBER
 LOANSEASON          = NUMBER
 GRACEDAYS           = NUMBER
 SKIPCOUNT           = NUMBER
 TEMPLOOP            = NUMBER
 TIMEPERIOD          = CHARACTER
 ERRORMSGUSER        = CHARACTER
 ERRORMSGLOG         = CHARACTER
 ERRORFLAG           = NUMBER
 TOTALFEE            = MONEY
 FEESUM              = MONEY
 COMMAPOS            = NUMBER
 TT                  = NUMBER
 TEXTFOUND           = NUMBER
 TEXT1               = CHARACTER

 LIDLIST             = CHARACTER
 LID                 = CHARACTER
 LDUEDATE            = DATE
 LNEWDUEDATE         = DATE
 LPAYMENT            = MONEY
 LMATURITYDATE       = DATE
 LNEWMATURITYDATE    = DATE
 LDESCRIPTION        = CHARACTER(40)
 LOANLOOP            = NUMBER
 LOANDISPLAYED       = NUMBER
 SHAREDISPLAYED      = NUMBER
 SHAREFOUND          = NUMBER
 INELIGIBLEDISPLAYED = NUMBER

 SEQ1                = NUMBER
 SEQ2                = NUMBER
 CAC                 = CHARACTER
 CN                  = CHARACTER
 TRANERROR           = CHARACTER
 FMERROR             = CHARACTER

 LFNUMBER            = NUMBER
 LFERROR             = CHARACTER
 LFLINE              = CHARACTER
 READCONFIGERROR     = NUMBER
 READCONFIGERRORMSG  = CHARACTER

 LOANID              = CHARACTER(4)  ARRAY(25)
 LOANINELIGIBLECODE  = NUMBER        ARRAY(25,14)
 LOANSMAX            = 25
 INELIGIBLEREASONS   = CHARACTER(60) ARRAY(14)
 INELIGIBLEREASONSMAX= 14

 LOANTYPES           = NUMBER        ARRAY(9999)
 SHARETYPES          = NUMBER        ARRAY(9999)
 TYPESMAX            = 9999

 LOANWARNINGS        = NUMBER        ARRAY(999)
 ACCTWARNINGS        = NUMBER        ARRAY(999)
 WARNINGSMAX         = 999

 LOANSERVICECODE     = NUMBER        ARRAY(99)
 SERVICECODEMAX      = 99

 FEEAMOUNTS          = MONEY         ARRAY(99) [0:DEFAULT,
                                                01-99:REL CODE]
 FEEAMOUNTSMAX       = 99

 TERMS               = CHARACTER ARRAY(40)
 TERMSMAXLINES       = 40
 TERMSLINESCOUNT     = NUMBER
 TERMSLASTLLINEUSED  = NUMBER

 GETPRELOADDATA      = "GETPRELOADDATA"
 PERFORMSKIPAPAYMENT = "PERFORMSKIPAPAYMENT"

 CONFIGFILENAME      = "BANNO.LOANPAYMENT.SKIP.CFG"

 TRUE                      = 1
 FALSE                     = 0
 DATENULL                  = '--/--/--'

 INELIGIBLECODESET         = 0
 INELIGIBLECODELOANTYPE    = 1
 INELIGIBLECODELOANWARNING = 2
 INELIGIBLECODEMAXSKIPS    = 3
 INELIGIBLECODETIMESKIP    = 4
 INELIGIBLECODEACCTWARNING = 5
 INELIGIBLECODESERVICECODE = 6
 INELIGIBLECODEMINPAYMENT  = 7
 INELIGIBLECODEMAXPAYMENT  = 8
 INELIGIBLECODETIMEOPEN    = 9
 INELIGIBLECODEPASTDUE     = 10

 FEEAMOUNT                 = MONEY
 LOANTRACKINGTYPE          = NUMBER
 MAXSKIPS                  = NUMBER
 MINMONTHSINCE             = NUMBER
 SUBSOURCECODE             = NUMBER
 OTHERACTION               = NUMBER
 FEECOMMENT                = CHARACTER
 LOANMINPAYMENT            = MONEY
 LOANMAXPAYMENT            = MONEY
 STARTDATE                 = DATE
 ENDDATE                   = DATE

 DEFAULTFEEAMOUNT          = $35.00
 DEFAULTLOANTRACKINGTYPE   = 77
 DEFAULTMAXSKIPS           = 2
 DEFAULTMINMONTHSINCE      = 2
 DEFAULTSUBSOURCECODE      = 33 [Skip Payment Fee]
 DEFAULTOTHERACTION        = 0  [Use "FEE OTHER" OTHERACTION with Fee]
 DEFAULTFEECOMMENT         = ""
 DEFAULTLOANMINPAYMENT     = $0.00
 DEFAULTLOANMAXPAYMENT     = $0.00

 [Both start and end date must be set for this feature to work]
 DEFAULTSTARTDATE          = DATENULL
 DEFAULTENDDATE            = DATENULL

 GENERICUSERERRORMSG="We're sorry we've encountered an error. Please contact your credit union."

[* 04/16/20 *]
 TMPTEXT                   = CHARACTER
 TMPCHR                    = CHARACTER
 TMPLOOP                   = NUMBER
 TMPTEXTLOOP               = NUMBER
 CHRVAL                    = NUMBER
 VALIDCHRINPUT1            = CHARACTER
 VALIDCHARS                = NUMBER ARRAY(999)
 MAXCHRVALUE               = 255

[* 02/04/22 *]
 APPROVALCODESEXCLUDED     = NUMBER ARRAY(9999)
 BNOCFGFILENAME            = CHARACTER
 BNODEBUGCOUNT             = NUMBER
 BNODEBUGLOOP              = NUMBER
 BNODEBUGMODE              = NUMBER
 BNODEBUGMODEOFF           = 0
 BNODEBUGMODEON            = 1
 BNODEBUGMSG               = CHARACTER
 BNODEBUGMSGLIST           = CHARACTER ARRAY(999)
 BNODEBUGMSGMAX            = 999
 BNOINCLUDEPARMINDEBUG     = NUMBER
 BNOINDENT                 = CHARACTER ARRAY(9)
 BNOINDENTMAX              = 9
 BNOLASTMODDATE            = DATE
 BNOLASTMODTIME            = CHARACTER
 BNOLOCALLOOP              = NUMBER
 BNOPRINTDEBUGDAYS         = NUMBER
 BNOPRINTDEBUGINFODAYS     = NUMBER
 BNOPROGRAMNAME            = CHARACTER
 BNOPROGRAMVERSION         = CHARACTER
 CUTOFFDQA                 = NUMBER
 CUTOFFDQB                 = NUMBER
 CUTOFFDQC                 = NUMBER
 CUTOFFDQD                 = NUMBER
 CUTOFFDQE                 = NUMBER
 DUEDATECALCTYPE           = CHARACTER ARRAY(13)
 ELEGIBLEFREQUENCIES       = NUMBER ARRAY(13)
 HONORSKIPS                = NUMBER
 INCLUDEPROGRAMINFO        = NUMBER
 INELIGIBLECODEAPPROVALCODE= 13
 INELIGIBLECODEDQPAYMENTS  = 14
 INELIGIBLECODEFREQ        = 11
 INELIGIBLECODEMINPMTCOUNT = 12
 LNEWDUEMONTH              = NUMBER
 MINIMUMPAYMENTCOUNT       = NUMBER
 TESTACCOUNTLIST           = CHARACTER
 TESTMODE                  = NUMBER
 TMPPOS                    = NUMBER
 TMPVAL                    = NUMBER
 TRUEFALSECHR              = CHARACTER ARRAY(1)
 VALIDTESTACCOUNT          = NUMBER
END [DEFINE]

SETUP
 Q=CTRLCHR(34)
 TRUEFALSECHR(FALSE)="FALSE"
 TRUEFALSECHR(TRUE)="TRUE"
 CALL INITIALIZETERMS
 TERMS(1)="Some example terms go here"
 TERMS(2)="Some more text"
 TERMSLINESCOUNT=2
 VALIDCHRINPUT1="32-126,128-175,181-184,189,190,198,199,208-216,221,222,224-253"
 INCLUDEPROGRAMINFO=TRUE
 BNOLASTMODDATE='02/04/22'
 BNOLASTMODTIME="15:00 MT"
 BNOPROGRAMNAME="BANNO.LOANPAYMENT.SKIP.V1.POW"
 BNOCFGFILENAME = "BANNO.LOANPAYMENT.SKIP.V1.CFG"
 BNOPROGRAMVERSION="1.1.0"
 BNOPRINTDEBUGINFODAYS=90
 IF BNOLASTMODDATE+BNOPRINTDEBUGINFODAYS>SYSTEMDATE THEN
  BNODEBUGMODE=BNODEBUGMODEON
 BNOINCLUDEPARMINDEBUG=TRUE
END [SETUP]

PRINT TITLE="Banno Skip a Loan Payment"

 CALL INITIALIZEDATA
 CALL READCONFIGFILESETTINGS

 IF @RGSTATE=GETPRELOADDATA THEN
  DO
   CALL PROCGETPRELOADDATA
  END
 ELSE IF @RGSTATE=PERFORMSKIPAPAYMENT THEN
  DO
   CALL PROCPERFORMSKIPAPAYMENT
  END

 CALL BNOPRINTPROGRAMINFO
 CALL BNOPRINTRGDATA
 CALL BNOPRINTDEBUG

 IF BNODEBUGMODE=BNODEBUGMODEOFF THEN
  NEWLINE
 PRINT "}"
 NEWLINE
END [PRINT]

PROCEDURE PROCGETPRELOADDATA
 PRINT "{"
 NEWLINE

 IF READCONFIGERROR=TRUE THEN
  DO
   PRINT Q+"clientErrorMessage"+Q+":"
   NEWLINE
   PRINT Q+GENERICUSERERRORMSG+Q
   NEWLINE
   PRINT ","+Q+"loggingErrorMessage"+Q+":"
   NEWLINE
   PRINT Q+READCONFIGERRORMSG+Q+","
   NEWLINE
  END
 ELSE
  DO
   PRINT Q+"clientErrorMessage"+Q+":"+Q+Q+","
   NEWLINE
   PRINT Q+"loggingErrorMessage"+Q+":"+Q+Q+","
   NEWLINE
  END

 [ Check if skip-a-pay is available based on start and end dates.
   Both dates must be set to a non null value for this to work.
 ]
 PRINT "  "+Q+"available"+Q+":"
 IF STARTDATE<>DATENULL AND ENDDATE<>DATENULL THEN
  DO
   IF SYSTEMDATE>=STARTDATE AND SYSTEMDATE<=ENDDATE THEN
    PRINT "true,"
   ELSE
    PRINT "false,"
  END
 ELSE
  PRINT "true,"
 NEWLINE

 PRINT "  "+Q+"availableStartDate"+Q+":"
 IF STARTDATE<>DATENULL then
  PRINT Q+FORMAT("99/99/9999",STARTDATE)+Q+","
 ELSE
  PRINT Q+Q+","
 NEWLINE

 PRINT "  "+Q+"availableEndDate"+Q+":"
 IF ENDDATE<>DATENULL then
  PRINT Q+FORMAT("99/99/9999",ENDDATE)+Q+","
 ELSE
  PRINT Q+Q+","
 NEWLINE

 PRINT "  "+Q+"feePerPaymentSkip"+Q+":"+Q+FORMAT("#######9.99",FEEAMOUNT)+Q+","
 NEWLINE

 PRINT "  "+Q+"terms"+Q+":["
 NEWLINE
 I=1
 WHILE I<TERMSMAXLINES AND
       I<=TERMSLASTLLINEUSED
  DO
   IF I>1 THEN
    PRINT ","
   PRINT Q+TERMS(I)

   IF TERMS(I)<> "" AND
      I<TERMSLASTLLINEUSED AND
      TERMS(I)<>"" THEN
    PRINT " "
   PRINT Q
   NEWLINE
   I=I+1
  END
 PRINT "],"
 NEWLINE

 CALL GETLOANDATA
 PRINT "  "+Q+"availableLoans"+Q+": ["
 NEWLINE

 LOANDISPLAYED=FALSE
 FOR LOANLOOP=1 TO TOTALLOANS
  DO
   IF LOANINELIGIBLECODE(LOANLOOP,INELIGIBLECODESET)=FALSE THEN
    DO
     LID=LOANID(LOANLOOP)
     CALL GETSKIPCRITERIA

     IF LOANDISPLAYED=TRUE THEN
      PRINT ","
     PRINT "{"
     NEWLINE
     PRINT Q+"name"+Q+": "+Q+LDESCRIPTION+Q+","
     NEWLINE
     PRINT Q+"paymentAmount"+Q+": "+Q+FORMAT("#######9.99",LPAYMENT)+Q+","
     NEWLINE
     PRINT Q+"accountId"+Q+":"+Q+LID+Q+","
     NEWLINE
     PRINT Q+"originalPaymentDueDate"+Q+": "+Q+FORMAT("99/99/9999",LDUEDATE)+Q+","
     NEWLINE
     PRINT Q+"newPaymentDueDate"+Q+": "+Q+FORMAT("99/99/9999",LNEWDUEDATE)+Q
     NEWLINE
     PRINT "}"
     NEWLINE

     LOANDISPLAYED=TRUE
    END
  END
 PRINT "  ],"
 NEWLINE

 PRINT "  "+Q+"ineligibleLoans"+Q+": ["
 NEWLINE

 LOANDISPLAYED=FALSE
 FOR LOANLOOP=1 TO TOTALLOANS
  DO
   IF LOANINELIGIBLECODE(LOANLOOP,INELIGIBLECODESET)=TRUE THEN
    DO
     LID=LOANID(LOANLOOP)
     CALL GETSKIPCRITERIA

     IF LOANDISPLAYED=TRUE THEN
      PRINT ","
     PRINT "{"
     NEWLINE
     PRINT Q+"name"+Q+": "+Q+LDESCRIPTION+Q+","
     NEWLINE
     PRINT Q+"accountId"+Q+":"+Q+LID+Q+","
     NEWLINE
     INELIGIBLEDISPLAYED=FALSE
     FOR TEMPLOOP=1 TO INELIGIBLEREASONSMAX
      DO
       IF LOANINELIGIBLECODE(LOANLOOP,TEMPLOOP)=TRUE AND
          INELIGIBLEDISPLAYED=FALSE THEN
        DO
         PRINT Q+"ineligibilityReason"+Q+": "+Q+INELIGIBLEREASONS(TEMPLOOP)+Q
         NEWLINE
         INELIGIBLEDISPLAYED=TRUE
        END
      END

     PRINT "}"
     NEWLINE

     LOANDISPLAYED=TRUE
    END
  END
 PRINT "  ],"
 NEWLINE

 PRINT "  "+Q+"availableShares"+Q+": ["
 NEWLINE

 SHAREDISPLAYED=FALSE
 FOR EACH SHARE WITH (SHARE:CLOSEDATE=DATENULL AND
                      SHARE:CHARGEOFFDATE=DATENULL AND
                      SHARE:AVAILABLEBALANCE>=FEEAMOUNT AND
                      SHARETYPES(SHARE:TYPE)=TRUE)
  DO
   TMPCHR=SHARE:DESCRIPTION
   CALL CLEANUPTEXT

   IF SHAREDISPLAYED=TRUE THEN
    PRINT ","
   PRINT "{"+Q+"name"+Q+": "+Q+TMPCHR+Q+","
   NEWLINE
   PRINT Q+"accountId"+Q+": "+Q+SHARE:ID+Q+","
   NEWLINE
   PRINT Q+"balance"+Q+": "+Q+FORMAT("#######9.99",SHARE:AVAILABLEBALANCE)+Q+"}"
   NEWLINE
   SHAREDISPLAYED=TRUE
  END
 PRINT "]"
END [PROCEDURE]

PROCEDURE PROCPERFORMSKIPAPAYMENT
 PRINT "{"+Q+"loansWithPaymentsSkipped"+Q+": ["
 NEWLINE

[* Need the loan data for input validation
*]
 CALL GETLOANDATA

 TEXT1=@RGUSERCHR2
 CALL TEXTNLTS
 @RGUSERCHR2=TEXT1

 ERRORMSGUSER=""
 ERRORMSGLOG=""
 ERRORFLAG=FALSE
 LOANDISPLAYED=FALSE
 LIDLIST=@RGUSERCHR1
 TOTALFEE=FEEAMOUNT
 FEESUM=$0.00
 WHILE LIDLIST<>"" AND ERRORFLAG=FALSE
  DO
   CALL GETNEXTLID
   CALL GETSKIPCRITERIA
   I=1
   WHILE I<=TOTALLOANS AND LOANID(I)<>LID
    DO
     I=I+1
    END

   IF I>TOTALLOANS THEN
    DO
     ERRORFLAG=TRUE
     ERRORMSGUSER=GENERICUSERERRORMSG
     ERRORMSGLOG="Invalid loan id: "+LID
    END

   IF ERRORFLAG=FALSE AND
      LOANINELIGIBLECODE(I,INELIGIBLECODESET)=TRUE THEN
    DO
     ERRORFLAG=TRUE
     ERRORMSGUSER=GENERICUSERERRORMSG
     ERRORMSGLOG="Attempt to skip a payment on an ineligible loan: "+LID
    END

   IF ERRORFLAG=FALSE AND @RGUSERCHR2<>"" THEN
    DO
     SHAREFOUND=FALSE
     FOR EACH SHARE WITH (SHARE:ID=@RGUSERCHR2)
      DO
       SHAREFOUND=TRUE
      END
     IF SHAREFOUND=FALSE THEN
      DO
       ERRORFLAG=TRUE
       ERRORMSGUSER=GENERICUSERERRORMSG
       ERRORMSGLOG="Invalid fee share id: "+@RGUSERCHR2
      END
    END

   IF ERRORFLAG=FALSE THEN
    DO
[ Update Loan fields]

     FEESUM=FEESUM+TOTALFEE
     FMPERFORM REVISE LOAN LID (0,0,FMERROR)
      DO
       SET DUEDATE       TO LNEWDUEDATE
       SET MATURITYDATE  TO LNEWMATURITYDATE
      END
     IF FMERROR<>"" THEN
      DO
       ERRORFLAG=TRUE
       ERRORMSGUSER=GENERICUSERERRORMSG
       ERRORMSGLOG="Loan Record Update Failed. Error: "+FMERROR
      END
     ELSE
      DO
[ Update Loan fields]

       FMPERFORM CREATE LOAN LID TRACKING LOC -1 (1,LOANTRACKINGTYPE,FMERROR)
        DO
         SET EXPIREDATE  TO DATENULL
         SET USERDATE1   TO SYSTEMDATE
         SET USERDATE2   TO LDUEDATE
         SET USERDATE3   TO LNEWDUEDATE
         SET USERDATE4   TO LMATURITYDATE
         SET USERDATE5   TO LNEWMATURITYDATE
         SET USERAMOUNT1 TO TOTALFEE
         SET USERAMOUNT2 TO LPAYMENT
        END
       IF FMERROR<>"" THEN
        DO
         ERRORFLAG=TRUE
         ERRORMSGUSER=GENERICUSERERRORMSG
         ERRORMSGLOG="Tracking Record Create Failed. Error: "+FMERROR
        END
       ELSE
        DO
         IF LOANDISPLAYED=TRUE THEN
          PRINT ","
         PRINT "{"
         NEWLINE
         PRINT Q+"name"+Q+": "+Q+LDESCRIPTION+Q+","
         NEWLINE
         PRINT Q+"paymentAmount"+Q+": "+Q+FORMAT("#######9.99",LPAYMENT)+Q+","
         NEWLINE
         PRINT Q+"accountId"+Q+":"+Q+LID+Q+","
         NEWLINE
         PRINT Q+"feePaid"+Q+": "+Q+FORMAT("#######9.99",TOTALFEE)+Q+","
         NEWLINE
         PRINT Q+"nextDueDate"+Q+": "+Q+FORMAT("99/99/9999",LNEWDUEDATE)+Q
         NEWLINE
         FOR EACH SHARE WITH (SHARE:ID=@RGUSERCHR2)
          DO
           TMPCHR=SHARE:DESCRIPTION
           CALL CLEANUPTEXT

           PRINT ","+Q+"shareDebited"+Q+": "+Q+TMPCHR+Q
           NEWLINE
          END
         PRINT "}"
         NEWLINE
         LOANDISPLAYED=TRUE
        END
      END
    END
  END

[ Debit fee]

 IF ERRORFLAG=FALSE AND FEESUM>$0.00 THEN
  DO
   IF OTHERACTION<>0 THEN
    DO
     TRANPERFORM WF (0,SEQ1,SEQ2,CAC,CN,TRANERROR)
      DO
       SET FMACCT TO ACCOUNT:NUMBER
       SET FMTYPE TO "S"
       SET FMID   TO @RGUSERCHR2
       SET AMOUNT TO FEESUM
       SET SUBSOURCECODE TO SUBSOURCECODE
       SET COMMENT:1 TO FEECOMMENT
       SET OTHERACTION TO FORMAT("9",OTHERACTION)
       SET OTHERIDTYPE TO "L"
       SET OTHERID TO LID
      END  [TRANPERFORM]
    END
   ELSE
    DO
     TRANPERFORM WF (0,SEQ1,SEQ2,CAC,CN,TRANERROR)
      DO
       SET FMACCT TO ACCOUNT:NUMBER
       SET FMTYPE TO "S"
       SET FMID   TO @RGUSERCHR2
       SET AMOUNT TO FEESUM
       SET SUBSOURCECODE TO SUBSOURCECODE
       SET COMMENT:1 TO FEECOMMENT
      END  [TRANPERFORM]
    END
  END
 IF TRANERROR<>"" AND ERRORFLAG=FALSE THEN
  DO
   ERRORFLAG=TRUE
   ERRORMSGUSER=GENERICUSERERRORMSG
   ERRORMSGLOG="Skip Pay Fee Post Failed. Error="+TRANERROR
  END

 PRINT "],"+Q+"clientErrorMessage"+Q+":"
 NEWLINE
 PRINT Q+ERRORMSGUSER+Q
 NEWLINE
 PRINT ","+Q+"loggingErrorMessage"+Q+":"
 NEWLINE
 PRINT Q+ERRORMSGLOG+Q
 NEWLINE
 PRINT ","+Q+"memoMode"+Q+":"
 IF SYSMEMOMODE=0 THEN
  DO
   PRINT "false"
  END
 ELSE
  DO
   PRINT "true"
  END
END [PROCEDURE]

PROCEDURE INITIALIZETERMS
 WHILELIMIT=100000
 FOR I=1 TO TERMSMAXLINES
  DO
   TERMS(I)=""
  END
END [PROCEDURE]

PROCEDURE INITIALIZEDATA
 FEEAMOUNT=DEFAULTFEEAMOUNT
 LOANTRACKINGTYPE=DEFAULTLOANTRACKINGTYPE
 MAXSKIPS=DEFAULTMAXSKIPS
 MINMONTHSINCE=DEFAULTMINMONTHSINCE
 SUBSOURCECODE=DEFAULTSUBSOURCECODE
 OTHERACTION=DEFAULTOTHERACTION
 FEECOMMENT=DEFAULTFEECOMMENT
 LOANMINPAYMENT=DEFAULTLOANMINPAYMENT
 LOANMAXPAYMENT=DEFAULTLOANMAXPAYMENT
 STARTDATE=DEFAULTSTARTDATE
 ENDDATE=DEFAULTENDDATE
 HONORSKIPS=FALSE

 WHILELIMIT=100000
 FOR I=1 TO LOANSMAX
  DO
   LOANID(I)=""
   FOR J=0 TO INELIGIBLEREASONSMAX
    DO
     LOANINELIGIBLECODE(I,J)=FALSE
    END
  END

 FOR TEMPLOOP=1 TO WARNINGSMAX
  DO
   LOANWARNINGS(TEMPLOOP)=FALSE
   ACCTWARNINGS(TEMPLOOP)=FALSE
  END

 FOR TEMPLOOP=1 TO SERVICECODEMAX
  DO
   LOANSERVICECODE(TEMPLOOP)=FALSE
  END

 FOR TEMPLOOP=1 TO FEEAMOUNTSMAX
  DO
   FEEAMOUNTS(TEMPLOOP)=$0.00
  END

 FOR TEMPLOOP=0 TO TYPESMAX
  DO
   LOANTYPES(TEMPLOOP)=TRUE
   SHARETYPES(TEMPLOOP)=TRUE
  END

 FEEAMOUNTS(0)=FEEAMOUNT
 GRACEDAYS=0

[* 01/21/22 *]
 FOR TMPLOOP=1 TO 13
  DO
   ELEGIBLEFREQUENCIES(TMPLOOP)=0
   DUEDATECALCTYPE(TMPLOOP)="M"
  END

 FOR TMPLOOP=1 TO 9999
  DO
   APPROVALCODESEXCLUDED(TMPLOOP)=0
  END

 MINIMUMPAYMENTCOUNT=0
 CUTOFFDQA=0
 CUTOFFDQB=0
 CUTOFFDQC=0
 CUTOFFDQD=0
 CUTOFFDQE=0

 TESTMODE=FALSE
 TESTACCOUNTLIST=""
 VALIDTESTACCOUNT=FALSE

 [Initialize the ineligible reason messages]
 INELIGIBLEREASONS(INELIGIBLECODELOANTYPE)=
  "Ineligible Loan Type"
 INELIGIBLEREASONS(INELIGIBLECODELOANWARNING)=
  "Loan Warning Found"
 INELIGIBLEREASONS(INELIGIBLECODEMAXSKIPS)=
  "Max Loan skips already used for last 12 months"
 INELIGIBLEREASONS(INELIGIBLECODETIMESKIP)=
  "Insufficient time since last skip"
 INELIGIBLEREASONS(INELIGIBLECODEACCTWARNING)=
  "Account Warning Found"
 INELIGIBLEREASONS(INELIGIBLECODESERVICECODE)=
  "Required Service Code(s) not found"
 INELIGIBLEREASONS(INELIGIBLECODEMINPAYMENT)=
  "Payment Less than Minimum allowed"
 INELIGIBLEREASONS(INELIGIBLECODEMAXPAYMENT)=
  "Payment More than Maximum allowed"
 INELIGIBLEREASONS(INELIGIBLECODETIMEOPEN)=
  "Insufficient time since loan was opened"
 INELIGIBLEREASONS(INELIGIBLECODEPASTDUE)=
  "Loan past due grace period elapsed"

[* 01/21/22 *]
 INELIGIBLEREASONS(INELIGIBLECODEFREQ)=
  "Loan payment frequency is ineligible"
 INELIGIBLEREASONS(INELIGIBLECODEMINPMTCOUNT)=
  "Minimum payment count not met"
 INELIGIBLEREASONS(INELIGIBLECODEAPPROVALCODE)=
  "Ineligible loan approval code"
 INELIGIBLEREASONS(INELIGIBLECODEDQPAYMENTS)=
  "Acceptable number of DQ payments exceeded"

END [PROCEDURE]

PROCEDURE READCONFIGFILESETTINGS
 READCONFIGERROR=FALSE
 READCONFIGERRORMSG=""
[ Parse letterfile]
 FILEOPEN("LETTER",CONFIGFILENAME,"READ",LFNUMBER,LFERROR)
 IF LFERROR<>"" THEN
  DO
   READCONFIGERROR=TRUE
   READCONFIGERRORMSG="Error Opening Letterfile "+CONFIGFILENAME+": "+LFERROR
   BNODEBUGMSG="ERROR READING CFG LETTER FILE '"+CONFIGFILENAME+" ' ERROR:"+LFERROR
   CALL BNODEBUGMSGADD
  END
 ELSE
  DO
   BNODEBUGMSG="*** CONFIGURATION FILE SETTINGS:"
   CALL BNODEBUGMSGADD

   TERMSLINESCOUNT=0
   WHILE LFERROR=""
    DO
     FILEREADLINE(LFNUMBER,LFLINE,LFERROR)
     IF SEGMENT(LFLINE,1,1)<>"*" AND LFLINE<>"" THEN
      DO
[ Terms & conditions]
       IF SEGMENT(LFLINE,1,3)="TC:" AND TERMSLINESCOUNT<TERMSMAXLINES THEN
        DO
         BNODEBUGMSG="    "+LFLINE
         CALL BNODEBUGMSGADD
         TERMSLINESCOUNT=TERMSLINESCOUNT+1
         TMPCHR=SEGMENT(LFLINE,4,LENGTH(LFLINE))
         CALL CLEANUPTEXT

         TERMS(TERMSLINESCOUNT)=TMPCHR
         IF TMPCHR<>"" THEN
          TERMSLASTLLINEUSED=TERMSLINESCOUNT
        END
[ Loan types]
       IF SEGMENT(LFLINE,1,3)="LT:" THEN
        DO
         BNODEBUGMSG="    "+LFLINE
         CALL BNODEBUGMSGADD
         LELISTINPUT=SEGMENT(LFLINE,4,LENGTH(LFLINE))
         CALL LISTEXPAND
         FOR I=0 TO TYPESMAX
          DO
           LOANTYPES(I)=LELIST(I)
          END
        END
[ Loan service codes]
       IF SEGMENT(LFLINE,1,3)="SC:" THEN
        DO
         BNODEBUGMSG="    "+LFLINE
         CALL BNODEBUGMSGADD
         LELISTINPUT=SEGMENT(LFLINE,4,LENGTH(LFLINE))
         IF LELISTINPUT="" THEN
          LELISTINPUT="NONE"
         CALL LISTEXPAND
         FOR I=0 TO SERVICECODEMAX
          DO
           LOANSERVICECODE(I)=LELIST(I)
          END
        END
[ Loan warning codes]
       IF SEGMENT(LFLINE,1,3)="LW:" THEN
        DO
         BNODEBUGMSG="    "+LFLINE
         CALL BNODEBUGMSGADD
         IF LENGTH(LFLINE)>3 THEN
          DO
           LELISTINPUT=SEGMENT(LFLINE,4,LENGTH(LFLINE))
           CALL LISTEXPAND
           FOR I=1 TO WARNINGSMAX
            DO
             LOANWARNINGS(I)=LELIST(I)
            END
          END
        END
[ Acct warning codes]
       IF SEGMENT(LFLINE,1,3)="AW:" THEN
        DO
         BNODEBUGMSG="    "+LFLINE
         CALL BNODEBUGMSGADD
         IF LENGTH(LFLINE)>3 THEN
          DO
           LELISTINPUT=SEGMENT(LFLINE,4,LENGTH(LFLINE))
           CALL LISTEXPAND
           FOR I=1 TO WARNINGSMAX
            DO
             ACCTWARNINGS(I)=LELIST(I)
            END
          END
        END
[ Share types]
       IF SEGMENT(LFLINE,1,3)="ST:" THEN
        DO
         BNODEBUGMSG="    "+LFLINE
         CALL BNODEBUGMSGADD
         LELISTINPUT=SEGMENT(LFLINE,4,LENGTH(LFLINE))
         CALL LISTEXPAND
         FOR I=0 TO TYPESMAX
          DO
           SHARETYPES(I)=LELIST(I)
          END
        END
[ Program time period]
       IF SEGMENT(LFLINE,1,3)="TP:" THEN
        DO
         BNODEBUGMSG="    "+LFLINE
         CALL BNODEBUGMSGADD
         TIMEPERIOD=SEGMENT(LFLINE,4,LENGTH(LFLINE))
        END
[ Min payment amount]
       IF SEGMENT(LFLINE,1,3)="MA:" THEN
        DO
         BNODEBUGMSG="    "+LFLINE
         CALL BNODEBUGMSGADD
         LOANMINPAYMENT=MONEY(VALUE(SEGMENT(LFLINE,4,LENGTH(LFLINE))))
        END
[ Max payment amount]
       IF SEGMENT(LFLINE,1,3)="XA:" THEN
        DO
         BNODEBUGMSG="    "+LFLINE
         CALL BNODEBUGMSGADD
         LOANMAXPAYMENT=MONEY(VALUE(SEGMENT(LFLINE,4,LENGTH(LFLINE))))
        END
[ Loan season]
       IF SEGMENT(LFLINE,1,3)="LS:" THEN
        DO
         BNODEBUGMSG="    "+LFLINE
         CALL BNODEBUGMSGADD
         LOANSEASON=VALUE(SEGMENT(LFLINE,4,LENGTH(LFLINE)))
         IF LOANSEASON>360 THEN
          LOANSEASON=360
        END
[ Grace days past due]
       IF SEGMENT(LFLINE,1,3)="GD:" THEN
        DO
         BNODEBUGMSG="    "+LFLINE
         CALL BNODEBUGMSGADD
         GRACEDAYS=VALUE(SEGMENT(LFLINE,4,LENGTH(LFLINE)))
         IF GRACEDAYS<0 THEN
          GRACEDAYS=0
        END
[ Fee amount(s)]
       IF SEGMENT(LFLINE,1,3)="FA:" THEN
        DO
         BNODEBUGMSG="    "+LFLINE
         CALL BNODEBUGMSGADD
         FEEAMOUNTS(VALUE(SEGMENT(LFLINE,4,5)))=
                    MONEY(VALUE(SEGMENT(LFLINE,7,LENGTH(LFLINE))))
        END
[ Loan tracking type]
       IF SEGMENT(LFLINE,1,3)="TT:" THEN
        DO
         BNODEBUGMSG="    "+LFLINE
         CALL BNODEBUGMSGADD
         LOANTRACKINGTYPE=VALUE(SEGMENT(LFLINE,4,LENGTH(LFLINE)))
        END
[ Max skips per year]
       IF SEGMENT(LFLINE,1,3)="PS:" THEN
        DO
         BNODEBUGMSG="    "+LFLINE
         CALL BNODEBUGMSGADD
         MAXSKIPS=VALUE(SEGMENT(LFLINE,4,LENGTH(LFLINE)))
        END
[ Min months since last skip]
       IF SEGMENT(LFLINE,1,3)="MM:" THEN
        DO
         BNODEBUGMSG="    "+LFLINE
         CALL BNODEBUGMSGADD
         MINMONTHSINCE=VALUE(SEGMENT(LFLINE,4,LENGTH(LFLINE)))
        END
[ Sub Source Code for Fee]
       IF SEGMENT(LFLINE,1,3)="SS:" THEN
        DO
         BNODEBUGMSG="    "+LFLINE
         CALL BNODEBUGMSGADD
         SUBSOURCECODE=VALUE(SEGMENT(LFLINE,4,LENGTH(LFLINE)))
        END
[ OTHERACTION for Fee]
       IF SEGMENT(LFLINE,1,3)="OA:" THEN
        DO
         BNODEBUGMSG="    "+LFLINE
         CALL BNODEBUGMSGADD
         OTHERACTION=VALUE(SEGMENT(LFLINE,4,LENGTH(LFLINE)))
        END
[ Transaction comment for Fee]
       IF SEGMENT(LFLINE,1,3)="FC:" THEN
        DO
         BNODEBUGMSG="    "+LFLINE
         CALL BNODEBUGMSGADD
         FEECOMMENT=SEGMENT(LFLINE,4,LENGTH(LFLINE))
        END
[********** Added 01/21/22 - TEK **********]

[ Eligible payment frequencies]
       IF SEGMENT(LFLINE,1,4)="EPF:" THEN
        DO
         TEXT1=SEGMENT(LFLINE,5,LENGTH(LFLINE))
         CALL TEXTNLTS
         TMPCHR=TEXT1
         IF TMPCHR="" THEN
          TMPCHR="ALL"
         BNODEBUGMSG="    "+LFLINE+"  EPF LELSIT:"+TMPCHR
         CALL BNODEBUGMSGADD

         LELISTINPUT=TMPCHR
         CALL LISTEXPAND
         FOR BNOLOCALLOOP=1 TO 13
          DO
           ELEGIBLEFREQUENCIES(BNOLOCALLOOP)=LELIST(BNOLOCALLOOP)
          END
        END

[ Due Date Calculations]
       IF SEGMENT(LFLINE,1,3)="DDA" THEN
        DO
         BNODEBUGMSG="    "+LFLINE
         CALL BNODEBUGMSGADD
         TMPPOS=CHARACTERSEARCH(LFLINE,":")
         IF TMPPOS>4 THEN
          DO
           TMPVAL=VALUE(SEGMENT(LFLINE,1,TMPPOS-1))
           TEXT1=UPPERCASE(SEGMENT(LFLINE,TMPPOS+1,LENGTH(LFLINE)))
           CALL TEXTNLTS
           IF ((TMPVAL>=1 AND TMPVAL<10) OR
               (TMPVAL>=11 AND TMPVAL<=13)) AND
               (TEXT1="M" OR TEXT1="F") THEN
            DO
             DUEDATECALCTYPE(TMPVAL)=TEXT1
            END
          END
        END
[ Minimum Payment Count]
       IF SEGMENT(LFLINE,1,4)="MPC:" THEN
        DO
         BNODEBUGMSG="    "+LFLINE
         CALL BNODEBUGMSGADD
         MINIMUMPAYMENTCOUNT=VALUE(SEGMENT(LFLINE,5,LENGTH(LFLINE)))
         IF MINIMUMPAYMENTCOUNT<0 THEN
          MINIMUMPAYMENTCOUNT=0
        END
[ Approval Code Exclusion]
       IF SEGMENT(LFLINE,1,4)="ACE:" THEN
        DO
         BNODEBUGMSG="    "+LFLINE
         CALL BNODEBUGMSGADD
         TMPCHR=SEGMENT(LFLINE,5,LENGTH(LFLINE))
         IF TMPCHR="" THEN
          TMPCHR="NONE"
         LELISTINPUT=TMPCHR
         CALL LISTEXPAND
         FOR BNOLOCALLOOP=1 TO 9999
          DO
           APPROVALCODESEXCLUDED(BNOLOCALLOOP)=LELIST(BNOLOCALLOOP)
          END
        END
[Maximum number of late payments]
       IF SEGMENT(LFLINE,1,4)="DQA:" THEN
        DO
         BNODEBUGMSG="    "+LFLINE
         CALL BNODEBUGMSGADD
         CUTOFFDQA=VALUE(SEGMENT(LFLINE,5,LENGTH(LFLINE)))
        END
       IF SEGMENT(LFLINE,1,4)="DQB:" THEN
        DO
         BNODEBUGMSG="    "+LFLINE
         CALL BNODEBUGMSGADD
         CUTOFFDQB=VALUE(SEGMENT(LFLINE,5,LENGTH(LFLINE)))
        END
       IF SEGMENT(LFLINE,1,4)="DQC:" THEN
        DO
         BNODEBUGMSG="    "+LFLINE
         CALL BNODEBUGMSGADD
         CUTOFFDQC=VALUE(SEGMENT(LFLINE,5,LENGTH(LFLINE)))
        END
       IF SEGMENT(LFLINE,1,4)="DQD:" THEN
        DO
         BNODEBUGMSG="    "+LFLINE
         CALL BNODEBUGMSGADD
         CUTOFFDQD=VALUE(SEGMENT(LFLINE,5,LENGTH(LFLINE)))
        END
       IF SEGMENT(LFLINE,1,4)="DQE:" THEN
        DO
         BNODEBUGMSG="    "+LFLINE
         CALL BNODEBUGMSGADD
         CUTOFFDQE=VALUE(SEGMENT(LFLINE,5,LENGTH(LFLINE)))
        END

[check for honoring of the skip first / skip last criteria ]
       IF SEGMENT(LFLINE,1,5)="SFLE:" THEN
        DO
         BNODEBUGMSG="    "+LFLINE
         CALL BNODEBUGMSGADD
         TEXT1=UPPERCASE(SEGMENT(LFLINE,6,LENGTH(LFLINE)))
         CALL TEXTNLTS
         IF UPPERCASE(TEXT1)="TRUE" THEN
          HONORSKIPS=TRUE
         BNODEBUGMSG="    SFLE="+TRUEFALSECHR(HONORSKIPS)
         CALL BNODEBUGMSGADD
        END

[grab test account list]
       IF SEGMENT(LFLINE,1,4)="TNC:" THEN
        DO
         BNODEBUGMSG="    "+LFLINE
         CALL BNODEBUGMSGADD
         TEXT1=UPPERCASE(SEGMENT(LFLINE,5,LENGTH(LFLINE)))
         CALL TEXTNLTS
         IF TEXT1="TRUE" THEN
          TESTMODE=TRUE
        END

[Check for test mode]
       IF SEGMENT(LFLINE,1,4)="TML:" THEN
        DO
         BNODEBUGMSG="    "+LFLINE
         CALL BNODEBUGMSGADD
         TEXT1=SEGMENT(LFLINE,5,LENGTH(LFLINE))
         CALL TEXTNLTS
         IF LENGTH(TEXT1)>=10 THEN
          TESTACCOUNTLIST=TEXT1
         IF TESTACCOUNTLIST<>"" THEN
          IF CHARACTERSEARCH(TESTACCOUNTLIST,ACCOUNT:NUMBER)>0 THEN
           VALIDTESTACCOUNT=TRUE
        END
      END
    END [WHILE LFERROR=""]
  END

[ validate test mode state]
 IF TESTMODE=TRUE AND
    LENGTH(TESTACCOUNTLIST)<10 THEN
  TESTMODE=FALSE

[ Determine which fee to use]
 IF ACCOUNT:RELATIONSHIPOVERRIDE>0 AND
   (ACCOUNT:RELATIONSHIPOVERRIDEEFFDATE=DATENULL OR
    ACCOUNT:RELATIONSHIPOVERRIDEEFFDATE<=SYSTEMDATE) AND
   (ACCOUNT:RELATIONSHIPOVERRIDEEXPDATE=DATENULL OR
    ACCOUNT:RELATIONSHIPOVERRIDEEXPDATE>SYSTEMDATE) THEN [Rel Code Override]
  FEEAMOUNT=FEEAMOUNTS(ACCOUNT:RELATIONSHIPOVERRIDE)
 ELSE IF ACCOUNT:RELATIONSHIPCODE>0 THEN [Relationship Code]
  FEEAMOUNT=FEEAMOUNTS(ACCOUNT:RELATIONSHIPCODE)
 ELSE [Base fee]
  FEEAMOUNT=FEEAMOUNTS(0)

 IF FEEAMOUNT=0 THEN
  FEEAMOUNT=FEEAMOUNTS(0)

[ Check if time period is valid, and parse start and end dates ]
 IF TIMEPERIOD<>"" AND LENGTH(TIMEPERIOD)=21 THEN
  DO
   STARTDATE=DATE(VALUE(SEGMENT(TIMEPERIOD,1,2)),
                  VALUE(SEGMENT(TIMEPERIOD,4,5)),
                  VALUE(SEGMENT(TIMEPERIOD,7,10)))
   ENDDATE=DATE(VALUE(SEGMENT(TIMEPERIOD,12,13)),
                VALUE(SEGMENT(TIMEPERIOD,15,16)),
                VALUE(SEGMENT(TIMEPERIOD,18,21)))
  END
END [PROCEDURE]

PROCEDURE GETLOANDATA

 TOTALLOANS=0
 ELIGIBLELOANS=0
 FOR EACH LOAN WITH (LOAN:CLOSEDATE=DATENULL AND
                     LOAN:CHARGEOFFDATE=DATENULL AND
                     LOAN:BALANCE>$0.00)
  DO
   TOTALLOANS=TOTALLOANS+1
   FOR I=0 TO INELIGIBLEREASONSMAX
    DO
     LOANINELIGIBLECODE(TOTALLOANS,I)=FALSE
    END

   LOANID(TOTALLOANS)=LOAN:ID
   IF LOANTYPES(LOAN:TYPE)=FALSE THEN
    LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODELOANTYPE)=TRUE
   FOR WARNINGLOOP=1 TO WARNINGSMAX
    DO
     IF ANYWARNING(ACCOUNT,WARNINGLOOP) AND
        ACCTWARNINGS(WARNINGLOOP)=TRUE THEN
      LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODEACCTWARNING)=TRUE
     IF ANYWARNING(LOAN,WARNINGLOOP) AND
        LOANWARNINGS(WARNINGLOOP)=TRUE THEN
      LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODELOANWARNING)=TRUE
    END

   SERVICEFOUND=FALSE
   FOR SERVICELOOP=1 TO SERVICECODEMAX
    DO
     IF ANYSERVICE(LOAN,SERVICELOOP) AND
        LOANSERVICECODE(SERVICELOOP)=TRUE THEN
      SERVICEFOUND=TRUE
    END

[ If none are found, check to see if any are defined]
   IF SERVICEFOUND=FALSE THEN
    DO
     [default to none found]
     SERVICEFOUND=TRUE
     FOR I=0 TO SERVICECODEMAX
      DO
[ One found, loan ineligible]
       IF LOANSERVICECODE(I)=TRUE THEN
        SERVICEFOUND=FALSE
      END
    END
[ If none found, and some are defined]
   IF SERVICEFOUND=FALSE THEN
    LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODESERVICECODE)=TRUE

[ Payment amount]
   IF LOANMINPAYMENT>$0.00 AND LOAN:PAYMENT<LOANMINPAYMENT THEN
    LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODEMINPAYMENT)=TRUE
   IF LOANMAXPAYMENT>$0.00 AND LOAN:PAYMENT>LOANMAXPAYMENT THEN
    LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODEMAXPAYMENT)=TRUE
[ Loan season]
   IF LOANSEASON>0 AND
      SYSTEMDATE<DATEOFFSET(LOAN:OPENDATE,LOANSEASON,0) THEN
    LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODETIMEOPEN)=TRUE
[ Grace period]
   IF LOAN:DUEDATE+GRACEDAYS<SYSTEMDATE THEN
    LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODEPASTDUE)=TRUE
[ Skips]
   SKIPCOUNT=0
   FOR EACH LOAN TRACKING WITH (LOAN TRACKING:TYPE=LOANTRACKINGTYPE AND
                                LOAN TRACKING:USERDATE1>=
                                DATEOFFSET(SYSTEMDATE,-12,0))
    DO
     SKIPCOUNT=SKIPCOUNT+1
    END
   UNTIL SKIPCOUNT=MAXSKIPS
[ Too many skips in last year]
   IF SKIPCOUNT>=MAXSKIPS THEN
    LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODEMAXSKIPS)=TRUE

   SKIPCOUNT=0
   FOR EACH LOAN TRACKING WITH (
                     LOAN TRACKING:TYPE=LOANTRACKINGTYPE AND
                     LOAN TRACKING:USERDATE2>=
                     DATEOFFSET(LOAN:DUEDATE,-MINMONTHSINCE,0))
    DO
     SKIPCOUNT=SKIPCOUNT+1
    END
   UNTIL SKIPCOUNT=1
[ Too soon since last skip]
   IF SKIPCOUNT>0 THEN
    LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODETIMESKIP)=TRUE


[* 01/21/22 *]

[* only evaluate the following settings if in test mode and the account is
** a test account or if running for everyone
*]
   IF TESTMODE=FALSE OR
     (TESTMODE=TRUE AND
      VALIDTESTACCOUNT=TRUE) THEN
    DO

[* Eligible Payment Frequencies *]
     IF ELEGIBLEFREQUENCIES(LOAN:PAYMENTFREQUENCY)=FALSE THEN
      LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODEFREQ)=TRUE

[* Minimum Payment Count *]
     IF MINIMUMPAYMENTCOUNT>0 AND
        LOAN:PAYMENTHISTORY:1<MINIMUMPAYMENTCOUNT THEN
      LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODEMINPMTCOUNT)=TRUE

[* Approval Code Exclusion *]
     IF APPROVALCODESEXCLUDED(LOAN:APPROVALCODE)=TRUE THEN
      LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODEAPPROVALCODE)=TRUE

[* Maximum number of late payments *]
     IF ((CUTOFFDQA>0 AND
         LOAN:PAYMENTHISTORY:2>=CUTOFFDQA) OR
         (CUTOFFDQB>0 AND
         LOAN:PAYMENTHISTORY:3>=CUTOFFDQB) OR
         (CUTOFFDQC>0 AND
         LOAN:PAYMENTHISTORY:4>=CUTOFFDQC) OR
         (CUTOFFDQD>0 AND
         LOAN:PAYMENTHISTORY:5>=CUTOFFDQD) OR
         (CUTOFFDQE>0 AND
         LOAN:PAYMENTHISTORY:6>=CUTOFFDQE)) THEN
      LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODEDQPAYMENTS)=TRUE
    END [IF TESTMODE=FALSE OR ...]

[ If any codes are set, loan is ineligible]
   FOR I=1 TO INELIGIBLEREASONSMAX
    DO
     IF LOANINELIGIBLECODE(TOTALLOANS,I)=TRUE THEN
      LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODESET)=TRUE
    END
[ Increment eligible loans]
   IF LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODESET)=FALSE THEN
    ELIGIBLELOANS=ELIGIBLELOANS+1
  END
 UNTIL TOTALLOANS=LOANSMAX  [FOR EACH LOAN]
END [PROCEDURE]

PROCEDURE GETSKIPCRITERIA

 LDUEDATE=DATENULL
 LNEWDUEDATE=DATENULL
 LPAYMENT=$0.00
 LMATURITYDATE=DATENULL
 LNEWMATURITYDATE=DATENULL
 LDESCRIPTION=""

 FOR EACH LOAN WITH LOAN:ID=LID
  DO
   LDUEDATE=LOAN:DUEDATE
   LPAYMENT=LOAN:PAYMENT
   LMATURITYDATE=LOAN:MATURITYDATE
   TMPCHR=LOAN:DESCRIPTION
   CALL CLEANUPTEXT

   LDESCRIPTION=TMPCHR

   IF DUEDATECALCTYPE(LOAN:PAYMENTFREQUENCY)="F" AND
      TESTMODE=FALSE OR
     (TESTMODE=TRUE AND
      VALIDTESTACCOUNT=TRUE) THEN
    DO
     BNODEBUGMSG="Evaluating LOAN "+LID+" by frequency  - "+FORMAT("Freq=99",LOAN:PAYMENTFREQUENCY)

[* new due dates and maturity dates in this section are calculated based upon
** the loan's payment frequency
*]
     IF LOAN:PAYMENTFREQUENCY=1 THEN [annual]
      DO
[* advance the due date and maturity date by 1 year
*]
       LNEWDUEDATE=DATEOFFSET(LDUEDATE,12,LOAN:DUEDAY1)
       IF LMATURITYDATE<>DATENULL THEN
        LNEWMATURITYDATE=DATEOFFSET(LMATURITYDATE,12,LOAN:DUEDAY1)
      END

     ELSE IF LOAN:PAYMENTFREQUENCY=2 THEN [semiannual]
      DO
[* advance the due date and matuurity date by 6 months
*]
       LNEWDUEDATE=DATEOFFSET(LDUEDATE,6,LOAN:DUEDAY1)
       IF LMATURITYDATE<>DATENULL THEN
        LNEWMATURITYDATE=DATEOFFSET(LMATURITYDATE,6,LOAN:DUEDAY1)
      END

     ELSE IF LOAN:PAYMENTFREQUENCY=3 THEN [quarterly]
      DO
[* advance the due date and maturity date by 3 months
*]
       LNEWDUEDATE=DATEOFFSET(LDUEDATE,3,LOAN:DUEDAY1)
       IF LMATURITYDATE<>DATENULL THEN
        LNEWMATURITYDATE=DATEOFFSET(LMATURITYDATE,3,LOAN:DUEDAY1)
      END

     ELSE IF LOAN:PAYMENTFREQUENCY=4 THEN [monthly]
      DO
[* advance the due date and matuurity date by 1 month
*]
       LNEWDUEDATE=DATEOFFSET(LDUEDATE,1,LOAN:DUEDAY1)
       IF LMATURITYDATE<>DATENULL THEN
        LNEWMATURITYDATE=DATEOFFSET(LMATURITYDATE,1,LOAN:DUEDAY1)
      END

     ELSE IF LOAN:PAYMENTFREQUENCY=5 THEN [semimonthly]
      DO
[* if the current due date matches the loan's dueday1 value then advance to the
** dueday2 value of the same month. If the current due date matches the loan's
** dueday2 value then advance to the dueday1 value of the next month. Same
** logic goes for the new maturity date.
*]
       IF DAY(LDUEDATE)=LOAN:DUEDAY1 THEN
        LNEWDUEDATE=DATEOFFSET(LDUEDATE,0,LOAN:DUEDAY2)
       ELSE
        LNEWDUEDATE=DATEOFFSET(LDUEDATE,1,LOAN:DUEDAY1)

       IF LMATURITYDATE<>DATENULL THEN
        DO
         IF DAY(LMATURITYDATE)=LOAN:DUEDAY1 THEN
          LNEWMATURITYDATE=DATEOFFSET(LMATURITYDATE,0,LOAN:DUEDAY2)
         ELSE
          LNEWMATURITYDATE=DATEOFFSET(LMATURITYDATE,1,LOAN:DUEDAY1)
        END
      END
     ELSE IF LOAN:PAYMENTFREQUENCY=6 THEN [biweekly, skip first]
      DO
[* advance the due date by 1 payment(14 days). Get the month of the new payment. If the month of
** the new payment is the same as the month of the new payment plus 2 payments (28 days) then
** there are three payments in the month and advance the new due date by another 14 days (skipping
** what would have been the first of three payments in the month)
*]
       LNEWDUEDATE=LDUEDATE+14
       LNEWDUEMONTH=MONTH(LNEWDUEDATE)
       IF MONTH(LNEWDUEDATE+28)=LNEWDUEMONTH THEN
        DO
         LNEWDUEDATE=LNEWDUEDATE+14
        END
[* advance the maturity date by the same number of days the due date was advanced
*]
       IF LMATURITYDATE<>DATENULL THEN
        LNEWMATURITYDATE=LMATURITYDATE+(LNEWDUEDATE-LDUEDATE)
      END
     ELSE IF LOAN:PAYMENTFREQUENCY=7 THEN [biweekly, skip last]
      DO
[* advance the due date by 1 payment(14 days). Get the month of the new payment. If the month of
** the new payment is the same as the month of the new payment minus 2 payments (28 days) then
** there are three payments in the month and advance the new due date by another 14 days (skipping
** what would have been the third payment)
*]
       LNEWDUEDATE=LDUEDATE+14
       LNEWDUEMONTH=MONTH(LNEWDUEDATE)
       IF MONTH(LNEWDUEDATE-28)=LNEWDUEMONTH THEN
        DO
         LNEWDUEDATE=LNEWDUEDATE+14
        END
[* advance the maturity date by the same number of days the due date was advanced
*]
       IF LMATURITYDATE<>DATENULL THEN
        LNEWMATURITYDATE=LMATURITYDATE+(LNEWDUEDATE-LDUEDATE)
      END
     ELSE IF LOAN:PAYMENTFREQUENCY=8 THEN [biweekly]
      DO
[* advance the due date and maturity date by 1 payment(14 days).
*]
       LNEWDUEDATE=LDUEDATE+14
       IF LMATURITYDATE<>DATENULL THEN
        LNEWMATURITYDATE=LMATURITYDATE+14
      END
     ELSE IF LOAN:PAYMENTFREQUENCY=9 THEN [WEEKLY]
      DO
[* advance the due date and maturity date by 1 payment(7 days).
*]
       LNEWDUEDATE=LDUEDATE+7
       IF LMATURITYDATE<>DATENULL THEN
        LNEWMATURITYDATE=LMATURITYDATE+7
      END
     ELSE IF LOAN:PAYMENTFREQUENCY=11 THEN [weekly, skip first]
      DO
[* advance the due date by 1 payment(7 days). Get the month of the new payment. If the month of
** the new payment is the same as the month of the new payment PLUS 4 payments (28 days) then
** there are five payments in the month and advance the new due date by another 7 days (skipping
** what would have been the first of five payments for the month)
*]
       LNEWDUEDATE=LDUEDATE+7
       LNEWDUEMONTH=MONTH(LNEWDUEDATE)
       IF MONTH(LNEWDUEDATE+28)=LNEWDUEMONTH THEN
        DO
         LNEWDUEDATE=LNEWDUEDATE+7
        END
[* advance the maturity date by the same number of days the due date was advanced
*]
       IF LMATURITYDATE<>DATENULL THEN
        LNEWMATURITYDATE=LMATURITYDATE+(LNEWDUEDATE-LDUEDATE)
      END
     ELSE IF LOAN:PAYMENTFREQUENCY=12 THEN [weekly, skip last]
      DO
[* advance the due date by 1 payment(7 days). Get the month of the new payment. If the month of
** the new payment is the same as the month of the new payment MINUS 4 payments (28 days) then
** there are five payments in the month and advance the new due date by another 7 days (skipping
** what would have been the fifth of five payments for the month)
*]
       LNEWDUEDATE=LDUEDATE+7
       LNEWDUEMONTH=MONTH(LNEWDUEDATE)
       IF MONTH(LNEWDUEDATE-28)=LNEWDUEMONTH THEN
        DO
         LNEWDUEDATE=LNEWDUEDATE+7
        END
[* advance the maturity date by the same number of days the due date was advanced
*]
       IF LMATURITYDATE<>DATENULL THEN
        LNEWMATURITYDATE=LMATURITYDATE+(LNEWDUEDATE-LDUEDATE)
      END

     ELSE IF LOAN:PAYMENTFREQUENCY=13 THEN [bimonthly]
      DO
[* advance the due date and the loan maturity date by 2 months
*]
       LNEWDUEDATE=DATEOFFSET(LDUEDATE,2,LOAN:DUEDAY1)
       IF LMATURITYDATE<>DATENULL THEN
        LNEWMATURITYDATE=DATEOFFSET(LMATURITYDATE,2,LOAN:DUEDAY1)
      END
     BNODEBUGMSG=BNODEBUGMSG+FORMAT("  OLD DUE:99/99/99",LDUEDATE)+
                             FORMAT("  NEW DUE:99/99/99",LNEWDUEDATE)+
                             FORMAT("  OLD MAT:99/99/99",LMATURITYDATE)+
                             FORMAT("  NEW MAT:99/99/99",LNEWMATURITYDATE)
     CALL  BNODEBUGMSGADD
    END
   ELSE [Next due date cals is 1 month / 28 days]
    DO
[* new due dates and maturity dates in this section are calculated at 28 days
** for weekly/biweekly loan types of 1 month for all others
*]
     IF CHARACTERSEARCH("06,07,08,09,11,12",FORMAT("99",LOAN:PAYMENTFREQUENCY))>0 THEN
      DO
       LNEWDUEDATE=LDUEDATE+28

       IF LMATURITYDATE<>DATENULL THEN
        LNEWMATURITYDATE=LMATURITYDATE+28


[* TEK-01/27 Adding check for skip first, skip last for freqs. 6,7,11,12 and adjusting due date
** by one payment cycle (plus 2 weeks for freqs. 6 or 7, plus 1 week for freqs. 11 or 12 IF
** the new payment due falls into the skip first/skip last scenario. Maturity date will also be
** adjusted accordingly
*]
       IF HONORSKIPS=TRUE THEN
        DO
         IF LOAN:PAYMENTFREQUENCY=6 THEN [Biweekly, skip first]
          DO
           LNEWDUEMONTH=MONTH(LNEWDUEDATE)
           IF MONTH(LNEWDUEDATE+28)=LNEWDUEMONTH THEN
            DO
             LNEWDUEDATE=LNEWDUEDATE+14
             IF LMATURITYDATE<>DATENULL THEN
              LNEWMATURITYDATE=LNEWMATURITYDATE+14
            END
          END
         ELSE IF LOAN:PAYMENTFREQUENCY=7 THEN [Biweekly, skip last]
          DO
           LNEWDUEMONTH=MONTH(LNEWDUEDATE)
           IF MONTH(LNEWDUEDATE-28)=LNEWDUEMONTH THEN
            DO
             LNEWDUEDATE=LNEWDUEDATE+14
             IF LMATURITYDATE<>DATENULL THEN
              LNEWMATURITYDATE=LNEWMATURITYDATE+14
            END
          END
         ELSE IF LOAN:PAYMENTFREQUENCY=11 THEN [Weekly, skip first]
          DO
           LNEWDUEMONTH=MONTH(LNEWDUEDATE)
           IF MONTH(LNEWDUEDATE+28)=LNEWDUEMONTH THEN
            DO
             LNEWDUEDATE=LNEWDUEDATE+7
             IF LMATURITYDATE<>DATENULL THEN
              LNEWMATURITYDATE=LNEWMATURITYDATE+7
            END
          END
         ELSE IF LOAN:PAYMENTFREQUENCY=12 THEN [Weekly, skip last]
          DO
           LNEWDUEMONTH=MONTH(LNEWDUEDATE)
           IF MONTH(LNEWDUEDATE-28)=LNEWDUEMONTH THEN
            DO
             LNEWDUEDATE=LNEWDUEDATE+7
             IF LMATURITYDATE<>DATENULL THEN
              LNEWMATURITYDATE=LNEWMATURITYDATE+7
            END
          END
        END [IF HONORSKIPS=TRUE]
       BNODEBUGMSG="Evaluating LOAN "+LID+" by 28 day - "+FORMAT("Freq=99",LOAN:PAYMENTFREQUENCY)+
                    FORMAT("  OLD DUE:99/99/99",LDUEDATE)+
                    FORMAT("  NEW DUE:99/99/99",LNEWDUEDATE)+
                    FORMAT("  OLD MAT:99/99/99",LMATURITYDATE)+
                    FORMAT("  NEW MAT:99/99/99",LNEWMATURITYDATE)
       CALL  BNODEBUGMSGADD
      END
     ELSE
      DO
       IF LOAN:PAYMENTFREQUENCY=5 THEN
        DO
         IF DAY(LDUEDATE)>LOAN:DUEDAY1 THEN
          LNEWDUEDATE=DATEOFFSET(LOAN:DUEDATE,1,LOAN:DUEDAY2)
         ELSE
          LNEWDUEDATE=DATEOFFSET(LOAN:DUEDATE,1,LOAN:DUEDAY1)
        END
       ELSE
        LNEWDUEDATE=DATEOFFSET(LDUEDATE,1,LOAN:DUEDAY1)

       IF LMATURITYDATE<>DATENULL THEN
        DO
         IF LOAN:PAYMENTFREQUENCY=5 THEN
          DO
           IF DAY(LMATURITYDATE)>LOAN:DUEDAY1 THEN
            LNEWMATURITYDATE=DATEOFFSET(LMATURITYDATE,1,LOAN:DUEDAY2)
           ELSE
            LNEWMATURITYDATE=DATEOFFSET(LMATURITYDATE,1,LOAN:DUEDAY1)
          END
         ELSE
          LNEWMATURITYDATE=DATEOFFSET(LMATURITYDATE,1,LOAN:DUEDAY1)
        END
       BNODEBUGMSG="Evaluating LOAN "+LID+" by std month - "+FORMAT("Freq=99",LOAN:PAYMENTFREQUENCY)+
                   FORMAT("  OLD DUE:99/99/99",LDUEDATE)+
                   FORMAT("  NEW DUE:99/99/99",LNEWDUEDATE)+
                   FORMAT("  OLD MAT:99/99/99",LMATURITYDATE)+
                   FORMAT("  NEW MAT:99/99/99",LNEWMATURITYDATE)
       CALL  BNODEBUGMSGADD
      END
    END
  END
END [PROCEDURE]

[
  This procedure extracts the next LID from the LIDLIST. The
  LIDLIST will be modified not to include the loan ID.

  PASS:   LIDLIST

  RETURN: LIDLIST
          LID
]
PROCEDURE GETNEXTLID

 COMMAPOS=CHARACTERSEARCH(LIDLIST,",")
 IF COMMAPOS>0 THEN
  DO
   LID=SEGMENT(LIDLIST,1,COMMAPOS-1)
   LIDLIST=SEGMENT(LIDLIST,COMMAPOS+1,LENGTH(LIDLIST))
  END
 ELSE
  DO
   LID=LIDLIST
   LIDLIST=""
  END

 TEXT1=LID
 CALL TEXTNLS
 LID=TEXT1
END [PROCEDURE]

[
 Remove leading spaces from a text string.

 PASS:   TEXT1     The string to trim
 RETURN: TEXT1     The trimmed string
]
PROCEDURE TEXTNLS

 TT=1
 TEXTFOUND=FALSE
 WHILE (TT<=LENGTH(TEXT1) AND TEXTFOUND=FALSE)
  DO
   IF SEGMENT(TEXT1,TT,TT)<>" " THEN
    TEXTFOUND=TRUE
   ELSE
    TT=TT+1
  END
 IF TT>1 THEN
  TEXT1=SEGMENT(TEXT1,TT,LENGTH(TEXT1))
END [PROCEDURE]

[
 Remove trailing spaces from a text string.

 PASS:   TEXT1     The string to trim
 RETURN: TEXT1     The trimmed string
]
PROCEDURE TEXTNTS

 TT=LENGTH(TEXT1)
 TEXTFOUND=FALSE
 WHILE (TT>0 AND TEXTFOUND=FALSE)
  DO
   IF SEGMENT(TEXT1,TT,TT)<>" " THEN
    TEXTFOUND=TRUE
   ELSE
    TT=TT-1
  END
 TEXT1=SEGMENT(TEXT1,1,TT)
END [PROCEDURE]

[
 Remove leading and trailing spaces from a text string.

 PASS:   TEXT1     The string to trim
 RETURN: TEXT1     The trimmed string
]
PROCEDURE TEXTNLTS
 CALL TEXTNLS
 CALL TEXTNTS
END [PROCEDURE]

PROCEDURE CLEANUPTEXT
[* 04/16/20
** Check character string and remove out any characters or hidden
** characters which have an ASCII value which is not established in
** the VALIDCHRINPUT1 string in the SETUP division . This is to avoid
** display issues with displaying the terms or conditions. Additionally,
** if a back-slash or double quote is encountered, add a preceding
** backslash
**  PASS       TMPCHR   String to test
**  RETURN     TMPCHR   Updated string
*]
 LELISTINPUT=VALIDCHRINPUT1
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO MAXCHRVALUE
  DO
   VALIDCHARS(TMPLOOP)=LELIST(TMPLOOP)
  END
 TMPTEXT=""

 IF TMPCHR<>"" THEN
  DO
   FOR TMPTEXTLOOP=1 TO LENGTH(TMPCHR)
    DO
     CHRVAL=CHRVALUE(SEGMENT(TMPCHR,TMPTEXTLOOP,TMPTEXTLOOP))
     IF  VALIDCHARS(CHRVAL)=TRUE THEN
      DO
[* Check for back-slash or double-quote. If found, precede with a back-slash
*]
       IF (CHRVAL=92 OR CHRVAL=34) THEN
        TMPTEXT=TMPTEXT+"\"+SEGMENT(TMPCHR,TMPTEXTLOOP,TMPTEXTLOOP)
       ELSE
        TMPTEXT=TMPTEXT+SEGMENT(TMPCHR,TMPTEXTLOOP,TMPTEXTLOOP)
      END
    END
  END
 TMPCHR=TMPTEXT
END [PROCEDURE]

PROCEDURE BNOPRINTPROGRAMINFO
[* Print program info to direct JSON output
**
**  PASS    BNOPROGRAMNAME     Program name
**  PASS    BNOPROGRAMVERSION  Program version
**  PASS    BNOLASTMODDATE     Last mod date
**  PASS    BNOLASTMODTIME     Last mod time
*]
 PRINT BNOINDENT(1)+","
 NEWLINE
 PRINT BNOINDENT(1)+Q+"programInfo"+Q+":"+Q+
                    BNOPROGRAMNAME+"  "+
                    BNOPROGRAMVERSION+"  "+
                    FORMAT("99/99/99 ",BNOLASTMODDATE)+"  "+
                    "TESTMODE:"+TRUEFALSECHR(TESTMODE)+"  "+
                    "TESTACCT:"+TRUEFALSECHR(VALIDTESTACCOUNT)+Q
END [PROCEDURE]

PROCEDURE BNOPRINTRGDATA
[* Print @RGUSER[CHR,NUM] data passed from the UX in proper JSON format
**
**  PASS    DEBUGMODE        Boolean: Print debug data, T/F
*]

 IF BNODEBUGMODE=BNODEBUGMODEON THEN
  DO

   PRINT ","
   NEWLINE
   PRINT BNOINDENT(1)+Q+"rgData"+Q+": ["
   NEWLINE
   PRINT BNOINDENT(2)+Q+"CHR1:'"+@RGUSERCHR1+"' "+
                     "CHR2:'"+@RGUSERCHR2+"'"+Q+","
   NEWLINE
   PRINT BNOINDENT(2)+Q+"CHR3:'"+@RGUSERCHR3+"' "+
                     "CHR4:'"+@RGUSERCHR4+"'"+Q+","

   NEWLINE
   PRINT BNOINDENT(2)+Q+"CHR5:'"+@RGUSERCHR5+"' "+
                     "NUM1:"+FORMAT("#########9 ",@RGUSERNUM1)+
                     "NUM2:"+FORMAT("#########9 ",@RGUSERNUM2)+
                     "NUM3:"+FORMAT("#########9 ",@RGUSERNUM3)+
                     "NUM4:"+FORMAT("#########9 ",@RGUSERNUM4)+
                     "NUM5:"+FORMAT("#########9",@RGUSERNUM5)+Q
   NEWLINE
   PRINT BNOINDENT(1)+"]"
   NEWLINE
  END
END [PROCEDURE]

PROCEDURE BNODEBUGMSGADD
[* Add a message line to the debug message array
**
** PASS    BNODEBUGMSGMAX     Current array index max lines allowed
** PASS    BNODEBUGMSG        Debug message to add to array
**
** RETURN  BNODEBUGCOUNT      Count of debug message lines
** RETURN  BNODEBUGMSGLIST(A) Debug lines of data to print
*]
 IF BNODEBUGCOUNT<BNODEBUGMSGMAX THEN
  DO
   BNODEBUGCOUNT=BNODEBUGCOUNT+1
   BNODEBUGMSGLIST(BNODEBUGCOUNT)=BNODEBUGMSG
   BNODEBUGMSG=""
  END
END [PROCEDURE]

PROCEDURE BNOPRINTDEBUG
[* Print debug output in proper JSON format. Requires DEBUGMODE to be
** on (or true).
**
**  PASS  DEBUGMODE           Boolean: Print debug data, T/F
**  PASS  BNODEBUGMSGLIST(A)  Array of debug messages to print
**  PASS  BNODEBUGCOUNT       Number of debug lines to print
*]
 IF BNODEBUGMODE=BNODEBUGMODEON THEN
  DO
   PRINT ","
   NEWLINE
   PRINT BNOINDENT(2)+Q+"debugData"+Q+": ["
   NEWLINE
   PRINT BNOINDENT(2)+Q+"Debug note: Debug lines truncated to 126 characters"+Q

   FOR BNODEBUGLOOP=1 TO BNODEBUGCOUNT
    DO
     IF BNODEBUGLOOP=1 THEN
      DO
       IF BNODEBUGLOOP<BNODEBUGCOUNT THEN
        DO
         PRINT ","
         NEWLINE
        END
      END
     PRINT BNOINDENT(3)+Q+Segment(BNODEBUGMSGLIST(BNODEBUGLOOP),1,126)+Q
     IF BNODEBUGLOOP<BNODEBUGCOUNT THEN
      PRINT ","
     NEWLINE
    END

   PRINT BNOINDENT(2)+"]"
   NEWLINE
  END
END [PROCEDURE]

#INCLUDE "RB.LISTEXPAND"


