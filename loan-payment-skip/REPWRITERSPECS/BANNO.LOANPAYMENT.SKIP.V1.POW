[*  Copyright 2019-2024 Jack Henry
**
**  PowerOn Name:                   BANNO.LOANPAYMENT.SKIP.V1.POW
**  Configuration Letterfile Name:  BANNO.LOANPAYMENT.SKIP.CFG
**
**  Program Summary
**  --------------------------------------------------------------------
**  This Banno service PowerOn allow the user to select one or more
**  eligible loans and, for a fee, have the loan due date advanced
**  by 28 days, 1 month or one payment cycle, depending upon the
**  parameter settings. Once the new due date has been calculated, the
**  loan maturity date will also be advanced accordingly.
**
**  Modification History
**  --------------------------------------------------------------------
**  Ver. 1.0.0  Original Programming
**  Ver. 1.0.1  03/24/2020: fixes for no fee and skip period
**  Ver. 1.0.2  04/16/2020: fixes for invalid punctuation in share
**              descriptions
**  Ver. 1.0.3  06/16/2020: Correct new due date and maturity date to
**              insure it falls on the correct day of the week.
**  Ver. 1.0.4  10/28/2021: Correct processing of disclosure blank lines.
**              Added forced space between consecutive lines of text
**  Ver. 1.0.5  11/30/2021: TKainz - Banno
**              Changed max DQ grace days from 30 to unlimited
**  Ver. 1.1.0  02/14/2022: TKainz - Banno
**              Added parameter to allow loan eligibility to also be based
**               upon loan payment frequencies.
**              Added parameter to allow CU to keep new payment due date
**               calc. as it currently operates (28 days/1 month) or allow
**               the new due date calculation to be based upon the
**               actual payment frequency.
**              Added additional logic for skip first/skip last loan
**               frequencies even though they may be set for the "M"
**               (1 month/28 day) due date advance option.
**              Added parameter setting for min. number of payments
**               requirement (LOAN:PAYMENTHISTORY:1)
**              Added parameter for loan eligibility to be based upon loan
**               not having a certain approval code (LOAN:APPROVALCODE)
**              Added parameter to allow loan eligibility to be based upon
**               max number of DQ payment counts (LOAN:PAYMENTHISTORY:[2-6])
**              Added parameter allowing program to be run in test mode.
**               With test mode on, only accounts listed as a test account
**               will have these newest changes processed on the account
**               when the member runs the program.
**              Added JSON output of debug code, parameter file settings
**               and current program test mode and account's test status.
**  Ver. 1.1.1  03/04/2022: TKainz - Banno
**              Corrected Configuration Letterfile name
**  Ver. 1.1.2  01/12/2023: TKainz - Banno
**              Modified CFG Letter file read error handling
**              Corrected loan disqualification check loop
**              Corrected test mode pay freq logic
**              Reworked param LF read procedure
**              Other code cleanup
**  Ver. 1.1.3 11/06/2023: JuCarson - Banno
**             Corrected allowed share types for fee loop to include
**             setting type 0 in SHARETYPES array. 
**  Ver. 1.1.4 05/30/2024: JuCarson - Banno
**             Corrected issue with relationship level fee amounts
**             when a fee amount is set to $0.00. 
**
**  For more information check
**  https://github.com/Banno/banno-powerons
**
**  Banno is not responsible for any modifications to this file
**  made by unauthorized personnel.
**
**  DO NOT MODIFY THIS FILE UNLESS YOU KNOW WHAT YOU'RE DOING!
*]

SYMCONNECT
STATELESS

TARGET=ACCOUNT

DEFINE
 #INCLUDE "RB.LISTEXPAND.DEF"

 Q                   = CHARACTER
 I                   = NUMBER
 J                   = NUMBER
 TOTALLOANS          = NUMBER
 ELIGIBLELOANS       = NUMBER
 WARNINGLOOP         = NUMBER
 SERVICEFOUND        = NUMBER
 SERVICELOOP         = NUMBER
 LOANSEASON          = NUMBER
 GRACEDAYS           = NUMBER
 SKIPCOUNT           = NUMBER
 TEMPLOOP            = NUMBER
 TIMEPERIOD          = CHARACTER
 ERRORMSGUSER        = CHARACTER
 ERRORMSGLOG         = CHARACTER
 ERRORFLAG           = NUMBER
 TOTALFEE            = MONEY
 FEESUM              = MONEY
 COMMAPOS            = NUMBER
 TT                  = NUMBER
 TEXTFOUND           = NUMBER
 TEXT1               = CHARACTER

 LIDLIST             = CHARACTER
 LID                 = CHARACTER
 LDUEDATE            = DATE
 LNEWDUEDATE         = DATE
 LPAYMENT            = MONEY
 LMATURITYDATE       = DATE
 LNEWMATURITYDATE    = DATE
 LDESCRIPTION        = CHARACTER(40)
 LOANLOOP            = NUMBER
 LOANDISPLAYED       = NUMBER
 SHAREDISPLAYED      = NUMBER
 SHAREFOUND          = NUMBER
 INELIGIBLEDISPLAYED = NUMBER

 SEQ1                = NUMBER
 SEQ2                = NUMBER
 CAC                 = CHARACTER
 CN                  = CHARACTER
 TRANERROR           = CHARACTER
 FMERROR             = CHARACTER

 LFNUMBER            = NUMBER
 LFERROR             = CHARACTER
 LFLINE              = CHARACTER
 READCONFIGERROR     = NUMBER
 READCONFIGERRORMSG  = CHARACTER

 LOANID              = CHARACTER(4)  ARRAY(25)
 LOANINELIGIBLECODE  = NUMBER        ARRAY(25,14)
 LOANSMAX            = 25
 INELIGIBLEREASONS   = CHARACTER(60) ARRAY(14)
 INELIGIBLEREASONSMAX= 14

 LOANTYPES           = NUMBER        ARRAY(9999)
 SHARETYPES          = NUMBER        ARRAY(9999)
 TYPESMAX            = 9999

 LOANWARNINGS        = NUMBER        ARRAY(999)
 ACCTWARNINGS        = NUMBER        ARRAY(999)
 WARNINGSMAX         = 999

 LOANSERVICECODE     = NUMBER        ARRAY(99)
 SERVICECODEMAX      = 99

 FEEAMOUNTS          = MONEY         ARRAY(99) [0:DEFAULT,
                                                01-99:REL CODE]
 FEEAMOUNTSMAX       = 99
 FEEAMOUNTSET        = NUMBER

 TERMS               = CHARACTER ARRAY(40)
 TERMSMAXLINES       = 40
 TERMSLINESCOUNT     = NUMBER
 TERMSLASTLLINEUSED  = NUMBER

 GETPRELOADDATA      = "GETPRELOADDATA"
 PERFORMSKIPAPAYMENT = "PERFORMSKIPAPAYMENT"

 CONFIGFILENAME      = "BANNO.LOANPAYMENT.SKIP.CFG"

 TRUE                      = 1
 FALSE                     = 0
 DATENULL                  = '--/--/--'

 INELIGIBLECODESET         = 0  [loan ineligible flag]
 INELIGIBLECODELOANTYPE    = 1  [Incorrect loan type]
 INELIGIBLECODELOANWARNING = 2  [has loan warning]
 INELIGIBLECODEMAXSKIPS    = 3  [has used max skips already]
 INELIGIBLECODETIMESKIP    = 4  [not enough time between skips]
 INELIGIBLECODEACCTWARNING = 5  [has account warning]
 INELIGIBLECODESERVICECODE = 6  [does not have required svc code]
 INELIGIBLECODEMINPAYMENT  = 7  [min payment requirement not met]
 INELIGIBLECODEMAXPAYMENT  = 8  [max payment amount exceeded]
 INELIGIBLECODETIMEOPEN    = 9  [loan not opened for sufficient time]
 INELIGIBLECODEPASTDUE     = 10 [past due grace days exceeded]
 INELIGIBLECODEFREQ        = 11 [has ineligible payment freq]
 INELIGIBLECODEMINPMTCOUNT = 12 [minimum payment count not met]
 INELIGIBLECODEAPPROVALCODE= 13 [has invalid approval code]
 INELIGIBLECODEDQPAYMENTS  = 14 [has excessive DQ payment history]

 FEEAMOUNT                 = MONEY
 LOANTRACKINGTYPE          = NUMBER
 MAXSKIPS                  = NUMBER
 MINMONTHSINCE             = NUMBER
 SUBSOURCECODE             = NUMBER
 OTHERACTION               = NUMBER
 FEECOMMENT                = CHARACTER
 LOANMINPAYMENT            = MONEY
 LOANMAXPAYMENT            = MONEY
 STARTDATE                 = DATE
 ENDDATE                   = DATE

 DEFAULTFEEAMOUNT          = $35.00
 DEFAULTLOANTRACKINGTYPE   = 77
 DEFAULTMAXSKIPS           = 2
 DEFAULTMINMONTHSINCE      = 2
 DEFAULTSUBSOURCECODE      = 33 [Skip Payment Fee]
 DEFAULTOTHERACTION        = 0  [Use "FEE OTHER" OTHERACTION with Fee]
 DEFAULTFEECOMMENT         = ""
 DEFAULTLOANMINPAYMENT     = $0.00
 DEFAULTLOANMAXPAYMENT     = $0.00

 [Both start and end date must be set for this feature to work]
 DEFAULTSTARTDATE          = DATENULL
 DEFAULTENDDATE            = DATENULL
 GENERICUSERERRORMSG       = CHARACTER
 TMPTEXT                   = CHARACTER
 TMPCHR                    = CHARACTER
 TMPLOOP                   = NUMBER
 TMPTEXTLOOP               = NUMBER
 CHRVAL                    = NUMBER
 VALIDCHRINPUT1            = CHARACTER
 VALIDCHARS                = NUMBER ARRAY(999)
 MAXCHRVALUE               = 255
 APPROVALCODESEXCLUDED     = NUMBER ARRAY(9999)
 BNOCFGFILENAME            = CHARACTER
 BNODEBUGCOUNT             = NUMBER
 BNODEBUGLOOP              = NUMBER
 BNODEBUGMODE              = NUMBER
 BNODEBUGMODEOFF           = 0
 BNODEBUGMODEON            = 1
 BNODEBUGMSG               = CHARACTER
 BNODEBUGMSGLIST           = CHARACTER ARRAY(999)
 BNODEBUGMSGMAX            = 999
 BNOINCLUDEPARMINDEBUG     = NUMBER
 BNOINDENT                 = CHARACTER ARRAY(9)
 BNOINDENTMAX              = 9
 BNOLASTMODDATE            = DATE
 BNOLASTMODTIME            = CHARACTER
 BNOLOCALLOOP              = NUMBER
 BNOPRINTDEBUGDAYS         = NUMBER
 BNOPRINTDEBUGINFODAYS     = NUMBER
 BNOPROGRAMNAME            = CHARACTER
 BNOPROGRAMVERSION         = CHARACTER
 CUTOFFDQA                 = NUMBER
 CUTOFFDQB                 = NUMBER
 CUTOFFDQC                 = NUMBER
 CUTOFFDQD                 = NUMBER
 CUTOFFDQE                 = NUMBER
 DUEDATECALCTYPE           = CHARACTER ARRAY(13)
 ELEGIBLEFREQUENCIES       = NUMBER ARRAY(13)
 HONORSKIPS                = NUMBER
 LNEWDUEMONTH              = NUMBER
 MINIMUMPAYMENTCOUNT       = NUMBER
 TESTACCOUNTLIST           = CHARACTER
 TESTMODE                  = NUMBER
 TMPPOS                    = NUMBER
 TMPVAL                    = NUMBER
 TRUEFALSECHR              = CHARACTER ARRAY(1)
 VALIDTESTACCOUNT          = NUMBER
 TMPPARAM                  = CHARACTER
 TMPPARAMVAL               = CHARACTER
 POS                       = NUMBER
 FOUND                     = NUMBER
END [DEFINE]

SETUP
 Q=CTRLCHR(34)
 TRUEFALSECHR(FALSE)="FALSE"
 TRUEFALSECHR(TRUE)="TRUE"
 CALL INITIALIZETERMS
 TERMS(1)="Some example terms go here"
 TERMS(2)="Some more text"
 TERMSLINESCOUNT=2
 VALIDCHRINPUT1="32-126,128-175,181-184,189,190,198,199,208-216,221,222,224-253"
 BNOLASTMODDATE='05/30/2024'
 BNOLASTMODTIME="11:30 ET"
 BNOPROGRAMNAME="BANNO.LOANPAYMENT.SKIP.V1.POW"
 BNOCFGFILENAME = "BANNO.LOANPAYMENT.SKIP.CFG"
 BNOPROGRAMVERSION="1.1.4"
 BNOPRINTDEBUGINFODAYS=90
 IF BNOLASTMODDATE+BNOPRINTDEBUGINFODAYS>SYSTEMDATE THEN
  BNODEBUGMODE=BNODEBUGMODEON
 BNOINCLUDEPARMINDEBUG=TRUE
END [SETUP]

PRINT TITLE="Banno Skip a Loan Payment"

 CALL INITIALIZEDATA
 CALL READCONFIGFILESETTINGS
 NEWLINE
 PRINT "{"
 NEWLINE

 IF READCONFIGERROR=TRUE THEN
  DO
   PRINT Q+"clientErrorMessage"+Q+":"
   PRINT Q+GENERICUSERERRORMSG+Q+","
   NEWLINE
   PRINT Q+"loggingErrorMessage"+Q+":"
   PRINT Q+READCONFIGERRORMSG+Q+","
   NEWLINE
  END
 ELSE
  DO
   IF @RGSTATE=GETPRELOADDATA THEN
    DO
     CALL PROCGETPRELOADDATA
    END
   ELSE IF @RGSTATE=PERFORMSKIPAPAYMENT THEN
    DO
     CALL PROCPERFORMSKIPAPAYMENT
    END
  END

 CALL BNOPRINTPROGRAMINFO
 CALL BNOPRINTRGDATA
 CALL BNOPRINTDEBUG

 IF BNODEBUGMODE=BNODEBUGMODEOFF THEN
  NEWLINE
 PRINT "}"
 NEWLINE
END [PRINT]

PROCEDURE PROCGETPRELOADDATA
 [ Check if skip-a-pay is available based on start and end dates.
   Both dates must be set to a non null value for this to work.
 ]
 PRINT "  "+Q+"available"+Q+":"
 IF STARTDATE<>DATENULL AND ENDDATE<>DATENULL THEN
  DO
   IF SYSTEMDATE>=STARTDATE AND
      SYSTEMDATE<=ENDDATE AND
      ENDDATE>=STARTDATE THEN
    PRINT "true,"
   ELSE
    PRINT "false,"
  END
 ELSE
  PRINT "true,"
 NEWLINE

 PRINT "  "+Q+"availableStartDate"+Q+":"
 IF STARTDATE<>DATENULL then
  PRINT Q+FORMAT("99/99/9999",STARTDATE)+Q+","
 ELSE
  PRINT Q+Q+","
 NEWLINE

 PRINT "  "+Q+"availableEndDate"+Q+":"
 IF ENDDATE<>DATENULL then
  PRINT Q+FORMAT("99/99/9999",ENDDATE)+Q+","
 ELSE
  PRINT Q+Q+","
 NEWLINE

 PRINT "  "+Q+"feePerPaymentSkip"+Q+":"+Q+FORMAT("#######9.99",FEEAMOUNT)+Q+","
 NEWLINE

 PRINT "  "+Q+"terms"+Q+":["
 NEWLINE
 I=1
 WHILE I<TERMSMAXLINES AND
       I<=TERMSLASTLLINEUSED
  DO
   IF I>1 THEN
    PRINT ","
   PRINT Q+TERMS(I)

   IF TERMS(I)<> "" AND
      I<TERMSLASTLLINEUSED AND
      TERMS(I)<>"" THEN
    PRINT " "
   PRINT Q
   NEWLINE
   I=I+1
  END
 PRINT "],"
 NEWLINE

 CALL GETLOANDATA
 PRINT "  "+Q+"availableLoans"+Q+": ["
 NEWLINE

 LOANDISPLAYED=FALSE
 FOR LOANLOOP=1 TO TOTALLOANS
  DO
   IF LOANINELIGIBLECODE(LOANLOOP,INELIGIBLECODESET)=FALSE THEN
    DO
     LID=LOANID(LOANLOOP)
     CALL GETSKIPCRITERIA

     IF LOANDISPLAYED=TRUE THEN
      PRINT ","
     PRINT "{"
     NEWLINE
     PRINT Q+"name"+Q+": "+Q+LDESCRIPTION+Q+","
     NEWLINE
     PRINT Q+"paymentAmount"+Q+": "+Q+FORMAT("#######9.99",LPAYMENT)+Q+","
     NEWLINE
     PRINT Q+"accountId"+Q+":"+Q+LID+Q+","
     NEWLINE
     PRINT Q+"originalPaymentDueDate"+Q+": "+Q+FORMAT("99/99/9999",LDUEDATE)+Q+","
     NEWLINE
     PRINT Q+"newPaymentDueDate"+Q+": "+Q+FORMAT("99/99/9999",LNEWDUEDATE)+Q
     NEWLINE
     PRINT "}"
     NEWLINE

     LOANDISPLAYED=TRUE
    END
  END
 PRINT "  ],"
 NEWLINE

 PRINT "  "+Q+"ineligibleLoans"+Q+": ["
 NEWLINE

 LOANDISPLAYED=FALSE
 FOR LOANLOOP=1 TO TOTALLOANS
  DO
   IF LOANINELIGIBLECODE(LOANLOOP,INELIGIBLECODESET)=TRUE THEN
    DO
     LID=LOANID(LOANLOOP)
     CALL GETSKIPCRITERIA

     IF LOANDISPLAYED=TRUE THEN
      PRINT ","
     PRINT "{"
     NEWLINE
     PRINT Q+"name"+Q+": "+Q+LDESCRIPTION+Q+","
     NEWLINE
     PRINT Q+"accountId"+Q+":"+Q+LID+Q+","
     NEWLINE
     INELIGIBLEDISPLAYED=FALSE
     FOR TEMPLOOP=1 TO INELIGIBLEREASONSMAX
      DO
       IF LOANINELIGIBLECODE(LOANLOOP,TEMPLOOP)=TRUE AND
          INELIGIBLEDISPLAYED=FALSE THEN
        DO
         PRINT Q+"ineligibilityReason"+Q+": "+Q+INELIGIBLEREASONS(TEMPLOOP)+Q
         NEWLINE
         INELIGIBLEDISPLAYED=TRUE
        END
      END

     PRINT "}"
     NEWLINE

     LOANDISPLAYED=TRUE
    END
  END
 PRINT "  ],"
 NEWLINE

 PRINT "  "+Q+"availableShares"+Q+": ["
 NEWLINE

 SHAREDISPLAYED=FALSE
 FOR EACH SHARE WITH (SHARE:CLOSEDATE=DATENULL AND
                      SHARE:CHARGEOFFDATE=DATENULL AND
                      SHARE:AVAILABLEBALANCE>=FEEAMOUNT AND
                      SHARETYPES(SHARE:TYPE)=TRUE)
  DO
   TMPCHR=SHARE:DESCRIPTION
   CALL CLEANUPTEXT

   IF SHAREDISPLAYED=TRUE THEN
    PRINT ","
   PRINT "{"+Q+"name"+Q+": "+Q+TMPCHR+Q+","
   NEWLINE
   PRINT Q+"accountId"+Q+": "+Q+SHARE:ID+Q+","
   NEWLINE
   PRINT Q+"balance"+Q+": "+Q+FORMAT("#######9.99",SHARE:AVAILABLEBALANCE)+Q+"}"
   NEWLINE
   SHAREDISPLAYED=TRUE
  END
 PRINT "]"
END [PROCEDURE]

PROCEDURE PROCPERFORMSKIPAPAYMENT
 PRINT Q+"loansWithPaymentsSkipped"+Q+": ["
 NEWLINE

[* Need the loan data for input validation
*]
 CALL GETLOANDATA

 TEXT1=@RGUSERCHR2
 CALL TEXTNLTS
 @RGUSERCHR2=TEXT1

 ERRORMSGUSER=""
 ERRORMSGLOG=""
 ERRORFLAG=FALSE
 LOANDISPLAYED=FALSE
 LIDLIST=@RGUSERCHR1
 TOTALFEE=FEEAMOUNT
 FEESUM=$0.00
 WHILE LIDLIST<>"" AND ERRORFLAG=FALSE
  DO
   CALL GETNEXTLID
   CALL GETSKIPCRITERIA
   I=1
   WHILE I<=TOTALLOANS AND LOANID(I)<>LID
    DO
     I=I+1
    END

   IF I>TOTALLOANS THEN
    DO
     ERRORFLAG=TRUE
     ERRORMSGUSER=GENERICUSERERRORMSG
     ERRORMSGLOG="Invalid loan id: "+LID
    END

   IF ERRORFLAG=FALSE AND
      LOANINELIGIBLECODE(I,INELIGIBLECODESET)=TRUE THEN
    DO
     ERRORFLAG=TRUE
     ERRORMSGUSER=GENERICUSERERRORMSG
     ERRORMSGLOG="Attempt to skip a payment on an ineligible loan: "+LID
    END

   IF ERRORFLAG=FALSE AND @RGUSERCHR2<>"" THEN
    DO
     SHAREFOUND=FALSE
     FOR EACH SHARE WITH (SHARE:ID=@RGUSERCHR2)
      DO
       SHAREFOUND=TRUE
      END
     IF SHAREFOUND=FALSE THEN
      DO
       ERRORFLAG=TRUE
       ERRORMSGUSER=GENERICUSERERRORMSG
       ERRORMSGLOG="Invalid fee share id: "+@RGUSERCHR2
      END
    END

   IF ERRORFLAG=FALSE THEN
    DO
[ Update Loan fields]

     FEESUM=FEESUM+TOTALFEE
     FMPERFORM REVISE LOAN LID (0,0,FMERROR)
      DO
       SET DUEDATE       TO LNEWDUEDATE
       SET MATURITYDATE  TO LNEWMATURITYDATE
      END
     IF FMERROR<>"" THEN
      DO
       ERRORFLAG=TRUE
       ERRORMSGUSER=GENERICUSERERRORMSG
       ERRORMSGLOG="Loan Record Update Failed. Error: "+FMERROR
      END
     ELSE
      DO
[ Update Loan fields]

       FMPERFORM CREATE LOAN LID TRACKING LOC -1 (1,LOANTRACKINGTYPE,FMERROR)
        DO
         SET EXPIREDATE  TO DATENULL
         SET USERDATE1   TO SYSTEMDATE
         SET USERDATE2   TO LDUEDATE
         SET USERDATE3   TO LNEWDUEDATE
         SET USERDATE4   TO LMATURITYDATE
         SET USERDATE5   TO LNEWMATURITYDATE
         SET USERAMOUNT1 TO TOTALFEE
         SET USERAMOUNT2 TO LPAYMENT
        END
       IF FMERROR<>"" THEN
        DO
         ERRORFLAG=TRUE
         ERRORMSGUSER=GENERICUSERERRORMSG
         ERRORMSGLOG="Tracking Record Create Failed. Error: "+FMERROR
        END
       ELSE
        DO
         IF LOANDISPLAYED=TRUE THEN
          PRINT ","
         PRINT "{"
         NEWLINE
         PRINT Q+"name"+Q+": "+Q+LDESCRIPTION+Q+","
         NEWLINE
         PRINT Q+"paymentAmount"+Q+": "+Q+FORMAT("#######9.99",LPAYMENT)+Q+","
         NEWLINE
         PRINT Q+"accountId"+Q+":"+Q+LID+Q+","
         NEWLINE
         PRINT Q+"feePaid"+Q+": "+Q+FORMAT("#######9.99",TOTALFEE)+Q+","
         NEWLINE
         PRINT Q+"nextDueDate"+Q+": "+Q+FORMAT("99/99/9999",LNEWDUEDATE)+Q
         NEWLINE
         FOR EACH SHARE WITH (SHARE:ID=@RGUSERCHR2)
          DO
           TMPCHR=SHARE:DESCRIPTION
           CALL CLEANUPTEXT

           PRINT ","+Q+"shareDebited"+Q+": "+Q+TMPCHR+Q
           NEWLINE
          END
         PRINT "}"
         NEWLINE
         LOANDISPLAYED=TRUE
        END
      END
    END
  END

[ Debit fee]

 IF ERRORFLAG=FALSE AND FEESUM>$0.00 THEN
  DO
   IF OTHERACTION<>0 THEN
    DO
     TRANPERFORM WF (0,SEQ1,SEQ2,CAC,CN,TRANERROR)
      DO
       SET FMACCT TO ACCOUNT:NUMBER
       SET FMTYPE TO "S"
       SET FMID   TO @RGUSERCHR2
       SET AMOUNT TO FEESUM
       SET SUBSOURCECODE TO SUBSOURCECODE
       SET COMMENT:1 TO FEECOMMENT
       SET OTHERACTION TO FORMAT("9",OTHERACTION)
       SET OTHERIDTYPE TO "L"
       SET OTHERID TO LID
      END  [TRANPERFORM]
    END
   ELSE
    DO
     TRANPERFORM WF (0,SEQ1,SEQ2,CAC,CN,TRANERROR)
      DO
       SET FMACCT TO ACCOUNT:NUMBER
       SET FMTYPE TO "S"
       SET FMID   TO @RGUSERCHR2
       SET AMOUNT TO FEESUM
       SET SUBSOURCECODE TO SUBSOURCECODE
       SET COMMENT:1 TO FEECOMMENT
      END  [TRANPERFORM]
    END
  END
 IF TRANERROR<>"" AND ERRORFLAG=FALSE THEN
  DO
   ERRORFLAG=TRUE
   ERRORMSGUSER=GENERICUSERERRORMSG
   ERRORMSGLOG="Skip Pay Fee Post Failed. Error="+TRANERROR
  END

 PRINT "],"+Q+"clientErrorMessage"+Q+":"
 NEWLINE
 PRINT Q+ERRORMSGUSER+Q
 NEWLINE
 PRINT ","+Q+"loggingErrorMessage"+Q+":"
 NEWLINE
 PRINT Q+ERRORMSGLOG+Q
 NEWLINE
 PRINT ","+Q+"memoMode"+Q+":"
 IF SYSMEMOMODE=0 THEN
  DO
   PRINT "false"
  END
 ELSE
  DO
   PRINT "true"
  END
END [PROCEDURE]

PROCEDURE INITIALIZETERMS
 WHILELIMIT=100000
 FOR I=1 TO TERMSMAXLINES
  DO
   TERMS(I)=""
  END
END [PROCEDURE]

PROCEDURE INITIALIZEDATA
 FEEAMOUNT=DEFAULTFEEAMOUNT
 LOANTRACKINGTYPE=DEFAULTLOANTRACKINGTYPE
 MAXSKIPS=DEFAULTMAXSKIPS
 MINMONTHSINCE=DEFAULTMINMONTHSINCE
 SUBSOURCECODE=DEFAULTSUBSOURCECODE
 OTHERACTION=DEFAULTOTHERACTION
 FEECOMMENT=DEFAULTFEECOMMENT
 LOANMINPAYMENT=DEFAULTLOANMINPAYMENT
 LOANMAXPAYMENT=DEFAULTLOANMAXPAYMENT
 STARTDATE=DEFAULTSTARTDATE
 ENDDATE=DEFAULTENDDATE
 HONORSKIPS=FALSE
 LOANSEASON=0
 GENERICUSERERRORMSG="We're sorry we've encountered an error. "+
                     "Please contact your credit union."

 WHILELIMIT=100000
 FOR I=1 TO LOANSMAX
  DO
   LOANID(I)=""
   FOR J=0 TO INELIGIBLEREASONSMAX
    DO
     LOANINELIGIBLECODE(I,J)=FALSE
    END
  END

 FOR TEMPLOOP=1 TO WARNINGSMAX
  DO
   LOANWARNINGS(TEMPLOOP)=FALSE
   ACCTWARNINGS(TEMPLOOP)=FALSE
  END

 FOR TEMPLOOP=1 TO SERVICECODEMAX
  DO
   LOANSERVICECODE(TEMPLOOP)=FALSE
  END

 FOR TEMPLOOP=1 TO FEEAMOUNTSMAX
  DO
   FEEAMOUNTS(TEMPLOOP)=$0.00
  END

 FOR TEMPLOOP=0 TO TYPESMAX
  DO
   LOANTYPES(TEMPLOOP)=TRUE
   SHARETYPES(TEMPLOOP)=TRUE
  END

 FEEAMOUNTS(0)=FEEAMOUNT
 GRACEDAYS=0

[* 02/04/22 *]
 FOR TMPLOOP=1 TO 13
  DO
   ELEGIBLEFREQUENCIES(TMPLOOP)=0
   DUEDATECALCTYPE(TMPLOOP)="M"
  END

 FOR TMPLOOP=1 TO 9999
  DO
   APPROVALCODESEXCLUDED(TMPLOOP)=0
  END

 MINIMUMPAYMENTCOUNT=0
 CUTOFFDQA=0
 CUTOFFDQB=0
 CUTOFFDQC=0
 CUTOFFDQD=0
 CUTOFFDQE=0

 TESTMODE=FALSE
 TESTACCOUNTLIST=""
 VALIDTESTACCOUNT=FALSE

 [Initialize the ineligible reason messages]
 INELIGIBLEREASONS(INELIGIBLECODELOANTYPE)=
  "Ineligible Loan Type"
 INELIGIBLEREASONS(INELIGIBLECODELOANWARNING)=
  "Loan Warning Found"
 INELIGIBLEREASONS(INELIGIBLECODEMAXSKIPS)=
  "Max Loan skips already used for last 12 months"
 INELIGIBLEREASONS(INELIGIBLECODETIMESKIP)=
  "Insufficient time since last skip"
 INELIGIBLEREASONS(INELIGIBLECODEACCTWARNING)=
  "Account Warning Found"
 INELIGIBLEREASONS(INELIGIBLECODESERVICECODE)=
  "Required Service Code(s) not found"
 INELIGIBLEREASONS(INELIGIBLECODEMINPAYMENT)=
  "Payment Less than Minimum allowed"
 INELIGIBLEREASONS(INELIGIBLECODEMAXPAYMENT)=
  "Payment More than Maximum allowed"
 INELIGIBLEREASONS(INELIGIBLECODETIMEOPEN)=
  "Insufficient time since loan was opened"
 INELIGIBLEREASONS(INELIGIBLECODEPASTDUE)=
  "Loan past due grace period elapsed"

[* 01/21/22 *]
 INELIGIBLEREASONS(INELIGIBLECODEFREQ)=
  "Loan payment frequency is ineligible"
 INELIGIBLEREASONS(INELIGIBLECODEMINPMTCOUNT)=
  "Minimum payment count not met"
 INELIGIBLEREASONS(INELIGIBLECODEAPPROVALCODE)=
  "Ineligible loan approval code"
 INELIGIBLEREASONS(INELIGIBLECODEDQPAYMENTS)=
  "Acceptable number of DQ payments exceeded"

END [PROCEDURE]

PROCEDURE READCONFIGFILESETTINGS
 READCONFIGERROR=FALSE
 READCONFIGERRORMSG=""
[ Parse letterfile]
 FILEOPEN("LETTER",CONFIGFILENAME,"READ",LFNUMBER,LFERROR)
 IF LFERROR<>"" THEN
  DO
   READCONFIGERROR=TRUE
   READCONFIGERRORMSG="Error Opening Letterfile "+CONFIGFILENAME+": "+LFERROR
   BNODEBUGMSG="ERROR READING CFG LETTER FILE '"+CONFIGFILENAME+" ' ERROR:"+LFERROR
   CALL BNODEBUGMSGADD
  END
 ELSE
  DO
   IF BNOINCLUDEPARMINDEBUG=TRUE THEN
    DO
     BNODEBUGMSG="*** CONFIGURATION FILE SETTINGS - START"
     CALL BNODEBUGMSGADD
    END
   TERMSLINESCOUNT=0
   WHILE LFERROR="" AND
         READCONFIGERROR=FALSE
    DO
     TMPPARAM=""
     TMPPARAMVAL=""
     FILEREADLINE(LFNUMBER,LFLINE,LFERROR)
     IF LFERROR="" AND
        SEGMENT(LFLINE,1,1)<>"*" AND
        LFLINE<>"" AND
        CHARACTERSEARCH(LFLINE,":")>0 THEN
      DO
[The text in front of the colon is the parameter and after the colon is
 the parameter setting.]
       POS=CHARACTERSEARCH(LFLINE,":")
       TEXT1=SEGMENT(LFLINE,1,POS-1)
       CALL TEXTNLTS
       TMPPARAM=TEXT1
       TEXT1=SEGMENT(LFLINE,POS+1,LENGTH(LFLINE))
[Trim leading and trailing spaces from the parameter value unless it's
 for the terms or conditions (TC)]
       IF TMPPARAM<>"TC" THEN
        CALL TEXTNLTS
       TMPPARAMVAL=TEXT1
       IF BNOINCLUDEPARMINDEBUG=TRUE THEN
        DO
         BNODEBUGMSG=TMPPARAM+":"+TMPPARAMVAL
         CALL BNODEBUGMSGADD
        END
      END
     IF TMPPARAM<>"" THEN
      DO

[ Terms & conditions ]
       IF TMPPARAM="TC"  AND
          TERMSLINESCOUNT<TERMSMAXLINES THEN
        DO
         TERMSLINESCOUNT=TERMSLINESCOUNT+1
         TMPCHR=TMPPARAMVAL
         CALL CLEANUPTEXT
         TERMS(TERMSLINESCOUNT)=TMPCHR
         IF TMPCHR<>"" THEN
          TERMSLASTLLINEUSED=TERMSLINESCOUNT
        END

[ Loan types ]
       ELSE IF TMPPARAM="LT" THEN
        DO
         IF TMPPARAMVAL="" THEN
          TMPPARAMVAL="ALL"
         LELISTINPUT=TMPPARAMVAL
         CALL LISTEXPAND
         FOUND=FALSE
         FOR I=0 TO TYPESMAX
          DO
           LOANTYPES(I)=LELIST(I)
           IF LOANTYPES(I)=TRUE THEN
            FOUND=TRUE
          END
         IF FOUND=FALSE THEN
          DO
           READCONFIGERROR=TRUE
           READCONFIGERRORMSG="No loan types found in CFG Letter file"
          END
        END

[ Loan service codes ]
       ELSE IF TMPPARAM="SC" THEN
        DO
         LELISTINPUT=TMPPARAMVAL
         IF LELISTINPUT="" THEN
          LELISTINPUT="NONE"
         CALL LISTEXPAND
         FOR I=1 TO SERVICECODEMAX
          DO
           LOANSERVICECODE(I)=LELIST(I)
          END
        END

[ Loan warning codes ]
       ELSE IF TMPPARAM="LW" THEN
        DO
         IF TMPPARAMVAL="" THEN
          TMPPARAMVAL="NONE"
         LELISTINPUT=TMPPARAMVAL
         CALL LISTEXPAND
         FOR I=1 TO WARNINGSMAX
          DO
           LOANWARNINGS(I)=LELIST(I)
          END
        END

[ Acct warning codes ]
       ELSE IF TMPPARAM="AW" THEN
        DO
         IF TMPPARAMVAL="" THEN
          TMPPARAMVAL="NONE"
         LELISTINPUT=TMPPARAMVAL
         CALL LISTEXPAND
         FOR I=1 TO WARNINGSMAX
          DO
           ACCTWARNINGS(I)=LELIST(I)
          END
        END

[ Share types ]
       ELSE IF TMPPARAM="ST" THEN
        DO
         IF TMPPARAMVAL="" THEN
          TMPPARAMVAL="ALL"
         LELISTINPUT=TMPPARAMVAL
         CALL LISTEXPAND
         FOR I=0 TO TYPESMAX
          DO
           SHARETYPES(I)=LELIST(I)
          END
        END

[ Program time period ]
       ELSE IF TMPPARAM="TP" THEN
        DO
         TIMEPERIOD=TMPPARAMVAL
        END

[ Min payment amount ]
       ELSE IF TMPPARAM="MA" THEN
        DO
         LOANMINPAYMENT=MONEY(VALUE(TMPPARAMVAL))
        END

[ Max payment amount ]
       ELSE IF TMPPARAM="XA" THEN
        DO
         LOANMAXPAYMENT=MONEY(VALUE(TMPPARAMVAL))
        END

[ Loan season ]
       ELSE IF TMPPARAM="LS" THEN
        DO
         LOANSEASON=VALUE(TMPPARAMVAL)
         IF LOANSEASON>360 THEN
          LOANSEASON=360
        END

[ Grace days past due ]
       ELSE IF TMPPARAM="GD" THEN
        DO
         GRACEDAYS=VALUE(TMPPARAMVAL)
         IF GRACEDAYS<0 THEN
          GRACEDAYS=0
        END

[ Fee amount(s) ]
       ELSE IF TMPPARAM="FA" AND
               TMPPARAMVAL<>"" THEN
        DO
         FEEAMOUNTS(VALUE(SEGMENT(TMPPARAMVAL,1,2)))=
                    MONEY(VALUE(SEGMENT(TMPPARAMVAL,4,LENGTH(TMPPARAMVAL))))
        END

[ Loan tracking type ]
       ELSE IF TMPPARAM="TT" AND
               TMPPARAMVAL<>"" THEN
        DO
         IF VALUE(TMPPARAMVAL)>=30 AND
            VALUE(TMPPARAMVAL)<=99 THEN
          LOANTRACKINGTYPE=VALUE(TMPPARAMVAL)
         ELSE
          DO
           READCONFIGERROR=TRUE
           READCONFIGERRORMSG=FORMAT("Invalid loan tracking type: ###9",VALUE(TMPPARAMVAL))
          END
        END

[ Max skips per year ]
       ELSE IF TMPPARAM="PS" AND
               TMPPARAMVAL<>"" THEN
        DO
         MAXSKIPS=VALUE(TMPPARAMVAL)
        END

[ Min months since last skip ]
       ELSE IF TMPPARAM="MM" AND
               TMPPARAMVAL<>"" THEN
        DO
         MINMONTHSINCE=VALUE(TMPPARAMVAL)
        END

[ Sub Source Code for Fee ]
       ELSE IF TMPPARAM="SS" AND
               TMPPARAMVAL<>"" THEN
        DO
         IF VALUE(TMPPARAMVAL)>=0 AND
            VALUE(TMPPARAMVAL)<=50 THEN
          SUBSOURCECODE=VALUE(TMPPARAMVAL)
         ELSE
          DO
           READCONFIGERROR=TRUE
           READCONFIGERRORMSG=FORMAT("Invalid sub source code: 999",VALUE(TMPPARAMVAL))
          END
        END


[ OTHERACTION for Fee ]
       ELSE IF TMPPARAM="OA" AND
               TMPPARAMVAL<>"" THEN
        DO
         IF VALUE(TMPPARAMVAL)>=0 AND
            VALUE(TMPPARAMVAL)<=1 THEN
          OTHERACTION=VALUE(TMPPARAMVAL)
         ELSE
          DO
           READCONFIGERROR=TRUE
           READCONFIGERRORMSG=FORMAT("Invalid other action: 999",VALUE(TMPPARAMVAL))
          END
        END

[ Transaction comment for Fee ]
       ELSE IF TMPPARAM="FC" THEN
        DO
         FEECOMMENT=TMPPARAMVAL
        END

[ Eligible payment frequencies ]
       ELSE IF TMPPARAM="EPF" THEN
        DO
         IF TMPPARAMVAL="" THEN
          TMPPARAMVAL="ALL"
         LELISTINPUT=TMPPARAMVAL
         CALL LISTEXPAND
         FOR BNOLOCALLOOP=1 TO 13
          DO
           ELEGIBLEFREQUENCIES(BNOLOCALLOOP)=LELIST(BNOLOCALLOOP)
          END
        END

[ Due Date Calculations ]
       ELSE IF SEGMENT(TMPPARAM,1,3)="DDA" THEN
        DO
         TMPVAL=VALUE(TMPPARAM)
         TEXT1=UPPERCASE(TMPPARAMVAL)

         IF ((TMPVAL>=1 AND TMPVAL<10) OR
             (TMPVAL>=11 AND TMPVAL<=13)) AND
             (TEXT1="M" OR TEXT1="F") THEN
          DO
           DUEDATECALCTYPE(TMPVAL)=TEXT1
          END
        END

[ Minimum Payment Count ]
       ELSE IF TMPPARAM="MPC" THEN
        DO
         MINIMUMPAYMENTCOUNT=VALUE(TMPPARAMVAL)
         IF MINIMUMPAYMENTCOUNT<0 THEN
          MINIMUMPAYMENTCOUNT=0
        END

[ Approval Code Exclusion ]
       ELSE IF TMPPARAM="ACE" THEN
        DO
         IF TMPPARAMVAL="" THEN
          TMPPARAMVAL="NONE"
         LELISTINPUT=TMPPARAMVAL
         CALL LISTEXPAND
         FOR BNOLOCALLOOP=1 TO 9999
          DO
           APPROVALCODESEXCLUDED(BNOLOCALLOOP)=LELIST(BNOLOCALLOOP)
          END
        END

[ Maximum number of late payments ]
       ELSE IF TMPPARAM="DQA" THEN
        DO
         CUTOFFDQA=VALUE(TMPPARAMVAL)
        END
       ELSE IF TMPPARAM="DQB" THEN
        DO
         CUTOFFDQB=VALUE(TMPPARAMVAL)
        END
       ELSE IF TMPPARAM="DQC" THEN
        DO
         CUTOFFDQC=VALUE(TMPPARAMVAL)
        END
       ELSE IF TMPPARAM="DQD" THEN
        DO
         CUTOFFDQD=VALUE(TMPPARAMVAL)
        END
       ELSE IF TMPPARAM="DQE" THEN
        DO
         CUTOFFDQE=VALUE(TMPPARAMVAL)
        END

[ check for honoring of the skip first / skip last criteria ]
       ELSE IF TMPPARAM="SFLE" THEN
        DO
         IF UPPERCASE(TMPPARAMVAL)="TRUE" THEN
          HONORSKIPS=TRUE
        END

[ Check for test mode ]
       ELSE IF TMPPARAM="TNC" THEN
        DO
         IF UPPERCASE(TMPPARAMVAL)="TRUE" THEN
          TESTMODE=TRUE
        END

[ grab test account list ]
       ELSE IF TMPPARAM="TML" THEN
        DO
         IF LENGTH(TMPPARAMVAL)>=10 THEN
          TESTACCOUNTLIST=TMPPARAMVAL
         IF TESTACCOUNTLIST<>"" THEN
          DO
           IF CHARACTERSEARCH(TESTACCOUNTLIST,ACCOUNT:NUMBER)>0 THEN
            VALIDTESTACCOUNT=TRUE
          END
        END
      END [IF TMPPARAM<>"" THEN]
    END [WHILE LFERROR=""]

   IF BNOINCLUDEPARMINDEBUG=TRUE THEN
    DO
     BNODEBUGMSG="*** CONFIGURATION FILE SETTINGS - END"
     CALL BNODEBUGMSGADD
    END
  END [LFERROR=""]

 IF READCONFIGERROR=FALSE THEN
  DO

[ Determine which fee to use]
   FEEAMOUNTSET=FALSE
   IF ACCOUNT:RELATIONSHIPOVERRIDE>0 AND
     (ACCOUNT:RELATIONSHIPOVERRIDEEFFDATE=DATENULL OR
      ACCOUNT:RELATIONSHIPOVERRIDEEFFDATE<=SYSTEMDATE) AND
     (ACCOUNT:RELATIONSHIPOVERRIDEEXPDATE=DATENULL OR
      ACCOUNT:RELATIONSHIPOVERRIDEEXPDATE>SYSTEMDATE) THEN [Rel Code Override]
    DO
     FEEAMOUNTSET=TRUE
     FEEAMOUNT=FEEAMOUNTS(ACCOUNT:RELATIONSHIPOVERRIDE)
    END
   ELSE IF ACCOUNT:RELATIONSHIPCODE>0 THEN [Relationship Code]
    DO
     FEEAMOUNTSET=TRUE
     FEEAMOUNT=FEEAMOUNTS(ACCOUNT:RELATIONSHIPCODE)
    END
   ELSE [Base fee]
    DO
     FEEAMOUNTSET=TRUE
     FEEAMOUNT=FEEAMOUNTS(0)
    END

   IF FEEAMOUNTSET=FALSE THEN
    FEEAMOUNT=FEEAMOUNTS(0)

[ Check if time period is valid, and parse start and end dates ]
   IF TIMEPERIOD<>"" THEN
    DO
     POS=CHARACTERSEARCH(TIMEPERIOD,"-")
     IF POS>10 THEN
      DO
       TEXT1=SEGMENT(TIMEPERIOD,1,POS-1)
       CALL TEXTNLTS
       IF LENGTH(TEXT1)=10 THEN
        STARTDATE=DATE(VALUE(SEGMENT(TEXT1,1,2)),
                    VALUE(SEGMENT(TEXT1,4,5)),
                    VALUE(SEGMENT(TEXT1,7,10)))
       TEXT1=SEGMENT(TIMEPERIOD,POS+1,LENGTH(TIMEPERIOD))
       CALL TEXTNLTS
       IF LENGTH(TEXT1)=10 THEN
        ENDDATE=DATE(VALUE(SEGMENT(TEXT1,1,2)),
                     VALUE(SEGMENT(TEXT1,4,5)),
                     VALUE(SEGMENT(TEXT1,7,10)))
      END
    END
  END

[* Check for at least one test account if test mode is on
*]
 IF READCONFIGERROR=FALSE AND
    TESTMODE=TRUE AND
    LENGTH(TESTACCOUNTLIST)<10 THEN
  DO
   READCONFIGERROR=TRUE
   READCONFIGERRORMSG="Test mode on but no test account(s) defined"
  END

[*Check for valid start and end dates. if both dates are present in the
** config Letter file then the end date must be after the start date.
*]
 IF READCONFIGERROR=FALSE AND
    STARTDATE<>DATENULL AND
    ENDDATE<>DATENULL AND
    ENDDATE<=STARTDATE THEN
  DO
   READCONFIGERROR=TRUE
   READCONFIGERRORMSG="Invalid start/end date(s)"
  END
END [PROCEDURE]

PROCEDURE GETLOANDATA

 TOTALLOANS=0
 ELIGIBLELOANS=0
 FOR EACH LOAN WITH (LOAN:CLOSEDATE=DATENULL AND
                     LOAN:CHARGEOFFDATE=DATENULL AND
                     LOAN:BALANCE>$0.00)
  DO
   TOTALLOANS=TOTALLOANS+1
   FOR I=0 TO INELIGIBLEREASONSMAX
    DO
     LOANINELIGIBLECODE(TOTALLOANS,I)=FALSE
    END

   LOANID(TOTALLOANS)=LOAN:ID
   IF LOANTYPES(LOAN:TYPE)=FALSE THEN
    LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODELOANTYPE)=TRUE
   FOR WARNINGLOOP=1 TO WARNINGSMAX
    DO
     IF ANYWARNING(ACCOUNT,WARNINGLOOP) AND
        ACCTWARNINGS(WARNINGLOOP)=TRUE THEN
      LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODEACCTWARNING)=TRUE
     IF ANYWARNING(LOAN,WARNINGLOOP) AND
        LOANWARNINGS(WARNINGLOOP)=TRUE THEN
      LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODELOANWARNING)=TRUE
    END

   SERVICEFOUND=FALSE
   FOR SERVICELOOP=1 TO SERVICECODEMAX
    DO
     IF ANYSERVICE(LOAN,SERVICELOOP) AND
        LOANSERVICECODE(SERVICELOOP)=TRUE THEN
      SERVICEFOUND=TRUE
    END

[ If none are found, check to see if any are defined]
   IF SERVICEFOUND=FALSE THEN
    DO
     [default to none found]
     SERVICEFOUND=TRUE
     FOR SERVICELOOP=1 TO SERVICECODEMAX
      DO
[ One found, loan ineligible]
       IF LOANSERVICECODE(SERVICELOOP)=TRUE THEN
        SERVICEFOUND=FALSE
      END
    END
[ If none found, and some are defined]
   IF SERVICEFOUND=FALSE THEN
    LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODESERVICECODE)=TRUE

[ Payment amount]
   IF LOANMINPAYMENT>$0.00 AND LOAN:PAYMENT<LOANMINPAYMENT THEN
    LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODEMINPAYMENT)=TRUE
   IF LOANMAXPAYMENT>$0.00 AND LOAN:PAYMENT>LOANMAXPAYMENT THEN
    LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODEMAXPAYMENT)=TRUE
[ Loan season]
   IF LOANSEASON>0 AND
      SYSTEMDATE<DATEOFFSET(LOAN:OPENDATE,LOANSEASON,0) THEN
    LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODETIMEOPEN)=TRUE
[ Grace period]
   IF LOAN:DUEDATE+GRACEDAYS<SYSTEMDATE THEN
    LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODEPASTDUE)=TRUE
[ Skips]
   SKIPCOUNT=0
   FOR EACH LOAN TRACKING WITH (LOAN TRACKING:TYPE=LOANTRACKINGTYPE AND
                                LOAN TRACKING:USERDATE1>=
                                DATEOFFSET(SYSTEMDATE,-12,0))
    DO
     SKIPCOUNT=SKIPCOUNT+1
    END
   UNTIL SKIPCOUNT=MAXSKIPS
[ Too many skips in last year]
   IF SKIPCOUNT>=MAXSKIPS THEN
    LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODEMAXSKIPS)=TRUE

   SKIPCOUNT=0
   FOR EACH LOAN TRACKING WITH (
                     LOAN TRACKING:TYPE=LOANTRACKINGTYPE AND
                     LOAN TRACKING:USERDATE2>=
                     DATEOFFSET(LOAN:DUEDATE,-MINMONTHSINCE,0))
    DO
     SKIPCOUNT=SKIPCOUNT+1
    END
   UNTIL SKIPCOUNT=1
[ Too soon since last skip]
   IF SKIPCOUNT>0 THEN
    LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODETIMESKIP)=TRUE

[* only evaluate the following settings if in test mode and the account is
** a test account or if running for everyone
*]
   IF TESTMODE=FALSE OR
     (TESTMODE=TRUE AND
      VALIDTESTACCOUNT=TRUE) THEN
    DO

[* Eligible Payment Frequencies *]
     IF ELEGIBLEFREQUENCIES(LOAN:PAYMENTFREQUENCY)=FALSE THEN
      LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODEFREQ)=TRUE

[* Minimum Payment Count *]
     IF MINIMUMPAYMENTCOUNT>0 AND
        LOAN:PAYMENTHISTORY:1<MINIMUMPAYMENTCOUNT THEN
      LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODEMINPMTCOUNT)=TRUE

[* Approval Code Exclusion *]
     IF APPROVALCODESEXCLUDED(LOAN:APPROVALCODE)=TRUE THEN
      LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODEAPPROVALCODE)=TRUE

[* Maximum number of late payments *]
     IF ((CUTOFFDQA>0 AND
          LOAN:PAYMENTHISTORY:2>=CUTOFFDQA) OR     [11-30 Days DQ]
         (CUTOFFDQB>0 AND
          LOAN:PAYMENTHISTORY:3>=CUTOFFDQB) OR     [31-60 Days DQ]
         (CUTOFFDQC>0 AND
          LOAN:PAYMENTHISTORY:4>=CUTOFFDQC) OR     [61-90 Days DQ]
         (CUTOFFDQD>0 AND
          LOAN:PAYMENTHISTORY:5>=CUTOFFDQD) OR     [91-120 Days DQ]
         (CUTOFFDQE>0 AND
         LOAN:PAYMENTHISTORY:6>=CUTOFFDQE)) THEN  [121 & up Days DQ]
      LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODEDQPAYMENTS)=TRUE

     BNODEBUGMSG="LID:"+LOAN:ID+FORMAT("  CUTOFFDQA:99",CUTOFFDQA)+
                 FORMAT("  DQB:99",CUTOFFDQB)+
                 FORMAT("  DQC:99",CUTOFFDQC)+
                 FORMAT("  DQD:99",CUTOFFDQD)+
                 FORMAT("  DQE:99",CUTOFFDQE)
     CALL BNODEBUGMSGADD
     BNODEBUGMSG=FORMAT("LOANPYMNTHISTA:99",LOAN:PAYMENTHISTORY:2)+
                 FORMAT("  HISTB:99",LOAN:PAYMENTHISTORY:3)+
                 FORMAT("  HISTC:99",LOAN:PAYMENTHISTORY:4)+
                 FORMAT("  HISTD:99",LOAN:PAYMENTHISTORY:5)+
                 FORMAT("  HISTE:99",LOAN:PAYMENTHISTORY:6)
     CALL BNODEBUGMSGADD
    END [IF TESTMODE=FALSE OR ...]

[ If any codes are set, loan is ineligible]
   FOR I=1 TO INELIGIBLEREASONSMAX
    DO
     IF LOANINELIGIBLECODE(TOTALLOANS,I)=TRUE THEN
      LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODESET)=TRUE
    END
[ Increment eligible loans]
   IF LOANINELIGIBLECODE(TOTALLOANS,INELIGIBLECODESET)=FALSE THEN
    ELIGIBLELOANS=ELIGIBLELOANS+1
  END
 UNTIL TOTALLOANS=LOANSMAX  [FOR EACH LOAN]
END [PROCEDURE]

PROCEDURE GETSKIPCRITERIA

 LDUEDATE=DATENULL
 LNEWDUEDATE=DATENULL
 LPAYMENT=$0.00
 LMATURITYDATE=DATENULL
 LNEWMATURITYDATE=DATENULL
 LDESCRIPTION=""

 FOR EACH LOAN WITH LOAN:ID=LID
  DO
   LDUEDATE=LOAN:DUEDATE
   LPAYMENT=LOAN:PAYMENT
   LMATURITYDATE=LOAN:MATURITYDATE
   TMPCHR=LOAN:DESCRIPTION
   CALL CLEANUPTEXT

   LDESCRIPTION=TMPCHR

   IF DUEDATECALCTYPE(LOAN:PAYMENTFREQUENCY)="F" AND
      (TESTMODE=FALSE OR
      (TESTMODE=TRUE AND
       VALIDTESTACCOUNT=TRUE)) THEN
    DO
     BNODEBUGMSG="Evaluating LOAN "+LID+" by frequency  - "+FORMAT("Freq=99",LOAN:PAYMENTFREQUENCY)

[* new due dates and maturity dates in this section are calculated based upon
** the loan's payment frequency
*]
     IF LOAN:PAYMENTFREQUENCY=1 THEN [annual]
      DO
[* advance the due date and maturity date by 1 year
*]
       LNEWDUEDATE=DATEOFFSET(LDUEDATE,12,LOAN:DUEDAY1)
       IF LMATURITYDATE<>DATENULL THEN
        LNEWMATURITYDATE=DATEOFFSET(LMATURITYDATE,12,LOAN:DUEDAY1)
      END

     ELSE IF LOAN:PAYMENTFREQUENCY=2 THEN [semiannual]
      DO
[* advance the due date and matuurity date by 6 months
*]
       LNEWDUEDATE=DATEOFFSET(LDUEDATE,6,LOAN:DUEDAY1)
       IF LMATURITYDATE<>DATENULL THEN
        LNEWMATURITYDATE=DATEOFFSET(LMATURITYDATE,6,LOAN:DUEDAY1)
      END

     ELSE IF LOAN:PAYMENTFREQUENCY=3 THEN [quarterly]
      DO
[* advance the due date and maturity date by 3 months
*]
       LNEWDUEDATE=DATEOFFSET(LDUEDATE,3,LOAN:DUEDAY1)
       IF LMATURITYDATE<>DATENULL THEN
        LNEWMATURITYDATE=DATEOFFSET(LMATURITYDATE,3,LOAN:DUEDAY1)
      END

     ELSE IF LOAN:PAYMENTFREQUENCY=4 THEN [monthly]
      DO
[* advance the due date and matuurity date by 1 month
*]
       LNEWDUEDATE=DATEOFFSET(LDUEDATE,1,LOAN:DUEDAY1)
       IF LMATURITYDATE<>DATENULL THEN
        LNEWMATURITYDATE=DATEOFFSET(LMATURITYDATE,1,LOAN:DUEDAY1)
      END

     ELSE IF LOAN:PAYMENTFREQUENCY=5 THEN [semimonthly]
      DO
[* if the current due date matches the loan's dueday1 value then advance to the
** dueday2 value of the same month. If the current due date matches the loan's
** dueday2 value then advance to the dueday1 value of the next month. Same
** logic goes for the new maturity date.
*]
       IF DAY(LDUEDATE)=LOAN:DUEDAY1 THEN
        LNEWDUEDATE=DATEOFFSET(LDUEDATE,0,LOAN:DUEDAY2)
       ELSE
        LNEWDUEDATE=DATEOFFSET(LDUEDATE,1,LOAN:DUEDAY1)

       IF LMATURITYDATE<>DATENULL THEN
        DO
         IF DAY(LMATURITYDATE)=LOAN:DUEDAY1 THEN
          LNEWMATURITYDATE=DATEOFFSET(LMATURITYDATE,0,LOAN:DUEDAY2)
         ELSE
          LNEWMATURITYDATE=DATEOFFSET(LMATURITYDATE,1,LOAN:DUEDAY1)
        END
      END
     ELSE IF LOAN:PAYMENTFREQUENCY=6 THEN [biweekly, skip first]
      DO
[* advance the due date by 1 payment(14 days). Get the month of the new payment. If the month of
** the new payment is the same as the month of the new payment plus 2 payments (28 days) then
** there are three payments in the month and advance the new due date by another 14 days (skipping
** what would have been the first of three payments in the month)
*]
       LNEWDUEDATE=LDUEDATE+14
       LNEWDUEMONTH=MONTH(LNEWDUEDATE)
       IF MONTH(LNEWDUEDATE+28)=LNEWDUEMONTH THEN
        DO
         LNEWDUEDATE=LNEWDUEDATE+14
        END
[* advance the maturity date by the same number of days the due date was advanced
*]
       IF LMATURITYDATE<>DATENULL THEN
        LNEWMATURITYDATE=LMATURITYDATE+(LNEWDUEDATE-LDUEDATE)
      END
     ELSE IF LOAN:PAYMENTFREQUENCY=7 THEN [biweekly, skip last]
      DO
[* advance the due date by 1 payment(14 days). Get the month of the new payment. If the month of
** the new payment is the same as the month of the new payment minus 2 payments (28 days) then
** there are three payments in the month and advance the new due date by another 14 days (skipping
** what would have been the third payment)
*]
       LNEWDUEDATE=LDUEDATE+14
       LNEWDUEMONTH=MONTH(LNEWDUEDATE)
       IF MONTH(LNEWDUEDATE-28)=LNEWDUEMONTH THEN
        DO
         LNEWDUEDATE=LNEWDUEDATE+14
        END
[* advance the maturity date by the same number of days the due date was advanced
*]
       IF LMATURITYDATE<>DATENULL THEN
        LNEWMATURITYDATE=LMATURITYDATE+(LNEWDUEDATE-LDUEDATE)
      END
     ELSE IF LOAN:PAYMENTFREQUENCY=8 THEN [biweekly]
      DO
[* advance the due date and maturity date by 1 payment(14 days).
*]
       LNEWDUEDATE=LDUEDATE+14
       IF LMATURITYDATE<>DATENULL THEN
        LNEWMATURITYDATE=LMATURITYDATE+14
      END
     ELSE IF LOAN:PAYMENTFREQUENCY=9 THEN [WEEKLY]
      DO
[* advance the due date and maturity date by 1 payment(7 days).
*]
       LNEWDUEDATE=LDUEDATE+7
       IF LMATURITYDATE<>DATENULL THEN
        LNEWMATURITYDATE=LMATURITYDATE+7
      END
     ELSE IF LOAN:PAYMENTFREQUENCY=11 THEN [weekly, skip first]
      DO
[* advance the due date by 1 payment(7 days). Get the month of the new payment. If the month of
** the new payment is the same as the month of the new payment PLUS 4 payments (28 days) then
** there are five payments in the month and advance the new due date by another 7 days (skipping
** what would have been the first of five payments for the month)
*]
       LNEWDUEDATE=LDUEDATE+7
       LNEWDUEMONTH=MONTH(LNEWDUEDATE)
       IF MONTH(LNEWDUEDATE+28)=LNEWDUEMONTH THEN
        DO
         LNEWDUEDATE=LNEWDUEDATE+7
        END
[* advance the maturity date by the same number of days the due date was advanced
*]
       IF LMATURITYDATE<>DATENULL THEN
        LNEWMATURITYDATE=LMATURITYDATE+(LNEWDUEDATE-LDUEDATE)
      END
     ELSE IF LOAN:PAYMENTFREQUENCY=12 THEN [weekly, skip last]
      DO
[* advance the due date by 1 payment(7 days). Get the month of the new payment. If the month of
** the new payment is the same as the month of the new payment MINUS 4 payments (28 days) then
** there are five payments in the month and advance the new due date by another 7 days (skipping
** what would have been the fifth of five payments for the month)
*]
       LNEWDUEDATE=LDUEDATE+7
       LNEWDUEMONTH=MONTH(LNEWDUEDATE)
       IF MONTH(LNEWDUEDATE-28)=LNEWDUEMONTH THEN
        DO
         LNEWDUEDATE=LNEWDUEDATE+7
        END
[* advance the maturity date by the same number of days the due date was advanced
*]
       IF LMATURITYDATE<>DATENULL THEN
        LNEWMATURITYDATE=LMATURITYDATE+(LNEWDUEDATE-LDUEDATE)
      END

     ELSE IF LOAN:PAYMENTFREQUENCY=13 THEN [bimonthly]
      DO
[* advance the due date and the loan maturity date by 2 months
*]
       LNEWDUEDATE=DATEOFFSET(LDUEDATE,2,LOAN:DUEDAY1)
       IF LMATURITYDATE<>DATENULL THEN
        LNEWMATURITYDATE=DATEOFFSET(LMATURITYDATE,2,LOAN:DUEDAY1)
      END
     BNODEBUGMSG=BNODEBUGMSG+FORMAT("  OLD DUE:99/99/9999",LDUEDATE)+
                             FORMAT("  NEW DUE:99/99/9999",LNEWDUEDATE)+
                             FORMAT("  OLD MAT:99/99/9999",LMATURITYDATE)+
                             FORMAT("  NEW MAT:99/99/9999",LNEWMATURITYDATE)
     CALL  BNODEBUGMSGADD
    END
   ELSE [Next due date cals is 1 month / 28 days]
    DO
[* new due dates and maturity dates in this section are calculated at 28 days
** for weekly/biweekly loan types of 1 month for all others
*]
     IF CHARACTERSEARCH("06,07,08,09,11,12",FORMAT("99",LOAN:PAYMENTFREQUENCY))>0 THEN
      DO
       LNEWDUEDATE=LDUEDATE+28

       IF LMATURITYDATE<>DATENULL THEN
        LNEWMATURITYDATE=LMATURITYDATE+28


[* Check for skip first, skip last for freqs. 6,7,11,12 and adjusting due date
** by one payment cycle (plus 2 weeks for freqs. 6 or 7, plus 1 week for freqs. 11 or 12 IF
** the new payment due falls into the skip first/skip last scenario. Maturity date will also be
** adjusted accordingly
*]
       IF HONORSKIPS=TRUE THEN
        DO
         IF LOAN:PAYMENTFREQUENCY=6 THEN [Biweekly, skip first]
          DO
           LNEWDUEMONTH=MONTH(LNEWDUEDATE)
           IF MONTH(LNEWDUEDATE+28)=LNEWDUEMONTH THEN
            DO
             LNEWDUEDATE=LNEWDUEDATE+14
             IF LMATURITYDATE<>DATENULL THEN
              LNEWMATURITYDATE=LNEWMATURITYDATE+14
            END
          END
         ELSE IF LOAN:PAYMENTFREQUENCY=7 THEN [Biweekly, skip last]
          DO
           LNEWDUEMONTH=MONTH(LNEWDUEDATE)
           IF MONTH(LNEWDUEDATE-28)=LNEWDUEMONTH THEN
            DO
             LNEWDUEDATE=LNEWDUEDATE+14
             IF LMATURITYDATE<>DATENULL THEN
              LNEWMATURITYDATE=LNEWMATURITYDATE+14
            END
          END
         ELSE IF LOAN:PAYMENTFREQUENCY=11 THEN [Weekly, skip first]
          DO
           LNEWDUEMONTH=MONTH(LNEWDUEDATE)
           IF MONTH(LNEWDUEDATE+28)=LNEWDUEMONTH THEN
            DO
             LNEWDUEDATE=LNEWDUEDATE+7
             IF LMATURITYDATE<>DATENULL THEN
              LNEWMATURITYDATE=LNEWMATURITYDATE+7
            END
          END
         ELSE IF LOAN:PAYMENTFREQUENCY=12 THEN [Weekly, skip last]
          DO
           LNEWDUEMONTH=MONTH(LNEWDUEDATE)
           IF MONTH(LNEWDUEDATE-28)=LNEWDUEMONTH THEN
            DO
             LNEWDUEDATE=LNEWDUEDATE+7
             IF LMATURITYDATE<>DATENULL THEN
              LNEWMATURITYDATE=LNEWMATURITYDATE+7
            END
          END
        END [IF HONORSKIPS=TRUE]
       BNODEBUGMSG="Evaluating LOAN "+LID+" by 28 day - "+FORMAT("Freq=99",LOAN:PAYMENTFREQUENCY)+
                    FORMAT("  OLD DUE:99/99/9999",LDUEDATE)+
                    FORMAT("  NEW DUE:99/99/9999",LNEWDUEDATE)+
                    FORMAT("  OLD MAT:99/99/9999",LMATURITYDATE)+
                    FORMAT("  NEW MAT:99/99/9999",LNEWMATURITYDATE)
       CALL  BNODEBUGMSGADD
      END
     ELSE
      DO
       IF LOAN:PAYMENTFREQUENCY=5 THEN
        DO
         IF DAY(LDUEDATE)>LOAN:DUEDAY1 THEN
          LNEWDUEDATE=DATEOFFSET(LOAN:DUEDATE,1,LOAN:DUEDAY2)
         ELSE
          LNEWDUEDATE=DATEOFFSET(LOAN:DUEDATE,1,LOAN:DUEDAY1)
        END
       ELSE
        LNEWDUEDATE=DATEOFFSET(LDUEDATE,1,LOAN:DUEDAY1)

       IF LMATURITYDATE<>DATENULL THEN
        DO
         IF LOAN:PAYMENTFREQUENCY=5 THEN
          DO
           IF DAY(LMATURITYDATE)>LOAN:DUEDAY1 THEN
            LNEWMATURITYDATE=DATEOFFSET(LMATURITYDATE,1,LOAN:DUEDAY2)
           ELSE
            LNEWMATURITYDATE=DATEOFFSET(LMATURITYDATE,1,LOAN:DUEDAY1)
          END
         ELSE
          LNEWMATURITYDATE=DATEOFFSET(LMATURITYDATE,1,LOAN:DUEDAY1)
        END
       BNODEBUGMSG="Evaluating LOAN "+LID+" by std month - "+FORMAT("Freq=99",LOAN:PAYMENTFREQUENCY)+
                   FORMAT("  OLD DUE:99/99/9999",LDUEDATE)+
                   FORMAT("  NEW DUE:99/99/9999",LNEWDUEDATE)+
                   FORMAT("  OLD MAT:99/99/9999",LMATURITYDATE)+
                   FORMAT("  NEW MAT:99/99/9999",LNEWMATURITYDATE)
       CALL  BNODEBUGMSGADD
      END
    END
  END
END [PROCEDURE]

[
  This procedure extracts the next LID from the LIDLIST. The
  LIDLIST will be modified not to include the loan ID.

  PASS:   LIDLIST

  RETURN: LIDLIST
          LID
]
PROCEDURE GETNEXTLID

 COMMAPOS=CHARACTERSEARCH(LIDLIST,",")
 IF COMMAPOS>0 THEN
  DO
   LID=SEGMENT(LIDLIST,1,COMMAPOS-1)
   LIDLIST=SEGMENT(LIDLIST,COMMAPOS+1,LENGTH(LIDLIST))
  END
 ELSE
  DO
   LID=LIDLIST
   LIDLIST=""
  END

 TEXT1=LID
 CALL TEXTNLS
 LID=TEXT1
END [PROCEDURE]

PROCEDURE TEXTNLS
[* Remove leading spaces from a text string.
** PASS:   TEXT1     The string to trim
** RETURN: TEXT1     The trimmed string
*]
 TT=1
 TEXTFOUND=FALSE
 WHILE (TT<=LENGTH(TEXT1) AND TEXTFOUND=FALSE)
  DO
   IF SEGMENT(TEXT1,TT,TT)<>" " THEN
    TEXTFOUND=TRUE
   ELSE
    TT=TT+1
  END
 IF TT>1 THEN
  TEXT1=SEGMENT(TEXT1,TT,LENGTH(TEXT1))
END [PROCEDURE]

PROCEDURE TEXTNTS
[* Remove trailing spaces from a text string.
** PASS:   TEXT1     The string to trim
** RETURN: TEXT1     The trimmed string
*]
 TT=LENGTH(TEXT1)
 TEXTFOUND=FALSE
 WHILE (TT>0 AND TEXTFOUND=FALSE)
  DO
   IF SEGMENT(TEXT1,TT,TT)<>" " THEN
    TEXTFOUND=TRUE
   ELSE
    TT=TT-1
  END
 TEXT1=SEGMENT(TEXT1,1,TT)
END [PROCEDURE]

PROCEDURE TEXTNLTS
[* Remove leading & trailing spaces from a text string.
** PASS:   TEXT1     The string to trim
** RETURN: TEXT1     The trimmed string
*]
 CALL TEXTNLS
 CALL TEXTNTS
END [PROCEDURE]

PROCEDURE CLEANUPTEXT
[* Check character string and remove out any characters or hidden
** characters which have an ASCII value which is not established in
** the VALIDCHRINPUT1 string in the SETUP division . This is to avoid
** display issues with displaying the terms or conditions. Additionally,
** if a back-slash or double quote is encountered, add a preceding
** backslash
**  PASS       TMPCHR   String to test
**  RETURN     TMPCHR   Updated string
*]
 LELISTINPUT=VALIDCHRINPUT1
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO MAXCHRVALUE
  DO
   VALIDCHARS(TMPLOOP)=LELIST(TMPLOOP)
  END
 TMPTEXT=""

 IF TMPCHR<>"" THEN
  DO
   FOR TMPTEXTLOOP=1 TO LENGTH(TMPCHR)
    DO
     CHRVAL=CHRVALUE(SEGMENT(TMPCHR,TMPTEXTLOOP,TMPTEXTLOOP))
     IF  VALIDCHARS(CHRVAL)=TRUE THEN
      DO
[* Check for back-slash or double-quote. If found, precede with a back-slash
*]
       IF (CHRVAL=92 OR CHRVAL=34) THEN
        TMPTEXT=TMPTEXT+"\"+SEGMENT(TMPCHR,TMPTEXTLOOP,TMPTEXTLOOP)
       ELSE
        TMPTEXT=TMPTEXT+SEGMENT(TMPCHR,TMPTEXTLOOP,TMPTEXTLOOP)
      END
    END
  END
 TMPCHR=TMPTEXT
END [PROCEDURE]

PROCEDURE BNOPRINTPROGRAMINFO
[* Print program info to direct JSON output
**
**  PASS    BNOPROGRAMNAME     Program name
**  PASS    BNOPROGRAMVERSION  Program version
**  PASS    BNOLASTMODDATE     Last mod date
**  PASS    BNOLASTMODTIME     Last mod time
*]
 IF READCONFIGERROR=FALSE THEN
  PRINT BNOINDENT(1)+","
 NEWLINE
 PRINT BNOINDENT(1)+Q+"programInfo"+Q+":"+Q+
                    BNOPROGRAMNAME+"  "+
                    BNOPROGRAMVERSION+"  "+
                    FORMAT("99/99/99 ",BNOLASTMODDATE)+"  "+
                    "TESTMODE:"+TRUEFALSECHR(TESTMODE)+"  "+
                    "TESTACCT:"+TRUEFALSECHR(VALIDTESTACCOUNT)+Q
END [PROCEDURE]

PROCEDURE BNOPRINTRGDATA
[* Print @RGUSER[CHR,NUM] data passed from the UX in proper JSON format
**
**  PASS    DEBUGMODE        Boolean: Print debug data, T/F
*]

 IF BNODEBUGMODE=BNODEBUGMODEON THEN
  DO

   PRINT ","
   NEWLINE
   PRINT BNOINDENT(1)+Q+"rgData"+Q+": ["
   NEWLINE
   PRINT BNOINDENT(2)+Q+"CHR1:'"+@RGUSERCHR1+"' "+
                     "CHR2:'"+@RGUSERCHR2+"'"+Q+","
   NEWLINE
   PRINT BNOINDENT(2)+Q+"CHR3:'"+@RGUSERCHR3+"' "+
                     "CHR4:'"+@RGUSERCHR4+"'"+Q+","

   NEWLINE
   PRINT BNOINDENT(2)+Q+"CHR5:'"+@RGUSERCHR5+"' "+
                     "NUM1:"+FORMAT("#########9 ",@RGUSERNUM1)+
                     "NUM2:"+FORMAT("#########9 ",@RGUSERNUM2)+
                     "NUM3:"+FORMAT("#########9 ",@RGUSERNUM3)+
                     "NUM4:"+FORMAT("#########9 ",@RGUSERNUM4)+
                     "NUM5:"+FORMAT("#########9",@RGUSERNUM5)+Q
   NEWLINE
   PRINT BNOINDENT(1)+"]"
   NEWLINE
  END
END [PROCEDURE]

PROCEDURE BNODEBUGMSGADD
[* Add a message line to the debug message array
**
** PASS    BNODEBUGMSGMAX     Current array index max lines allowed
** PASS    BNODEBUGMSG        Debug message to add to array
**
** RETURN  BNODEBUGCOUNT      Count of debug message lines
** RETURN  BNODEBUGMSGLIST(A) Debug lines of data to print
*]
 IF BNODEBUGCOUNT<BNODEBUGMSGMAX THEN
  DO
   BNODEBUGCOUNT=BNODEBUGCOUNT+1
   BNODEBUGMSGLIST(BNODEBUGCOUNT)=SEGMENT(BNODEBUGMSG,1,120)
   BNODEBUGMSG=""
  END
END [PROCEDURE]

PROCEDURE BNOPRINTDEBUG
[* Print debug output in proper JSON format. Requires DEBUGMODE to be
** on (or true).
**
**  PASS  DEBUGMODE           Boolean: Print debug data, T/F
**  PASS  BNODEBUGMSGLIST(A)  Array of debug messages to print
**  PASS  BNODEBUGCOUNT       Number of debug lines to print
*]

 IF BNODEBUGMODE=BNODEBUGMODEON THEN
  DO
   PRINT ","
   NEWLINE
   PRINT BNOINDENT(2)+Q+"debugData"+Q+": ["
   NEWLINE
   PRINT BNOINDENT(2)+Q+"Debug note: Debug lines truncated to 120 characters"+Q
   IF BNODEBUGCOUNT>0 THEN
    DO
     FOR BNODEBUGLOOP=1 TO BNODEBUGCOUNT
      DO
       PRINT ","
       NEWLINE
       PRINT BNOINDENT(3)+Q+SEGMENT(BNODEBUGMSGLIST(BNODEBUGLOOP),1,120)+Q
      END [FOR BNODEBUGLOOP=1 TO BNODEBUGCOUNT]
    END [IF BNODEBUGCOUNT>0 THEN]
   PRINT BNOINDENT(2)+"]"
   NEWLINE
  END
END [PROCEDURE]

#INCLUDE "RB.LISTEXPAND"


