[*
**  PowerOn Name:       BANNO.ODTOPTIN.V1.POW
**  Letterfile Name:    BANNO.ODTOPTIN.V1.CFG
**
**  Copyright 2020-2023 Jack Henry and Associates
**
**  This Banno service PowerOn allows the user to Opt-In or Opt-out
**  of the Reg-E overdraft service
**
**  For more information check
**  https://github.com/Banno/banno-powerons
**
**  Banno is not responsible for any modifications to this file
**  made by unauthorized personnel.
**
**  Modification History:
**    Ver. 1.0.0  07/14/20 T. Kainz - Original Programming
**    Ver. 1.0.1  09/18/20 T. Kainz - Corrected end of line spacing for disclosures
**    Ver. 1.0.2  02/11/21 T. Kainz - Mod to terms, Discl & revoke inst.to allow for
**                         blank line. Added program info to JSON output.
**    Ver. 1.0.3  09/03/21 T. Kainz - Increased the TOC and Disclosure lines max to
**                         999 and the revoke instructions to 99.
**    Ver. 1.0.4  07/29/22 R. Robison - Added Service Instructions, Opt-in information
**                         and Opt-out information soft text.  Added feature for setting
**                         Overdraw Tolerance field on share record.
**    Ver. 1.1.0  06/12/23 R. Robison - Added opt-in/opt-out information soft text 
**    Ver. 1.1.1  08/04/23 T. Kainz - Corrected faulty JSON when debug mode is turned on
**                         Added additional debug output to facilitate troubleshooting.
**
**  DO NOT MODIFY THIS FILE UNLESS YOU KNOW WHAT YOU'RE DOING!
*]

SYMCONNECT
STATELESS

TARGET=ACCOUNT

DEFINE
 #INCLUDE "RD.GETDATA.DEF"
 #INCLUDE "RB.LISTEXPAND.DEF"

 TRUE                         = 1
 FALSE                        = 0
 FMUNCHANGED                  = 0
 FMSUCCESSFUL                 = 1
 FMUNSUCCESSFUL               = 2
 CONFIGFILENAME               = "BANNO.ODTOPTIN.V1.CFG"
 STATEPRELOADDATA             = "PRELOADDATA"
 STATEPROCESSDATA             = "PROCESSDATA"
 STATEEND                     = "STATEEND"
 DATENULL                     = '--/--/--'
 VALIDSOURCECODELIST          = "ABCDEFGHIJKLNOPRSTVW"


 PROGRAMNAME                  = CHARACTER
 PROGRAMVERSION               = CHARACTER
 LASTMODDATE                  = DATE
 LASTMODTIME                  = CHARACTER

 LFNUMBER                     = NUMBER
 LFERROR                      = CHARACTER
 LFLINE                       = CHARACTER
 READCONFIGERROR              = NUMBER
 READCONFIGERRORMSG           = CHARACTER
 PARAMINDEX                   = NUMBER
 PARAMFOUND                   = NUMBER

 PARAMINELIGIBLEACCTS         = CHARACTER
 PARAMVALIDSHARETYPES         = CHARACTER
 PARAMWARNINGSACCT            = CHARACTER
 PARAMWARNINGSSHARE           = CHARACTER
 PARAMSHARETRACKING           = NUMBER
 PARAMUPDATEANDF              = NUMBER
 PARAMSC1TRUE                 = CHARACTER
 PARAMSC1FALSE                = CHARACTER
 PARAMAF1TRUE                 = NUMBER
 PARAMAF1FALSE                = NUMBER
 PARAMCUSTOMTERMS             = CHARACTER(126) ARRAY(999)
 PARAMCUSTOMTERMLINES         = NUMBER
 PARAMFEEDISCL                = CHARACTER(126) ARRAY(999)
 PARAMFEEDISCLLINES           = NUMBER
 PARAMCUSTOMTERMLINESMAX      = 999
 PARAMREVOKEINST              = CHARACTER(126) ARRAY(99)
 PARAMREVOKEINSTLINES         = NUMBER
 PARAMREVOKEINSTLINESMAX      = 99
 PARAMSERVICEINST             = CHARACTER(126) ARRAY(99)
 PARAMSERVICEINSTLINES        = NUMBER
 PARAMSERVICEINSTLINESMAX     = 99
 PARAMOPTININFOTEXT           = CHARACTER(126) ARRAY(99)
 PARAMOPTININFOTEXTLINES      = NUMBER
 PARAMOPTININFOTEXTLINESMAX   = 99
 PARAMOPTOUTINFOTEXT          = CHARACTER(126) ARRAY(99)
 PARAMOPTOUTINFOTEXTLINES     = NUMBER
 PARAMOPTOUTINFOTEXTLINESMAX  = 99
 PARAMOTAAMOUNT               = MONEY ARRAY(99)
 PARAMOTASHARETYPE            = NUMBER ARRAY(99)
 PARAMOTACOUNT                = NUMBER
 PARAMOTAMAX                  = 99
 PARAMOPTINOUTINFOTEXT        = CHARACTER ARRAY(10)
 PARAMOPTINOUTINFOTEXTLINES   = NUMBER
 PARAMOPTINOUTINFOTEXTLINESMAX= 10 
 PARAMNAME                    = CHARACTER
 PARAMVALUE                   = CHARACTER
 PARAMVALIDATIONERROR         = NUMBER
 PARAMVALIDATIONERRORCHR      = CHARACTER
 INVALIDACCTYPES              = NUMBER ARRAY(9999)
 VALIDSHARETYPES              = NUMBER ARRAY(9999)
 WARNINGSACCT                 = NUMBER ARRAY(999)
 WARNINGSSHARE                = NUMBER ARRAY(999)
 SLAWARNINGFOUND              = NUMBER
 INVALIDACCTTYPEFOUND         = NUMBER
 TMPLOOP                      = NUMBER
 TMPCHR                       = CHARACTER
 POS                          = NUMBER
 Q                            = CHARACTER
 BACKSLASH                    = CHARACTER
 MEMBERNUM                    = CHARACTER
 SLTYPE                       = CHARACTER
 SLID                         = CHARACTER
 FOUND                        = NUMBER
 ERRORCODE                    = NUMBER
 ERRORMSG                     = CHARACTER
 ERRORDETAIL                  = CHARACTER ARRAY(99)
 ERRORDETAILOFFSET            = NUMBER
 IDLENGTH                     = NUMBER
 MAXWARNINGTYPES              = NUMBER
 MAXSLTYPES                   = NUMBER
 TMPTEXT                      = CHARACTER
 TMPTEXTLOOP                  = NUMBER
 CHR                          = NUMBER
 SYSTEMMEMOMODE               = NUMBER

 SDMAX                        = NUMBER
 SDCOUNT                      = NUMBER
 SDOVERMAX                    = NUMBER
 SDID                         = CHARACTER(4) ARRAY(132)
 SDTYPE                       = NUMBER ARRAY(132)
 SDNAME                       = CHARACTER(40) ARRAY(132)
 SDBALANCE                    = MONEY ARRAY(132)
 SDODTSTATUS                  = NUMBER ARRAY(132)
 SDODTNEWSTATUS               = NUMBER ARRAY(132)
 SDODTTRACKINGLOC             = NUMBER ARRAY(132)
 SDTRACKINGUPDATE             = NUMBER ARRAY(132)
 SDAUTHFEEUPDATE              = NUMBER ARRAY(132)
 SDOVERDRAFTTOLERANCE         = MONEY ARRAY(132)

 SNSHARELIST                  = CHARACTER ARRAY(9)
 SHARELISTINDEX               = NUMBER
 SHARELIST                    = CHARACTER
 COMMAPOS                     = NUMBER
 SLIDLEN                      = NUMBER
 FMERROR                      = CHARACTER
 NEWSTATUS                    = NUMBER
 FMTRACKINGLOCATOR            = NUMBER
 TEMPLOC                      = NUMBER
 NEWSOURCECODE1               = CHARACTER
 NEWAUTFEEOPTION1             = NUMBER
 INVALIDCONFIGPARAMS          = NUMBER
 BOOLEANCHR                   = CHARACTER ARRAY(1)
 CHRVAL                       = NUMBER
 FMRESULTSCHR                 = CHARACTER ARRAY(3)
 VALIDCHRINPUT1               = CHARACTER
 VALIDCHARS                   = NUMBER ARRAY(999)
 MAXCHRVALUE                  = 255
 FMUPDATEERRORTRACKING        = NUMBER
 FMUPDATEERRORAUTHFEE         = NUMBER
 FMUPDATEERRORODTAMOUNT       = NUMBER
 LASTSID                      = CHARACTER
 COLONPOS                     = NUMBER
 NEWODTAMOUNT                 = MONEY

[* Added 08/04/23*]
 BNODEBUGMODEOFF              = 0
 BNODEBUGMODEON               = 1
 BNODEBUGMODE                 = NUMBER
 BNODEBUGLOOP                 = NUMBER
 BNODEBUGCOUNT                = NUMBER
 BNODEBUGMSGLIST              = CHARACTER ARRAY(2400)
 BNODEBUGMSGMAX               = 2400
 BNODEBUGMSG                  = CHARACTER
 BNOINDENTMAX                 = 9
 BNOLOCALLOOP                 = NUMBER
 BNOINCLUDEPARMINDEBUG        = NUMBER
 BNOINCLUDERGDATAINDEBUG      = NUMBER
 BNOINDENT                    = CHARACTER ARRAY(9)
 SHAREINVALIDREASON           = CHARACTER
END [DEFINE]

SETUP
 PROGRAMNAME="BANNO.ODTOPTIN.V1.POW"
 PROGRAMVERSION="1.1.1"
 LASTMODDATE='08/04/23'
 LASTMODTIME="12:30 MT"

 Q=CTRLCHR(34)
 BACKSLASH=CTRLCHR(92)
 BNOINCLUDEPARMINDEBUG=TRUE
 BNOINCLUDERGDATAINDEBUG=TRUE

 IF LASTMODDATE+90>SYSTEMDATE THEN
  BNODEBUGMODE=BNODEBUGMODEON
 ELSE
  BNODEBUGMODE=BNODEBUGMODEOFF

 FOR BNOLOCALLOOP=1 TO BNOINDENTMAX
  DO
   BNOINDENT(BNOLOCALLOOP)=REPEATCHR(" ",BNOLOCALLOOP)
  END

[* Set SDMAX to 130 for production. Pass back any lower number >0 in the
** @RGUSERNUM1 field for testing or limiting program to lower values
*]
 SDMAX=130
 IF @RGUSERNUM1>0 THEN
  SDMAX=@RGUSERNUM1

 IDLENGTH=GETDATANUMBER(GETPARAMIDLENGTH)
 IF IDLENGTH=2 THEN
  MAXSLTYPES=99
 ELSE
  MAXSLTYPES=9999
 MAXWARNINGTYPES=999

 FMRESULTSCHR(FMSUCCESSFUL)="true"
 FMRESULTSCHR(FMUNSUCCESSFUL)="false"
 FMRESULTSCHR(FMUNCHANGED)="null"
 BOOLEANCHR(FALSE)="false"
 BOOLEANCHR(TRUE)="true"

 SLIDLEN=GETDATANUMBER(GETPARAMIDLENGTH)
 VALIDCHRINPUT1="32-126,128-175,181-184,189,190,198,199,208-216,221,222,224-253"
END [SETUP]

PRINT TITLE="BANNO.TEMPLATE.V1.POW"
[* STATE             OVERVIEW
** ----------------  -----------------------------------------------------------
** STATEPRELOADDATA  Present the user with a list of valid shares along with
**                   their current balance and ODT status.
** PROCESSDATA       Receive user input, update share and share tracking as
**                   needed and return a list of shares changed and new status.
**
*]
 CALL INITIALIZEDATA
 CALL VALIDATESYSMEMOMODE

 IF @RGSTATE<>STATEEND THEN
  CALL READCONFIGFILESETTINGS

 IF @RGSTATE<>STATEEND THEN
  CALL VALIDATEACCOUNT

 IF @RGSTATE<>STATEEND THEN
  DO
   NEWLINE
   IF @RGSTATE=STATEPRELOADDATA THEN
    DO
     CALL POLLSHARES
     IF ERRORCODE=0 THEN
      DO
       IF SDCOUNT=0 THEN
        DO
         ERRORCODE=503
         CALL JSONOPEN
         CALL ERRORHANDLER
         @RGSTATE=STATEEND
        END
       ELSE
        DO
         CALL PRINTSHAREDETAIL
        END
      END
    END
   IF @RGSTATE=STATEPROCESSDATA THEN
    DO
     CALL POLLSHARES
     CALL SETSESSIONVARS
     CALL SETSNSHARELISTSELECTED
     FOR TMPLOOP=1 TO SDCOUNT
      DO
       BNODEBUGMSG=FORMAT("99: ",TMPLOOP)+
                  "  SID:"+SDID(TMPLOOP)+
                   FORMAT("  SDODTTRACKINGLOC:999",SDODTTRACKINGLOC(TMPLOOP))+
                   FORMAT("  SDODTSTATUS:99",SDODTSTATUS(TMPLOOP))+
                   FORMAT("  SDODTNEWSTATUS:99",SDODTNEWSTATUS(TMPLOOP))
       CALL BNODEBUGMSGADD
      END

     CALL UPDATERECORDS

     IF FMUPDATEERRORTRACKING=TRUE OR
        FMUPDATEERRORAUTHFEE=TRUE OR
        FMUPDATEERRORODTAMOUNT=TRUE THEN
      DO
       IF FMUPDATEERRORTRACKING=TRUE THEN
        ERRORCODE=506
       ELSE IF FMUPDATEERRORAUTHFEE=TRUE THEN
        ERRORCODE=507
       ELSE IF FMUPDATEERRORODTAMOUNT=TRUE THEN    
        ERRORCODE=508 

       CALL JSONOPEN
       CALL ERRORHANDLER
      END
     ELSE
      DO
       IF (SDODTSTATUS(TMPLOOP)<>SDODTNEWSTATUS(TMPLOOP)) OR
           SDODTTRACKINGLOC(TMPLOOP)=0 THEN
        DO
         CALL PRINTSHAREDETAIL
        END
      END
    END
  END

 CALL BNOPRINTRGDATA
 CALL BNOPRINTDEBUG
 IF BNODEBUGMODE=BNODEBUGMODEOFF THEN
  DO
   NEWLINE
  END
 CALL JSONCLOSE
END [PRINT]

PROCEDURE PRINTSHAREDETAIL
[* Loop through array of eligible shares and print properly formatted
** JSON for each share. If in state PRELOADDATA, include the terms and
** conditions, fee disclosure and revocation instructions
*]

 PRINT "{"
 NEWLINE

 CALL PRINTPROGRAMINFO

 PRINT "  "+Q+"memoMode"+Q+":  false,"
 NEWLINE
 PRINT "  "+Q+"results"+Q+": {"
 NEWLINE
 PRINT "  "+Q+"maxSharesExceeded"+Q+": "
 IF SDOVERMAX=TRUE THEN
  PRINT "true,"
 ELSE
  PRINT "false,"
 NEWLINE
 IF @RGSTATE=STATEPRELOADDATA THEN
  PRINT "  "+Q+"shareDetail"+Q+": ["
 ELSE
  PRINT "  "+Q+"shareDetailUpdated"+Q+": ["
 LASTSID=""
 FOR TMPLOOP=1 TO SDCOUNT
  DO
   IF SDID(TMPLOOP)<>"" AND
     (@RGSTATE=STATEPRELOADDATA OR
     (@RGSTATE=STATEPROCESSDATA AND
      SDODTSTATUS(TMPLOOP)<>SDODTNEWSTATUS(TMPLOOP))) THEN
    DO
     LASTSID=SDID(TMPLOOP)
    END
  END
 FOR TMPLOOP=1 TO SDCOUNT
  DO
   IF SDID(TMPLOOP)<>"" AND
     (@RGSTATE=STATEPRELOADDATA OR
     (@RGSTATE=STATEPROCESSDATA AND
      SDODTSTATUS(TMPLOOP)<>SDODTNEWSTATUS(TMPLOOP))) THEN
    DO
     NEWLINE
     CALL JSONOPEN
     PRINT "   "+Q+"SID"+Q+": "+Q+SDID(TMPLOOP)+Q+","
     NEWLINE
     PRINT "   "+Q+"name"+Q+": "+Q+SDNAME(TMPLOOP)+Q+","
     NEWLINE
     TMPCHR=FORMAT("######9.99+",SDBALANCE(TMPLOOP))
     CALL NLS
     PRINT "   "+Q+"balance"+Q+": "+Q+TMPCHR+Q+","
     NEWLINE
     PRINT "   "+Q+"currentState"+Q+": "
     IF @RGSTATE=STATEPRELOADDATA THEN
      DO
       IF SDODTSTATUS(TMPLOOP)=TRUE THEN
        PRINT "true"
       ELSE
        PRINT "false"
      END
     ELSE
      DO
       IF SDODTNEWSTATUS(TMPLOOP)=TRUE THEN
        PRINT "true"
       ELSE
        PRINT "false"
      END
     NEWLINE
     PRINT "}"
     IF SDID(TMPLOOP)<>LASTSID THEN
      PRINT ","
     NEWLINE
    END
  END  [FOR TMPLOOP=1 TO SDCOUNT]
 PRINT "]"
 IF @RGSTATE=STATEPRELOADDATA THEN
  DO
   PRINT ","
   NEWLINE
   PRINT Q+"terms"+Q+": ["
   NEWLINE
   FOR TMPLOOP=1 TO PARAMCUSTOMTERMLINES
    DO
     PRINT Q+PARAMCUSTOMTERMS(TMPLOOP)+Q
     IF TMPLOOP<PARAMCUSTOMTERMLINES THEN
      PRINT ","
     NEWLINE
    END
   PRINT "],"
   NEWLINE

   PRINT Q+"feeDisclosure"+Q+": ["
   NEWLINE
   FOR TMPLOOP=1 TO PARAMFEEDISCLLINES
    DO
     PRINT Q+PARAMFEEDISCL(TMPLOOP)+Q
     IF TMPLOOP<PARAMFEEDISCLLINES THEN
      PRINT ","
     NEWLINE
    END
   PRINT "],"
   NEWLINE
   
   PRINT Q+"revocationInstructions"+Q+": ["
   NEWLINE
   FOR TMPLOOP=1 TO PARAMREVOKEINSTLINES
    DO
     PRINT Q+PARAMREVOKEINST(TMPLOOP)+Q
     IF TMPLOOP<PARAMREVOKEINSTLINES THEN
      PRINT ","
     NEWLINE
    END
   PRINT "],"
   NEWLINE

   PRINT Q+"servicesInstructions"+Q+": ["
   NEWLINE
   FOR TMPLOOP=1 TO PARAMSERVICEINSTLINES
    DO
     PRINT Q+PARAMSERVICEINST(TMPLOOP)+Q
     IF TMPLOOP<PARAMSERVICEINSTLINES THEN
      PRINT ","
     NEWLINE
    END
   PRINT "],"
   NEWLINE

   IF PARAMOPTINOUTINFOTEXTLINES>0 THEN 
    DO
     PRINT Q+"optInOutInfoText"+Q+": ["
     NEWLINE
     FOR TMPLOOP=1 TO PARAMOPTINOUTINFOTEXTLINES
      DO
       PRINT Q+PARAMOPTINOUTINFOTEXT(TMPLOOP)+Q
       IF TMPLOOP<PARAMOPTINOUTINFOTEXTLINES THEN
        PRINT ","
       NEWLINE
      END
     PRINT "],"
     NEWLINE
    END 

   PRINT Q+"optInInformationText"+Q+": ["
   NEWLINE
   FOR TMPLOOP=1 TO PARAMOPTININFOTEXTLINES
    DO
     PRINT Q+PARAMOPTININFOTEXT(TMPLOOP)+Q
     IF TMPLOOP<PARAMOPTININFOTEXTLINES THEN
      PRINT ","
     NEWLINE
    END
   PRINT "],"
   NEWLINE

   PRINT Q+"optOutInformationText"+Q+": ["
   NEWLINE
   FOR TMPLOOP=1 TO PARAMOPTOUTINFOTEXTLINES
    DO
     PRINT Q+PARAMOPTOUTINFOTEXT(TMPLOOP)+Q
     IF TMPLOOP<PARAMOPTOUTINFOTEXTLINES THEN
      PRINT ","
     NEWLINE
    END
   PRINT "]"
   NEWLINE      
  END
 CALL JSONCLOSE
END [PROCEDURE]

PROCEDURE POLLSHARES
[* Create list of eligible shares. For each eigible share found, call
** procedure to add the share to the list.
*]
 WHILELIMIT=1000000
 SDCOUNT=0
 FOR TMPLOOP=0 TO SDMAX
  DO
   SDID(TMPLOOP)=""
   SDTYPE(TMPLOOP)=-1
   SDNAME(TMPLOOP)=""
   SDBALANCE(TMPLOOP)=$0.00
   SDODTSTATUS(TMPLOOP)=FALSE
   SDODTNEWSTATUS(TMPLOOP)=FALSE
   SDODTTRACKINGLOC(TMPLOOP)=0
   SDTRACKINGUPDATE(TMPLOOP)=FMUNCHANGED
   SDAUTHFEEUPDATE(TMPLOOP)=0
   SDOVERDRAFTTOLERANCE(TMPLOOP)=$0.00
  END
 
 FOR EACH SHARE
  DO
   SHAREINVALIDREASON=""
   IF SHARE:CLOSEDATE<>DATENULL THEN
    SHAREINVALIDREASON="Share closed"
   ELSE IF SHARE:CHARGEOFFDATE<>DATENULL THEN
    SHAREINVALIDREASON="Share Charged-off"
   ELSE IF VALIDSHARETYPES(SHARE:TYPE)=FALSE THEN
    SHAREINVALIDREASON="Invalid Share Type"
   ELSE IF SHARE:SHARECODE=2 THEN
    SHAREINVALIDREASON="Cert (Share Code 2)"
   ELSE
    DO
     CALL TESTFORSHAREWARNING
     IF SLAWARNINGFOUND=TRUE THEN
      SHAREINVALIDREASON="Share Warning"
     ELSE
      CALL ADDSHARETOLIST
    END
   IF SHAREINVALIDREASON<>"" THEN
    BNODEBUGMSG="Testing Share ID "+SHARE:ID+": Invalid - "+SHAREINVALIDREASON
   ELSE
    BNODEBUGMSG="Testing Share ID "+SHARE:ID+": Valid - Added"
   CALL BNODEBUGMSGADD
  END
END [PROCEDURE]

PROCEDURE TESTFORSHAREWARNING
[* Test share for targeted warning(s)
*]
 SLAWARNINGFOUND=FALSE
 FOR TMPLOOP=1 TO MAXWARNINGTYPES
  DO
   IF ANYWARNING(SHARE,TMPLOOP) AND
      WARNINGSSHARE(TMPLOOP)=TRUE THEN
    DO
     SLAWARNINGFOUND=TRUE
     TMPLOOP=MAXWARNINGTYPES
    END
  END
END [PROCEDURE]

PROCEDURE ADDSHARETOLIST
[* Increment share counter. If max shares have been reached then
** set flag, else add share to list. Current share ODT status is
** found in share tracking. The first unexpired share tracking found
** will be used.
*]
 SDCOUNT=SDCOUNT+1
 IF SDCOUNT>SDMAX THEN
  SDOVERMAX=TRUE
 ELSE
  DO
   TMPCHR=SHARE:DESCRIPTION
   CALL CLEANUPTEXT

   SDID(SDCOUNT)=SHARE:ID
   SDTYPE(SDCOUNT)=SHARE:TYPE
   SDNAME(SDCOUNT)=TMPCHR
   SDBALANCE(SDCOUNT)=SHARE:AVAILABLEBALANCE
   SDOVERDRAFTTOLERANCE(SDCOUNT)=SHARE:OVERDRAFTTOLERANCE
   FOR EACH SHARE TRACKING WITH (SHARE TRACKING:TYPE=PARAMSHARETRACKING AND
                                (SHARE TRACKING:EXPIREDATE=DATENULL OR
                                 SHARE TRACKING:EXPIREDATE>SYSTEMDATE) AND
                                 SDODTTRACKINGLOC(SDCOUNT)=0)
    DO
     SDODTTRACKINGLOC(SDCOUNT)=SHARE TRACKING:LOCATOR
     SDODTSTATUS(SDCOUNT)=SHARE TRACKING:USERCODE1
    END
  END
END [PROCEDURE]

PROCEDURE READCONFIGFILESETTINGS
[* Read parameter settings from the configuration Letter file.
**  IAT PARAMINELIGIBLEACCTS  Ineligible Account Type(s) (in LISTEXPAND format)
**  TRK PARAMSHARETRACKING    The Share tracking type used for ODT tracking
**  ST  PARAMVALIDSHARETYPES  Char list of valid Share types (in LISTEXPAND format)
**  AW  PARAMWARNINGSACCT     Acct level warnings which exclude account (in LISTEXPAND format)
**  SW  PARAMWARNINGSSHARE    Share warnings which exclude share (in LISTEXPAND format)
**  UD  PARAMUPDATEANDF       Should the program update the AUTHFEEOPTION:1 and ODTAUTHFEESRCCODELIST:1 fields
**  SCT PARAMSC1TRUE          Source code 1 value if opt-in = true
**  SCF PARAMSC1FALSE         Source code 1 value if opt-in = false
**  AFT PARAMAF1TRUE          Auth & fee 1 value if opt-in = true
**  AFF PARAMAF1FALSE         Auth & fee 1 value if opt-in = false
**  TC  PARAMCUSTOMTERMS      Custom terms and conditions
**  FD  PARAMFEEDISCL         Custom fee disclosure
**  RI  PARAMREVOKEINST       Revocation instructions
**  OIO PARAMOPTINOUTINFO     Opt-in/Opt-out Information Text 
**  SI  PARAMSERVICEINST      Service Instuctions
**  OI  PARAMOPTININFO        Opt-in Information Text
**  OO  PARAMOPTOUTINFO       Opt-out Information Text
**  OTA PARAMOTAAMOUNT        Overdraft Tolerance Amount
*]
 INVALIDCONFIGPARAMS=FALSE

 FILEOPEN("LETTER",CONFIGFILENAME,"READ",LFNUMBER,LFERROR)

 IF LFERROR<>"" THEN
  DO
   READCONFIGERROR=TRUE
   READCONFIGERRORMSG="Error Opening Letterfile "+CONFIGFILENAME+": "+LFERROR
  END
 ELSE
  DO
   FILEREADLINE(LFNUMBER,LFLINE,LFERROR)
   WHILE LFERROR=""
    DO
     CALL NORMALIZEDATA
     IF PARAMNAME<>"" THEN
      DO
[* Ineligible Account Type(s)
*]
       IF PARAMNAME="IAT" AND
          PARAMVALUE<>"" THEN
        PARAMINELIGIBLEACCTS=PARAMVALUE

[* Share Tracking Type
*]
       IF PARAMNAME="TRK" AND
          PARAMVALUE<>"" THEN
        PARAMSHARETRACKING=VALUE(PARAMVALUE)

[* Valid Share Types
*]
       IF PARAMNAME="ST" THEN
        PARAMVALIDSHARETYPES=PARAMVALUE
[* Account Warnings
*]
       ELSE IF PARAMNAME="AW" AND
               PARAMVALUE<>"" THEN
        PARAMWARNINGSACCT=PARAMVALUE
[* Share Warnings
*]
       ELSE IF PARAMNAME="SW" AND
               PARAMVALUE<>"" THEN
        PARAMWARNINGSSHARE=PARAMVALUE
[* Update Auth And Fee
*]
       ELSE IF PARAMNAME="UD" THEN
        DO
         IF PARAMVALUE="FALSE" THEN
          PARAMUPDATEANDF=FALSE
        END
[* Source Code 1 when update A&F true & Opt-in true
*]
       ELSE IF PARAMNAME="SCT" THEN
        PARAMSC1TRUE=UPPERCASE(PARAMVALUE)
[* Source Code 1 when update A&F true & opt-in false
*]
       ELSE IF PARAMNAME="SCF" THEN
        PARAMSC1FALSE=UPPERCASE(PARAMVALUE)
[* Auth/Fee Option 1 when update A&F true & Opt-in true
*]
       ELSE IF PARAMNAME="AFT" AND
               PARAMVALUE<>"" THEN
        PARAMAF1TRUE=VALUE(PARAMVALUE)
[* Auth/Fee Option 1 when update A&F true & opt-in false
*]
       ELSE IF PARAMNAME="AFF" AND
               PARAMVALUE<>"" THEN
        PARAMAF1FALSE=VALUE(PARAMVALUE)
[* Overdraft Tolerance Amount
*]
       ELSE IF PARAMNAME="OTA" AND
               PARAMVALUE<>"" THEN
        DO
         COLONPOS=CHARACTERSEARCH(PARAMVALUE,":")
         IF COLONPOS>1 AND 
            COLONPOS<LENGTH(PARAMVALUE) AND
            PARAMOTACOUNT<PARAMOTAMAX THEN
          DO
           PARAMOTACOUNT=PARAMOTACOUNT+1
           PARAMOTASHARETYPE(PARAMOTACOUNT)=VALUE(SEGMENT(PARAMVALUE,1,COLONPOS-1))
           PARAMOTAAMOUNT(PARAMOTACOUNT)=MONEY(VALUE(SEGMENT(PARAMVALUE,COLONPOS+1,LENGTH(PARAMVALUE))))
          END
        END
[* Debug mode. This is a hidden parameter setting which can override the default debug
** mode setting. Use this "DB:" parameter setting in the CFG Letter file with "ON"
** or "OFF" to force the debug mode to be other than the default value of being on for
** the first 90 days after the most recent program modification date.
*]
       ELSE IF PARAMNAME="DB" THEN
        DO
         IF CHARACTERSEARCH("ONTRUEYES",UPPERCASE(PARAMVALUE))>0 THEN
          BNODEBUGMODE=BNODEBUGMODEON
         ELSE IF CHARACTERSEARCH("OFFFALSENO",UPPERCASE(PARAMVALUE))>0 THEN
          BNODEBUGMODE=BNODEBUGMODEOFF
        END

[* Custom terms & conditions
*]
       ELSE IF PARAMNAME="TC" THEN
        DO
         IF PARAMCUSTOMTERMLINES<PARAMCUSTOMTERMLINESMAX THEN
          DO
           PARAMCUSTOMTERMLINES=PARAMCUSTOMTERMLINES+1
           TMPCHR=PARAMVALUE
           CALL NTS
           CALL CLEANUPTEXT
           PARAMCUSTOMTERMS(PARAMCUSTOMTERMLINES)=TMPCHR
          END
        END
[* Custom Fee Disclosure
*]
       ELSE IF PARAMNAME="FD" THEN
        DO
         IF PARAMFEEDISCLLINES<PARAMCUSTOMTERMLINESMAX THEN
          DO
           PARAMFEEDISCLLINES=PARAMFEEDISCLLINES+1
           TMPCHR=PARAMVALUE
           CALL NTS
           CALL CLEANUPTEXT
           PARAMFEEDISCL(PARAMFEEDISCLLINES)=TMPCHR
          END
        END
[* Revocation Instructions
*]
       ELSE IF PARAMNAME="RI" THEN
        DO
         IF PARAMREVOKEINSTLINES<PARAMREVOKEINSTLINESMAX THEN
          DO
           PARAMREVOKEINSTLINES=PARAMREVOKEINSTLINES+1
           TMPCHR=PARAMVALUE
           CALL NTS
           CALL CLEANUPTEXT
           PARAMREVOKEINST(PARAMREVOKEINSTLINES)=TMPCHR
          END
        END
[* Service Instructions
*]
       ELSE IF PARAMNAME="SI" THEN
        DO
         IF PARAMSERVICEINSTLINES<PARAMSERVICEINSTLINESMAX THEN
          DO
           PARAMSERVICEINSTLINES=PARAMSERVICEINSTLINES+1
           TMPCHR=PARAMVALUE
           CALL NTS
           CALL CLEANUPTEXT
           PARAMSERVICEINST(PARAMSERVICEINSTLINES)=TMPCHR
          END
        END
[* Opt-in Information Text
*]
       ELSE IF PARAMNAME="OI" THEN
        DO
         IF PARAMOPTININFOTEXTLINES<PARAMOPTININFOTEXTLINESMAX THEN
          DO
           PARAMOPTININFOTEXTLINES=PARAMOPTININFOTEXTLINES+1
           TMPCHR=PARAMVALUE
           CALL NTS
           CALL CLEANUPTEXT
           PARAMOPTININFOTEXT(PARAMOPTININFOTEXTLINES)=TMPCHR
          END
        END
[* Opt-out Information Text
*]
       ELSE IF PARAMNAME="OO" THEN
        DO
         IF PARAMOPTOUTINFOTEXTLINES<PARAMOPTOUTINFOTEXTLINESMAX THEN
          DO
           PARAMOPTOUTINFOTEXTLINES=PARAMOPTOUTINFOTEXTLINES+1
           TMPCHR=PARAMVALUE
           CALL NTS
           CALL CLEANUPTEXT
           PARAMOPTOUTINFOTEXT(PARAMOPTOUTINFOTEXTLINES)=TMPCHR
          END
        END
[* Opt-in/Opt-out Information Text
*]
       ELSE IF PARAMNAME="OIO" THEN
        DO
         IF PARAMOPTINOUTINFOTEXTLINES<PARAMOPTINOUTINFOTEXTLINESMAX THEN
          DO
           PARAMOPTINOUTINFOTEXTLINES=PARAMOPTINOUTINFOTEXTLINES+1
           TMPCHR=PARAMVALUE
           CALL NTS
           CALL CLEANUPTEXT
           PARAMOPTINOUTINFOTEXT(PARAMOPTINOUTINFOTEXTLINES)=TMPCHR
          END
        END 
      END

     PARAMNAME=""
     PARAMVALUE=""
     FILEREADLINE(LFNUMBER,LFLINE,LFERROR)
    END [WHILE LFERROR=""]

   IF PARAMOPTINOUTINFOTEXTLINES=1 AND 
      PARAMOPTINOUTINFOTEXT(1)="" THEN
    PARAMOPTINOUTINFOTEXTLINES=0

   IF LFERROR<>"" AND
      LFERROR<>"EOF" THEN
    DO
     READCONFIGERROR=TRUE
     READCONFIGERRORMSG="Error Reading Letterfile "+CONFIGFILENAME+": "+LFERROR
    END
   FILECLOSE(LFNUMBER,LFERROR)
  END
[* Add the parameter settings to the debug output
*]
 IF BNOINCLUDEPARMINDEBUG=TRUE THEN
  DO
   BNODEBUGMSG=REPEATCHR("=",120) CALL BNODEBUGMSGADD
   BNODEBUGMSG="START PARAMETER SETTINGS:" CALL BNODEBUGMSGADD
   BNODEBUGMSG="  TRK: "+FORMAT("99",PARAMSHARETRACKING) CALL BNODEBUGMSGADD
   BNODEBUGMSG="  IAT: "+PARAMINELIGIBLEACCTS CALL BNODEBUGMSGADD
   BNODEBUGMSG="  ST: "+PARAMVALIDSHARETYPES CALL BNODEBUGMSGADD
   BNODEBUGMSG="  AW: "+PARAMWARNINGSACCT CALL BNODEBUGMSGADD
   BNODEBUGMSG="  SW: "+PARAMWARNINGSSHARE CALL BNODEBUGMSGADD
   BNODEBUGMSG="  UD: "+FORMAT("9",PARAMUPDATEANDF) CALL BNODEBUGMSGADD
   BNODEBUGMSG="  SCT: "+PARAMSC1TRUE CALL BNODEBUGMSGADD
   BNODEBUGMSG="  SCF: "+PARAMSC1FALSE CALL BNODEBUGMSGADD
   BNODEBUGMSG="  AFT: "+FORMAT("9",PARAMAF1TRUE) CALL BNODEBUGMSGADD
   BNODEBUGMSG="  AFF: "+FORMAT("9",PARAMAF1FALSE) CALL BNODEBUGMSGADD
   FOR TMPLOOP=1 TO PARAMOTACOUNT
    DO
     BNODEBUGMSG=FORMAT("OTA 999 -",TMPLOOP)+
                 FORMAT(" SHARE TYPE 9999  ",PARAMOTASHARETYPE(TMPLOOP))+
                 FORMAT("OT AMOUNT $###,###,##9.99",PARAMOTAAMOUNT(TMPLOOP))
     CALL BNODEBUGMSGADD
    END
   BNODEBUGMSG="Custom TOC:"
   CALL BNODEBUGMSGADD
   FOR TMPLOOP=1 TO PARAMCUSTOMTERMLINES
    DO
     BNODEBUGMSG=FORMAT("999:",TMPLOOP)+"'"+PARAMCUSTOMTERMS(TMPLOOP)+"'"
     CALL BNODEBUGMSGADD
    END

   BNODEBUGMSG="Custom Fee Disclosure:"
   CALL BNODEBUGMSGADD
   FOR TMPLOOP=1 TO PARAMFEEDISCLLINES
    DO
     BNODEBUGMSG=FORMAT("999:",TMPLOOP)+"'"+PARAMFEEDISCL(TMPLOOP)+"'"
     CALL BNODEBUGMSGADD
    END

   BNODEBUGMSG="Custom Revoke Instructions:"
   CALL BNODEBUGMSGADD
   FOR TMPLOOP=1 TO PARAMREVOKEINSTLINES
    DO
     BNODEBUGMSG=FORMAT("999:",TMPLOOP)+"'"+PARAMREVOKEINST(TMPLOOP)+"'"
     CALL BNODEBUGMSGADD
    END

   BNODEBUGMSG="Custom Service Instructions:"
   CALL BNODEBUGMSGADD
   FOR TMPLOOP=1 TO PARAMSERVICEINSTLINES
    DO
     BNODEBUGMSG= FORMAT("999:",TMPLOOP)+"'"+PARAMSERVICEINST(TMPLOOP)+"'"
     CALL BNODEBUGMSGADD
    END

   BNODEBUGMSG="Custom Opt-in/out Instructions:"
   CALL BNODEBUGMSGADD
   FOR TMPLOOP=1 TO PARAMOPTINOUTINFOTEXTLINES
    DO
     BNODEBUGMSG= FORMAT("999:",TMPLOOP)+"'"+PARAMOPTINOUTINFOTEXT(TMPLOOP)+"'"
     CALL BNODEBUGMSGADD
    END

   BNODEBUGMSG="Custom Opt-in Instructions:"
   CALL BNODEBUGMSGADD
   FOR TMPLOOP=1 TO PARAMOPTININFOTEXTLINES
    DO
     BNODEBUGMSG= FORMAT("999:",TMPLOOP)+"'"+PARAMOPTININFOTEXT(TMPLOOP)+"'"
     CALL BNODEBUGMSGADD
    END

   BNODEBUGMSG="Custom Opt-out Instructions:"
   CALL BNODEBUGMSGADD
   FOR TMPLOOP=1 TO PARAMOPTOUTINFOTEXTLINES
    DO
     BNODEBUGMSG= FORMAT("999:",TMPLOOP)+"'"+PARAMOPTOUTINFOTEXT(TMPLOOP)+"'"
     CALL BNODEBUGMSGADD
    END

   BNODEBUGMSG="END PARAMETER SETTINGS:" CALL BNODEBUGMSGADD
   BNODEBUGMSG=REPEATCHR("=",120) CALL BNODEBUGMSGADD
  END [IF BNOINCLUDEPARMINDEBUG=TRUE]

 LELISTINPUT=PARAMINELIGIBLEACCTS
 IF LELISTINPUT="" THEN
  LELISTINPUT="NONE"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO 9999
  DO
   INVALIDACCTYPES(TMPLOOP)=LELIST(TMPLOOP)
  END

 LELISTINPUT=PARAMVALIDSHARETYPES
 IF LELISTINPUT="" THEN
  LELISTINPUT="ALL"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO MAXSLTYPES
  DO
   VALIDSHARETYPES(TMPLOOP)=LELIST(TMPLOOP)
  END

 LELISTINPUT=PARAMWARNINGSACCT
 IF LELISTINPUT="" THEN
  LELISTINPUT="NONE"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO MAXWARNINGTYPES
  DO
   WARNINGSACCT(TMPLOOP)=LELIST(TMPLOOP)
  END

 LELISTINPUT=PARAMWARNINGSSHARE
 IF LELISTINPUT="" THEN
  LELISTINPUT="NONE"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO MAXWARNINGTYPES
  DO
   WARNINGSSHARE(TMPLOOP)=LELIST(TMPLOOP)
  END

 IF READCONFIGERROR=TRUE THEN
  DO
   NEWLINE
   CALL JSONOPEN
   ERRORCODE=501
   CALL ERRORHANDLER
   CALL JSONCLOSE
   @RGSTATE=STATEEND
  END
 ELSE
  CALL VALIDATEPARAMS
END [PROCEDURE]

PROCEDURE VALIDATEPARAMS
[* Validate required parameters to make sure all necessary
** parameter settings are present and within required ranges
*]
 PARAMVALIDATIONERROR=FALSE
[* Validate tracking record (<=3 and <=99)
*]
 IF PARAMSHARETRACKING<30 OR
    PARAMSHARETRACKING>99 THEN
  DO
   PARAMVALIDATIONERROR=TRUE
   PARAMVALIDATIONERRORCHR="Invalid tracking type"
  END

[* validate source code list entries  - if true or false
*]
 IF PARAMVALIDATIONERROR=FALSE AND
    PARAMUPDATEANDF=TRUE AND
    LENGTH(PARAMSC1TRUE)>0 THEN
  DO
   FOR TMPLOOP=1 TO LENGTH(PARAMSC1TRUE)
    DO
     TMPCHR=SEGMENT(PARAMSC1TRUE,TMPLOOP,TMPLOOP)
     IF CHARACTERSEARCH(VALIDSOURCECODELIST,TMPCHR)=0 THEN
      DO
       PARAMVALIDATIONERROR=TRUE
       PARAMVALIDATIONERRORCHR="Invalid source code"
       TMPLOOP=LENGTH(PARAMSC1TRUE)
      END
    END
  END

 IF PARAMVALIDATIONERROR=FALSE AND
    PARAMUPDATEANDF=TRUE AND
    LENGTH(PARAMSC1FALSE)>0 THEN
  DO
   FOR TMPLOOP=1 TO LENGTH(PARAMSC1FALSE)
    DO
     TMPCHR=SEGMENT(PARAMSC1FALSE,TMPLOOP,TMPLOOP)
     IF CHARACTERSEARCH(VALIDSOURCECODELIST,TMPCHR)=0 THEN
      DO
       PARAMVALIDATIONERROR=TRUE
       PARAMVALIDATIONERRORCHR="Invalid tracking type"
       TMPLOOP=LENGTH(PARAMSC1FALSE)
      END
    END
  END

 IF PARAMVALIDATIONERROR=FALSE AND
    PARAMUPDATEANDF=TRUE AND
   (PARAMAF1TRUE<0 OR
    PARAMAF1TRUE>7) THEN
  PARAMVALIDATIONERROR=TRUE

 IF PARAMVALIDATIONERROR=FALSE AND
    PARAMUPDATEANDF=TRUE AND
   (PARAMAF1FALSE<0 OR
    PARAMAF1FALSE>7) THEN
  PARAMVALIDATIONERROR=TRUE

 IF PARAMSHARETRACKING<30 OR
    PARAMSHARETRACKING>99 THEN
  PARAMVALIDATIONERROR=TRUE

 IF PARAMVALIDATIONERROR=TRUE THEN
  DO
   NEWLINE
   CALL JSONOPEN
   ERRORCODE=502
   CALL ERRORHANDLER
   CALL JSONCLOSE
   @RGSTATE=STATEEND
  END
END [PROCEDURE]

PROCEDURE NORMALIZEDATA
[* Normalize the data and if a parameter, separate into
** parameter name and value
** PASS    LFLINE          Character line read in
** RETURN  PARAMNAME       Parameter name found
** RETURN  PARAMVALUE      Parameter value
**
*]
 PARAMNAME=""
 PARAMVALUE=""

 POS=CHARACTERSEARCH(LFLINE,":")
 IF LFLINE<>"" AND
    SEGMENT(LFLINE,1,1)<>"*" AND
    POS>1 THEN
  DO
   TMPCHR=SEGMENT(LFLINE,1,POS-1)
   CALL NLTS
   PARAMNAME=UPPERCASE(TMPCHR)

   TMPCHR=SEGMENT(LFLINE,POS+1,LENGTH(LFLINE))
   CALL NLTS
   PARAMVALUE=TMPCHR
  END
END [PROCEDURE]

PROCEDURE NLTS
[* Remove leading AND trailing spaces
**  PASS       TMPCHR
**  RETURN     TMPCHR
*]
 CALL NTS
 IF TMPCHR<>"" THEN
  CALL NLS
END [PROCEDURE]

PROCEDURE NLS
[* Remove leading spaces
**  PASS       TMPCHR
**  RETURN     TMPCHR
*]
 WHILE (LENGTH(TMPCHR)>0 AND
        SEGMENT(TMPCHR,1,1)=" ")
  DO
   IF LENGTH(TMPCHR)=1 THEN
    TMPCHR=""
   ELSE
    TMPCHR=SEGMENT(TMPCHR,2,LENGTH(TMPCHR))
  END
 IF LENGTH(TMPCHR)=0 THEN
  TMPCHR=""
END [PROCEDURE]

PROCEDURE NTS
[* Remove trailing spaces
**  PASS       TMPCHR
**  RETURN     TMPCHR
*]
 IF TMPCHR<>"" THEN
  TMPCHR=SEGMENT(TMPCHR,1,LENGTH(TMPCHR))
 IF LENGTH(TMPCHR)=0 THEN
  TMPCHR=""
END [PROCEDURE]

PROCEDURE CLEANUPTEXT
[* Check character string and remove out any characters or hidden
** characters which have an ASCII value which is not established in
** the VALIDCHRINPUT1 string in the SETUP division . This is to avoid
** display issues with displaying the terms or conditions. Additionally,
** if a back-slash or double quote is encountered, add a preceding
** backslash
**  PASS       TMPCHR   String to test
**  RETURN     TMPCHR   Updated string
*]
 LELISTINPUT=VALIDCHRINPUT1
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO MAXCHRVALUE
  DO
   VALIDCHARS(TMPLOOP)=LELIST(TMPLOOP)
  END
 TMPTEXT=""

 IF TMPCHR<>"" THEN
  DO
   FOR TMPTEXTLOOP=1 TO LENGTH(TMPCHR)
    DO
     CHRVAL=CHRVALUE(SEGMENT(TMPCHR,TMPTEXTLOOP,TMPTEXTLOOP))
     IF  VALIDCHARS(CHRVAL)=TRUE THEN
      DO
[* Check for back-slash or double-quote. If found, precede with a back-slash
*]
       IF (CHRVAL=92 OR CHRVAL=34) THEN
        TMPTEXT=TMPTEXT+BACKSLASH+SEGMENT(TMPCHR,TMPTEXTLOOP,TMPTEXTLOOP)
       ELSE
        TMPTEXT=TMPTEXT+SEGMENT(TMPCHR,TMPTEXTLOOP,TMPTEXTLOOP)
      END
    END
  END
 TMPCHR=TMPTEXT
END [PROCEDURE]

PROCEDURE INITIALIZEDATA
[* Initialize state variables
*]
 WHILELIMIT=100000
 LFNUMBER=0
 LFERROR=""
 MEMBERNUM=""
 SLTYPE=""
 SLID=""
 READCONFIGERROR=FALSE
 READCONFIGERRORMSG=""
 LFERROR=""
 LFNUMBER=0

 PARAMINELIGIBLEACCTS="NONE"
 PARAMVALIDSHARETYPES="ALL"
 PARAMWARNINGSACCT="NONE"
 PARAMWARNINGSSHARE="NONE"
 PARAMUPDATEANDF=TRUE
 PARAMSC1TRUE=""
 PARAMSC1FALSE="GOBA"
 PARAMAF1TRUE=0
 PARAMAF1FALSE=7
 PARAMCUSTOMTERMLINES=0
 PARAMREVOKEINSTLINES=0
 PARAMSERVICEINSTLINES=0
 PARAMOPTININFOTEXTLINES=0
 PARAMOPTOUTINFOTEXTLINES=0
 PARAMOPTINOUTINFOTEXTLINES=0
 PARAMSHARETRACKING=0
 PARAMOTACOUNT=0

 FOR TMPLOOP=0 TO PARAMCUSTOMTERMLINESMAX
  DO
   PARAMCUSTOMTERMS(TMPLOOP)=""
   PARAMFEEDISCL(TMPLOOP)=""
  END

 FOR TMPLOOP=0 TO PARAMREVOKEINSTLINESMAX
  DO
   PARAMREVOKEINST(TMPLOOP)=""
  END

 FOR TMPLOOP=0 TO PARAMSERVICEINSTLINESMAX
  DO
   PARAMSERVICEINST(TMPLOOP)=""
  END 

 FOR TMPLOOP=0 TO PARAMOPTININFOTEXTLINESMAX
  DO
   PARAMOPTININFOTEXT(TMPLOOP)=""
  END

 FOR TMPLOOP=0 TO PARAMOPTOUTINFOTEXTLINESMAX
  DO
   PARAMOPTOUTINFOTEXT(TMPLOOP)=""
  END

 FOR TMPLOOP=0 TO PARAMOPTINOUTINFOTEXTLINESMAX
  DO
   PARAMOPTINOUTINFOTEXT(TMPLOOP)=""
  END   
 
 FOR TMPLOOP=0 TO MAXSLTYPES
  DO
   VALIDSHARETYPES(TMPLOOP)=FALSE
  END

 FOR TMPLOOP=0 TO MAXWARNINGTYPES
  DO
   WARNINGSACCT(TMPLOOP)=FALSE
   WARNINGSSHARE(TMPLOOP)=FALSE
  END
END [PROCEDURE]

PROCEDURE ERRORHANDLER
[* Print error code information to output.
**  PASS       ERRORCODE      Error code to print
**  PASS       ERRORMSG       Error type to print
**  PASS       ERRORDETAIL    Specific error detail
**
** ERROR CODES
**  500 - Program running in memo mode
**  501 - Config file read error
**  502 - Config file validation error
**  503 - No eligible shares to be created
**  504 - Ineligible account type
**  505 - Account warning exists
**  506 - Error updating/creating share tracking
**  507 - Error updating Auth/Fee fields
**  508 - Error updating Overdraft Tolerance amount
*]
 ERRORMSG="loggingErrorMessage"
 ERRORDETAIL(0)="Program running in memo mode"
 ERRORDETAIL(1)="Error reading from config file:"+LFERROR
 ERRORDETAIL(2)="Config file validation error"
 ERRORDETAIL(3)="No eligible shares."
 ERRORDETAIL(4)=FORMAT("Ineligible Acct Type 9999 found",ACCOUNT:TYPE)
 ERRORDETAIL(5)=FORMAT("Account warning 999 exists",SLAWARNINGFOUND)
 ERRORDETAIL(6)="Error attempting to update share tracking: "+FMERROR
 ERRORDETAIL(7)="Error updating sourcecode & auth/fee fields: "+FMERROR
 ERRORDETAIL(8)="Error updating share overdraft tolerance amount: "+FMERROR

 ERRORDETAILOFFSET=ERRORCODE-500

[* 7/1-TEK: Force all error codes to 500 except for 503
*]
 IF ERRORCODE<>503 THEN
  ERRORCODE=500

 PRINT "    "+Q+"errorCode"+Q+": "+FORMAT(Q+"999"+Q,ERRORCODE)+","
 NEWLINE
 PRINT "    "+Q+ERRORMSG+Q+": "+
            Q+ERRORDETAIL(ERRORDETAILOFFSET)+Q
 NEWLINE
END [PROCEDURE]

PROCEDURE JSONOPEN
 PRINT "{"
 NEWLINE
END [PROCEDURE]

PROCEDURE JSONCLOSE
 PRINT "}"
 NEWLINE
END [PROCEDURE]

PROCEDURE VALIDATEACCOUNT

 INVALIDACCTTYPEFOUND=FALSE
 IF INVALIDACCTYPES(ACCOUNT:TYPE)=TRUE THEN
  INVALIDACCTTYPEFOUND=TRUE

 SLAWARNINGFOUND=FALSE
 FOR TMPLOOP=1 TO MAXWARNINGTYPES
  DO
   IF WARNINGSACCT(TMPLOOP)=TRUE AND
      ANYWARNING(ACCOUNT,TMPLOOP) THEN
    DO
     SLAWARNINGFOUND=TMPLOOP
     TMPLOOP=MAXWARNINGTYPES
    END
  END

 IF INVALIDACCTTYPEFOUND=TRUE THEN
  DO
   ERRORCODE=504
   @RGSTATE=STATEEND
   CALL JSONOPEN
   CALL ERRORHANDLER
  END

 IF SLAWARNINGFOUND<>FALSE THEN
  DO
   ERRORCODE=505
   @RGSTATE=STATEEND
   CALL JSONOPEN
   CALL ERRORHANDLER
  END
END [PROCEDURE]

PROCEDURE VALIDATESYSMEMOMODE
[* Check to see if system is in MemoMode and if so, return
** memoMode: true
*]
 SYSTEMMEMOMODE=SYSMEMOMODE

 IF SYSTEMMEMOMODE=TRUE THEN
  DO
   NEWLINE
   CALL JSONOPEN
   PRINT Q+"memoMode"+Q+": true"
   NEWLINE
   CALL JSONCLOSE
   @RGSTATE=STATEEND
  END
END [PROCEDURE]

PROCEDURE SETSESSIONVARS
[* Pull the values from the state character arrays and store in
** an array for processing.
*]
 SNSHARELIST(1)=@RGUSERCHR1
 SNSHARELIST(2)=@RGUSERCHR2
 SNSHARELIST(3)=@RGUSERCHR3
 SNSHARELIST(4)=@RGUSERCHR4
 SNSHARELIST(5)=@RGUSERCHR5
END [PROCEDURE]

PROCEDURE SETSNSHARELISTSELECTED
[* UX will pass back up to 5 strings of data consisting of those Share
** IDs which are to be enrolled in ODT, passed data will be formatted
** as 4-chracter Share IDs with comma dilineation.
*]

 FOR TMPLOOP=1 TO SDMAX
  DO
   SDODTNEWSTATUS(TMPLOOP)=FALSE
  END

 SHARELISTINDEX=1
 WHILE SHARELISTINDEX<=5
  DO
   SHARELIST=SNSHARELIST(SHARELISTINDEX)
   WHILE SHARELIST<>""
    DO
     COMMAPOS=CHARACTERSEARCH(SHARELIST,",")
     IF COMMAPOS>0 THEN
      DO
       SLID=SEGMENT(SHARELIST,1,COMMAPOS-1)
       IF COMMAPOS=LENGTH(SHARELIST) THEN
        SHARELIST=""
       ELSE
	  SHARELIST=SEGMENT(SHARELIST,COMMAPOS+1,LENGTH(SHARELIST))
      END
     ELSE
      DO
       SLID=SHARELIST
       SHARELIST=""
      END
     IF SLID<>"" THEN
      DO
       SLID="0000"+SLID
       SLID=SEGMENT(SLID,LENGTH(SLID)-SLIDLEN+1,LENGTH(SLID))
       FOUND=FALSE
       TMPLOOP=1
       WHILE FOUND=FALSE AND TMPLOOP<=SDCOUNT
        DO
         IF SDID(TMPLOOP)=SLID THEN
          DO
           FOUND=TRUE
           SDODTNEWSTATUS(TMPLOOP)=TRUE
          END
         TMPLOOP=TMPLOOP+1
        END
      END
    END
   SHARELISTINDEX=SHARELISTINDEX+1
  END
END [PROCEDURE]

PROCEDURE UPDATERECORDS
[* Update or create share tracking records as needed and, if the parameter
** is set, the auth/fee and surcecode fields.
*]
 TMPLOOP=1
 FMERROR=""
 FMUPDATEERRORTRACKING=FALSE

 WHILE (TMPLOOP<=SDCOUNT)
  DO
   IF (SDODTSTATUS(TMPLOOP)<>SDODTNEWSTATUS(TMPLOOP)) OR
       SDODTTRACKINGLOC(TMPLOOP)=0 OR
       PARAMUPDATEANDF=TRUE THEN
    DO
     IF SDODTNEWSTATUS(TMPLOOP)=TRUE THEN
      NEWSTATUS=1
     ELSE
      NEWSTATUS=0
     IF SDODTTRACKINGLOC(TMPLOOP)=0 THEN
      DO
       FMTRACKINGLOCATOR=-1
       FMPERFORM CREATE SHARE SDID(TMPLOOP) TRACKING LOC FMTRACKINGLOCATOR
                (0,PARAMSHARETRACKING,TEMPLOC,FMERROR)
        DO
         SET USERCODE1   TO NEWSTATUS
         SET USERDATE1   TO SYSTEMDATE
        END
      END
     ELSE
      DO
       FMTRACKINGLOCATOR=SDODTTRACKINGLOC(TMPLOOP)
       FMPERFORM REVISE SHARE SDID(TMPLOOP) TRACKING LOC FMTRACKINGLOCATOR
                (0,PARAMSHARETRACKING,FMERROR)
        DO
         SET USERCODE1   TO NEWSTATUS
         SET USERDATE1   TO SYSTEMDATE
        END
      END
     IF FMERROR<>"" THEN
      DO
       SDTRACKINGUPDATE(TMPLOOP)=FMUNSUCCESSFUL
       FMUPDATEERRORTRACKING=TRUE
      END
     ELSE
      SDTRACKINGUPDATE(TMPLOOP)=FMSUCCESSFUL

     IF PARAMUPDATEANDF=TRUE THEN
      CALL FMAUTHFEEFIELDS

     CALL FMODTAMOUNT 
    END
   TMPLOOP=TMPLOOP+1
  END
END [PROCEDURE]

PROCEDURE FMAUTHFEEFIELDS
[* If parameter is set, update the Auth/Fee and Sourcecode fields
*]
 FMERROR=""
 FMUPDATEERRORAUTHFEE=FALSE

 IF SDODTNEWSTATUS(TMPLOOP)=TRUE THEN
  DO
   NEWSOURCECODE1=PARAMSC1TRUE
   NEWAUTFEEOPTION1=PARAMAF1TRUE
  END
 ELSE
  DO
   NEWSOURCECODE1=PARAMSC1FALSE
   NEWAUTFEEOPTION1=PARAMAF1FALSE
  END

 FMPERFORM REVISE SHARE SDID(TMPLOOP) (0,0,FMERROR)
  DO
   SET ODTAUTHFEESRCCODELIST:1 TO NEWSOURCECODE1
   SET AUTHFEEOPTION:1 TO NEWAUTFEEOPTION1
  END

 IF FMERROR<>"" THEN
  DO
   SDAUTHFEEUPDATE(TMPLOOP)=FMUNSUCCESSFUL
   FMUPDATEERRORAUTHFEE=TRUE
  END
 ELSE
  SDAUTHFEEUPDATE(TMPLOOP)=FMSUCCESSFUL
END [PROCEDURE]

PROCEDURE FMODTAMOUNT
[* Update OVERDRAFTTOLERANCE amount in the SHARE record
*]
 FMERROR=""
 FMUPDATEERRORODTAMOUNT=FALSE

 IF SDODTSTATUS(TMPLOOP)<>SDODTNEWSTATUS(TMPLOOP) THEN
  DO
   IF SDODTNEWSTATUS(TMPLOOP)=FALSE THEN
    NEWODTAMOUNT=$0.00
   ELSE
    DO
     NEWODTAMOUNT=SDOVERDRAFTTOLERANCE(TMPLOOP)
     PARAMINDEX=1
     PARAMFOUND=FALSE
     WHILE (PARAMFOUND=FALSE AND PARAMINDEX<=PARAMOTACOUNT)
      DO
       IF PARAMOTASHARETYPE(PARAMINDEX)=SDTYPE(TMPLOOP) THEN
        DO
         PARAMFOUND=TRUE
         NEWODTAMOUNT=PARAMOTAAMOUNT(PARAMINDEX)
        END
       PARAMINDEX=PARAMINDEX+1
      END
    END

   FMPERFORM REVISE SHARE SDID(TMPLOOP) (0,0,FMERROR)
    DO
     SET OVERDRAFTTOLERANCE TO NEWODTAMOUNT
    END
  END

 IF FMERROR<>"" THEN
  FMUPDATEERRORODTAMOUNT=TRUE
END [PROCEDURE]

PROCEDURE PRINTPROGRAMINFO
 PRINT "  "+Q+"programInfo"+Q+": {"
 NEWLINE
 PRINT "    "+Q+"programName"+Q+": "+Q+PROGRAMNAME+Q+","
 NEWLINE
 PRINT "    "+Q+"programVersion"+Q+": "+Q+PROGRAMVERSION+Q+","
 NEWLINE
 PRINT "    "+Q+"programLastModDate"+Q+": "+Q+FORMAT("99/99/99-",LASTMODDATE)+LASTMODTIME+Q
 NEWLINE
 PRINT "  "+"},"
 NEWLINE
END [PROCEDURE]

PROCEDURE BNOPRINTRGDATA
[* Print @RGUSER[CHR,NUM] data passed from the UX in proper JSON format
**
**  PASS    BNODEBUGMODE        Boolean: Print debug data, T/F
*]
 IF BNODEBUGMODE=BNODEBUGMODEON AND
    BNOINCLUDERGDATAINDEBUG=TRUE THEN
  DO
   PRINT ","
   NEWLINE
   PRINT BNOINDENT(1)+Q+"rgData"+Q+": ["
   NEWLINE
   PRINT BNOINDENT(2)+Q+"CHR1:'"+SEGMENT(@RGUSERCHR1,1,120)+"'"+Q+","
   NEWLINE
   PRINT BNOINDENT(2)+Q+"CHR2:'"+SEGMENT(@RGUSERCHR2,1,120)+"'"+Q+","
   NEWLINE
   PRINT BNOINDENT(2)+Q+"CHR3:'"+SEGMENT(@RGUSERCHR3,1,120)+"'"+Q+","
   NEWLINE
   PRINT BNOINDENT(2)+Q+"CHR4:'"+SEGMENT(@RGUSERCHR4,1,120)+"'"+Q+","
   NEWLINE
   PRINT BNOINDENT(2)+Q+"CHR5:'"+SEGMENT(@RGUSERCHR5,1,120)+"'"+Q+","
   NEWLINE
   PRINT BNOINDENT(2)+Q+
                     "NUM1:"+FORMAT("#########9 ",@RGUSERNUM1)+
                     "NUM2:"+FORMAT("#########9 ",@RGUSERNUM2)+
                     "NUM3:"+FORMAT("#########9 ",@RGUSERNUM3)+
                     "NUM4:"+FORMAT("#########9 ",@RGUSERNUM4)+
                     "NUM5:"+FORMAT("#########9",@RGUSERNUM5)+Q
   NEWLINE
   PRINT BNOINDENT(1)+"]"
   NEWLINE
  END
END [PROCEDURE]

PROCEDURE BNOPRINTDEBUG
[* Print debug output in proper JSON format. Requires BNODEBUGMODE to be
** on (or true).
**
**  PASS  BNODEBUGMODE        Boolean: Print debug data, T/F
**  PASS  BNODEBUGMSGLIST(A)  Array of debug messages to print
**  PASS  BNODEBUGCOUNT       Number of debug lines to print
*]
 IF BNODEBUGMODE=BNODEBUGMODEON THEN
  DO
   PRINT ","
   NEWLINE
   PRINT BNOINDENT(2)+Q+"debugData"+Q+": ["
   NEWLINE
   PRINT BNOINDENT(2)+Q+"Debug note: Debug lines truncated to 120 characters"+Q
   FOR BNODEBUGLOOP=1 TO BNODEBUGCOUNT
    DO
     PRINT ","
     NEWLINE
     PRINT BNOINDENT(3)+Q+SEGMENT(BNODEBUGMSGLIST(BNODEBUGLOOP),1,120)+Q
    END [FOR BNODEBUGLOOP=1 TO BNODEBUGCOUNT]
   PRINT BNOINDENT(2)+"]"
   NEWLINE
  END
END [PROCEDURE]

PROCEDURE BNODEBUGMSGADD
[* Add a message line to the debug message array
**
** PASS    BNODEBUGMSGMAX     Current array index max lines allowed
** PASS    BNODEBUGMSG        Debug message to add to array
**
** RETURN  BNODEBUGCOUNT      Count of debug message lines
** RETURN  BNODEBUGMSGLIST(A) Debug lines of data to print
**
*]
 IF BNODEBUGCOUNT<BNODEBUGMSGMAX THEN
  DO
   BNODEBUGCOUNT=BNODEBUGCOUNT+1
   BNODEBUGMSGLIST(BNODEBUGCOUNT)=SEGMENT(BNODEBUGMSG,1,126)
   BNODEBUGMSG=""
  END
END [PROCEDURE]

#INCLUDE "RB.LISTEXPAND"

