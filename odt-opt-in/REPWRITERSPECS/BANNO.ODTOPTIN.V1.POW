[*
**  PowerOn Name:       BANNO.ODTOPTIN.V1.POW
**  Letterfile Name:    BANNO.ODTOPTIN.V1.CFG
**
**  Copyright 2020-2025 Jack Henry and Associates
**
**  This Banno service PowerOn allows the user to Opt-In or Opt-out
**  of the Reg-E overdraft service
**
**  For more information check
**  https://github.com/Banno/banno-powerons
**
**  Banno is not responsible for any modifications to this file
**  made by unauthorized personnel.
**
**  Modification History:
**    Ver. 1.0.0  07/14/20 T. Kainz - Original Programming
**    Ver. 1.0.1  09/18/20 T. Kainz - Corrected end of line spacing for disclosures
**    Ver. 1.0.2  02/11/21 T. Kainz - Mod to terms, Discl & revoke inst.to allow for
**                         blank line. Added program info to JSON output.
**    Ver. 1.0.3  09/03/21 T. Kainz - Increased the TOC and Disclosure lines max to
**                         999 and the revoke instructions to 99.
**    Ver. 1.0.4  07/29/22 R. Robison - Added Service Instructions, Opt-in information
**                         and Opt-out information soft text.  Added feature for setting
**                         Overdraw Tolerance field on share record.
**    Ver. 1.1.0  06/12/23 R. Robison - Added opt-in/opt-out information soft text
**    Ver. 1.1.1  08/09/23 T. Kainz - Corrected faulty JSON when debug mode is turned on
**                         Added additional debug output to facilitate troubleshooting.
**                         Corrected S/L type calc/reference.
**    Ver. 1.1.2  01/22/24 J. Keenan - Improved JSon error message detail for
**                         configuration file validation error.
**    Ver. 1.2.0  05/14/24 TKainz - Banno
**                         Added Program Installation Date parameter
**    Ver. 1.3.0  08/13/24 TKainz - Banno
**                         Added setting for default ODT amount.
**    Ver. 1.4.0  09/16/24 TKainz - Banno
**                         Added parameter option to clear/not clear the ODT amount
**                         upon opt-out:
**                           CLEAR OVERDRAFT TOLERANCE AMOUNT ON OPT-OUT
**    Ver. 1.5.0  10/21/25 JKeenan - Banno
**                         Added the parameter settings to allow overdraft settings
**                         changes during memo mode, memo mode message configurable 
**                         soft text, and success message configurable soft text.
**                         Added support for a display to client errorMessage.
**                         The configuration file is prefilled with suggested
**                         error code 503 no eligible shares soft text.
**
**  DO NOT MODIFY THIS FILE UNLESS YOU KNOW WHAT YOU'RE DOING!
*]

SYMCONNECT
STATELESS

TARGET=ACCOUNT

DEFINE
 #INCLUDE "RD.GETDATA.DEF"
 #INCLUDE "RB.LISTEXPAND.DEF"

 TRUE                         = 1
 FALSE                        = 0
 FMUNCHANGED                  = 0
 FMSUCCESSFUL                 = 1
 FMUNSUCCESSFUL               = 2
 CONFIGFILENAME               = "BANNO.ODTOPTIN.V1.CFG"
 STATEPRELOADDATA             = "PRELOADDATA"
 STATEPROCESSDATA             = "PROCESSDATA"
 STATEEND                     = "STATEEND"
 DATENULL                     = '--/--/--'
 VALIDSOURCECODELIST          = "ABCDEFGHIJKLNOPRSTVW"


 PROGRAMNAME                  = CHARACTER
 PROGRAMVERSION               = CHARACTER
 LASTMODDATE                  = DATE
 LASTMODTIME                  = CHARACTER

 LFNUMBER                     = NUMBER
 LFERROR                      = CHARACTER
 LFLINE                       = CHARACTER
 READCONFIGERROR              = NUMBER
 READCONFIGERRORMSG           = CHARACTER
 PARAMINDEX                   = NUMBER
 PARAMFOUND                   = NUMBER

 PARAMINELIGIBLEACCTS         = CHARACTER
 PARAMVALIDSHARETYPES         = CHARACTER
 PARAMWARNINGSACCT            = CHARACTER
 PARAMWARNINGSSHARE           = CHARACTER
 PARAMSHARETRACKING           = NUMBER
 PARAMUPDATEANDF              = NUMBER
 PARAMSC1TRUE                 = CHARACTER
 PARAMSC1FALSE                = CHARACTER
 PARAMAF1TRUE                 = NUMBER
 PARAMAF1FALSE                = NUMBER
 PARAMCUSTOMTERMS             = CHARACTER(126) ARRAY(999)
 PARAMCUSTOMTERMLINES         = NUMBER
 PARAMFEEDISCL                = CHARACTER(126) ARRAY(999)
 PARAMFEEDISCLLINES           = NUMBER
 PARAMCUSTOMTERMLINESMAX      = 999
 PARAMREVOKEINST              = CHARACTER(126) ARRAY(99)
 PARAMREVOKEINSTLINES         = NUMBER
 PARAMREVOKEINSTLINESMAX      = 99
 PARAMSERVICEINST             = CHARACTER(126) ARRAY(99)
 PARAMSERVICEINSTLINES        = NUMBER
 PARAMSERVICEINSTLINESMAX     = 99
 PARAMOPTININFOTEXT           = CHARACTER(126) ARRAY(99)
 PARAMOPTININFOTEXTLINES      = NUMBER
 PARAMOPTININFOTEXTLINESMAX   = 99
 PARAMOPTOUTINFOTEXT          = CHARACTER(126) ARRAY(99)
 PARAMOPTOUTINFOTEXTLINES     = NUMBER
 PARAMOPTOUTINFOTEXTLINESMAX  = 99
 PARAMOTAAMOUNT               = MONEY ARRAY(99)
 PARAMOTASHARETYPE            = NUMBER ARRAY(99)
 PARAMOTACOUNT                = NUMBER
 PARAMOTAMAX                  = 99
 PARAMCOTA                    = NUMBER
 PARAMOPTINOUTINFOTEXT        = CHARACTER ARRAY(10)
 PARAMOPTINOUTINFOTEXTLINES   = NUMBER
 PARAMOPTINOUTINFOTEXTLINESMAX= 10
 PARAMNAME                    = CHARACTER
 PARAMVALUE                   = CHARACTER
 PARAMVALIDATIONERROR         = NUMBER
 PARAMVALIDATIONERRORCHR      = CHARACTER
 INVALIDACCTYPES              = NUMBER ARRAY(9999)
 VALIDSHARETYPES              = NUMBER ARRAY(9999)
 WARNINGSACCT                 = NUMBER ARRAY(999)
 WARNINGSSHARE                = NUMBER ARRAY(999)
 SLAWARNINGFOUND              = NUMBER
 INVALIDACCTTYPEFOUND         = NUMBER
 TMPLOOP                      = NUMBER
 TMPLOOP2                     = NUMBER
 TMPCHR                       = CHARACTER
 POS                          = NUMBER
 Q                            = CHARACTER
 QQ                           = CHARACTER
 BACKSLASH                    = CHARACTER
 MEMBERNUM                    = CHARACTER
 SLTYPE                       = CHARACTER
 SLID                         = CHARACTER
 FOUND                        = NUMBER
 ERRORCODE                    = NUMBER
 ERRORMSG                     = CHARACTER
 ERRORDETAIL                  = CHARACTER ARRAY(99)
 ERRORDETAILOFFSET            = NUMBER
 TYPELENGTH                   = NUMBER
 MAXWARNINGTYPES              = NUMBER
 MAXSLTYPES                   = NUMBER
 TMPTEXT                      = CHARACTER
 TMPTEXTLOOP                  = NUMBER
 SYSTEMMEMOMODE               = NUMBER

 SDMAX                        = NUMBER
 SDCOUNT                      = NUMBER
 SDOVERMAX                    = NUMBER
 SDID                         = CHARACTER(4) ARRAY(132)
 SDTYPE                       = NUMBER ARRAY(132)
 SDNAME                       = CHARACTER(40) ARRAY(132)
 SDBALANCE                    = MONEY ARRAY(132)
 SDODTSTATUS                  = NUMBER ARRAY(132)
 SDODTNEWSTATUS               = NUMBER ARRAY(132)
 SDODTTRACKINGLOC             = NUMBER ARRAY(132)
 SDTRACKINGUPDATE             = NUMBER ARRAY(132)
 SDAUTHFEEUPDATE              = NUMBER ARRAY(132)
 SDOVERDRAFTTOLERANCE         = MONEY ARRAY(132)

 SNSHARELIST                  = CHARACTER ARRAY(9)
 SHARELISTINDEX               = NUMBER
 SHARELIST                    = CHARACTER
 COMMAPOS                     = NUMBER
 SLIDLEN                      = NUMBER
 FMERROR                      = CHARACTER
 NEWSTATUS                    = NUMBER
 FMTRACKINGLOCATOR            = NUMBER
 TEMPLOC                      = NUMBER
 NEWSOURCECODE1               = CHARACTER
 NEWAUTFEEOPTION1             = NUMBER
 INVALIDCONFIGPARAMS          = NUMBER
 BOOLEANCHR                   = CHARACTER ARRAY(1)
 CHRVAL                       = NUMBER
 FMRESULTSCHR                 = CHARACTER ARRAY(3)
 VALIDCHRINPUT1               = CHARACTER
 VALIDCHARS                   = NUMBER ARRAY(999)
 MAXCHRVALUE                  = 255
 FMUPDATEERRORTRACKING        = NUMBER
 FMUPDATEERRORAUTHFEE         = NUMBER
 FMUPDATEERRORODTAMOUNT       = NUMBER
 LASTSID                      = CHARACTER
 COLONPOS                     = NUMBER
 NEWODTAMOUNT                 = MONEY

[* Added 08/04/23*]
 BNODEBUGMODEOFF              = 0
 BNODEBUGMODEON               = 1
 BNODEBUGMODE                 = NUMBER
 BNODEBUGLOOP                 = NUMBER
 BNODEBUGCOUNT                = NUMBER
 BNODEBUGMSGLIST              = CHARACTER ARRAY(2400)
 BNODEBUGMSGMAX               = 2400
 BNODEBUGMSG                  = CHARACTER
 BNOINDENTMAX                 = 9
 BNOLOCALLOOP                 = NUMBER
 BNOINCLUDEPARMINDEBUG        = NUMBER
 BNOINCLUDERGDATAINDEBUG      = NUMBER
 BNOINDENT                    = CHARACTER ARRAY(9)
 SHAREINVALIDREASON           = CHARACTER

[* Added 05/14/24 *]
 PARAMINSTALLDATE             = DATE
 PARAMDEBUGMODE               = NUMBER
 PARAMDEBUGMODEFOUND          = NUMBER

[* Added 08/02/24 *]
 DEFAULTOTAVALUE              = MONEY
 DEFAULTOTAVALUECHR           = CHARACTER
 BNOTRUEFALSECHR              = CHARACTER ARRAY(1)

[* Added 10/21/25 begin *]
 ALLOWINMEMOMODE                = NUMBER
 PARAMMEMOMODESUCCESS           = CHARACTER ARRAY(5)
 PARAMMEMOMODESUCCESSLINES      = NUMBER
 PARAMMEMOMODESUCCESSLINESMAX   = 5
 MEMOSUCCESSMSGSETFLAG          = NUMBER
 TERMSLOOP                      = NUMBER

 PARAMSUCCESSMSG                = CHARACTER ARRAY(5)
 PARAMSUCCESSMSGLINES           = NUMBER
 PARAMSUCCESSMSGLINESMAX        = 5

 PARAMMEMOMODEMSG               = CHARACTER ARRAY(5)
 PARAMMEMOMODEMSGLINES          = NUMBER
 PARAMMEMOMODEMSGLINESMAX       = 5

 FOUNDINDEX                     = NUMBER
 TMPERRCODE                     = NUMBER
 TMPDISPLAYLINE                 = CHARACTER
 PARAMERRDISPLAY                = NUMBER ARRAY(10,1)
  ERRDISPLAYERRCODE             = 0
  ERRDISPLAYLINECOUNT           = 1
 PARAMERRDISPLAYCOUNT           = NUMBER
 PARAMERRDISPLAYLINES           = CHARACTER ARRAY(10,5)
 PARAMERRDISPLAYMAX             = 10
 PARAMERRDISPLAYLINESMAX        = 5
 PARAMERRDISPLAYERRLIST         = "501,502,503,504,505,506,507,508"

 BNOERRCODEMEMOMODE             = 500
 BNOERRCODECFGPARSE             = 501
 BNOERRCODEINVALIDPARAM         = 502
 BNOERRCODENOELIGSHARES         = 503
 BNOERRCODEINELIGACCTYPE        = 504
 BNOERRCODACCTWARNEXISTS        = 505
 BNOERRCODEFMSHTRKNGFAIL        = 506
 BNOERRCODEFMSCANDAUTHFEEFAIL   = 507
 BNOERRCODEFMSHODTAMTFAIL       = 508
 BNOERRUNHANDLED                = 509

 BNOERRORCODE                   = NUMBER
 BNOERRCODE                     = NUMBER
 BNOERRMESSAGE                  = CHARACTER
 BNOERRCOUNT                    = NUMBER
 BNOERRTMPCOUNT                 = NUMBER
 BNOERRTMPCOUNT2                = NUMBER
 BNOERRFOUND                    = NUMBER
 BNOERRDISPLAYLINE              = CHARACTER
 BNOERRCODES                    = NUMBER ARRAY(99)
 BNOERRMESSAGES                 = CHARACTER ARRAY(99)
 BNOERRDISPLAYMSG               = CHARACTER ARRAY(5)
 BNOERRDISPLAYMSGCOUNT          = NUMBER
 BNOERRDISPLAYMSGS              = CHARACTER ARRAY(99,5)
 BNOERRDISPLAYMSGSCOUNT         = NUMBER ARRAY(99)
 BNOERRDISPLAYMSGSMAX           = 5
 GENERICERRDISPLAYMSGCOUNT      = NUMBER
 GENERICERRDISPLAYMSG           = CHARACTER ARRAY(4)
 BNOERRMAX                      = 99
 BNOERRUNDEFINED                = "**Undefined**"

 [* Added 10/21/25 end *]
END [DEFINE]

SETUP
 PROGRAMNAME="BANNO.ODTOPTIN.V1.POW"
 PROGRAMVERSION="1.5.0"
 LASTMODDATE='10/21/25'
 LASTMODTIME="17:30 PT"

 Q=CTRLCHR(34)
 QQ=CTRLCHR(34)
 BACKSLASH=CTRLCHR(92)
 BNOINCLUDEPARMINDEBUG=TRUE
 BNOINCLUDERGDATAINDEBUG=TRUE
 BNOTRUEFALSECHR(FALSE)="false"
 BNOTRUEFALSECHR(TRUE)="true"

 IF LASTMODDATE+90>SYSTEMDATE THEN
  BNODEBUGMODE=BNODEBUGMODEON
 ELSE
  BNODEBUGMODE=BNODEBUGMODEOFF

 FOR BNOLOCALLOOP=1 TO BNOINDENTMAX
  DO
   BNOINDENT(BNOLOCALLOOP)=REPEATCHR(" ",BNOLOCALLOOP)
  END

[* Set SDMAX to 130 for production. Pass back any lower number >0 in the
** @RGUSERNUM1 field for testing or limiting program to lower values
*]
 SDMAX=130
 IF @RGUSERNUM1>0 THEN
  SDMAX=@RGUSERNUM1

 TYPELENGTH=GETDATANUMBER(GETPARAMTYPELENGTH)
 IF TYPELENGTH=2 THEN
  MAXSLTYPES=99
 ELSE
  MAXSLTYPES=9999
 MAXWARNINGTYPES=999

 FMRESULTSCHR(FMSUCCESSFUL)="true"
 FMRESULTSCHR(FMUNSUCCESSFUL)="false"
 FMRESULTSCHR(FMUNCHANGED)="null"
 BOOLEANCHR(FALSE)="false"
 BOOLEANCHR(TRUE)="true"

 BNOERRCOUNT=0
 BNOERRMESSAGE=""
 BNOERRDISPLAYMSGCOUNT=0
 
 BNOERRCODE=BNOERRCODEMEMOMODE           BNOERRMESSAGE="Program running in memo mode"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODECFGPARSE           BNOERRMESSAGE="Config file read error"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEINVALIDPARAM       BNOERRMESSAGE="Config file validation error"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODENOELIGSHARES       BNOERRMESSAGE="No eligible shares."
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEINELIGACCTYPE      BNOERRMESSAGE="Ineligible Acct Type found"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODACCTWARNEXISTS      BNOERRMESSAGE="Account warning exists"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEFMSHTRKNGFAIL      BNOERRMESSAGE="Error attempting to update share tracking"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEFMSCANDAUTHFEEFAIL BNOERRMESSAGE="Error updating source code & auth/fee fields"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEFMSHODTAMTFAIL     BNOERRMESSAGE="Error updating share overdraft tolerance amount"
 CALL BNOERRADD
 BNOERRCODE=BNOERRUNHANDLED             BNOERRMESSAGE="Unhandled Error"
 CALL BNOERRADD

 SLIDLEN=GETDATANUMBER(GETPARAMIDLENGTH)
 VALIDCHRINPUT1="32-126,128-175,181-184,189,190,198,199,208-216,221,222,224-253"
 GENERICERRDISPLAYMSGCOUNT=4
 GENERICERRDISPLAYMSG(1)="<b>Your account needs attention</b><br>"
 GENERICERRDISPLAYMSG(2)="Something in your account needs to be corrected or updated."
 GENERICERRDISPLAYMSG(3)="At this time a staff member is required to assist you."
 GENERICERRDISPLAYMSG(4)="Please contact us to correct your account."
END [SETUP]

PRINT TITLE="BANNO.TEMPLATE.V1.POW"
[* STATE             OVERVIEW
** ----------------  -----------------------------------------------------------
** STATEPRELOADDATA  Present the user with a list of valid shares along with
**                   their current balance and ODT status.
** PROCESSDATA       Receive user input, update share and share tracking as
**                   needed and return a list of shares changed and new status.
**
*]
 CALL INITIALIZEDATA

 CALL READCONFIGFILESETTINGS

 IF @RGSTATE<>STATEEND AND
    ALLOWINMEMOMODE=FALSE THEN
  CALL VALIDATESYSMEMOMODE  

 IF @RGSTATE<>STATEEND THEN
  CALL VALIDATEACCOUNT

 IF @RGSTATE<>STATEEND THEN
  DO
   NEWLINE
   IF @RGSTATE=STATEPRELOADDATA THEN
    DO
     CALL POLLSHARES
     IF BNOERRORCODE=0 THEN
      DO
       IF SDCOUNT=0 THEN
        DO
         CALL JSONOPEN
         BNOERRORCODE=BNOERRCODENOELIGSHARES
         BNOERRCODE=BNOERRCODENOELIGSHARES
         BNOERRMESSAGE="No eligible shares."
         CALL ERRORHANDLER
         @RGSTATE=STATEEND
        END
       ELSE
        DO
         CALL PRINTSHAREDETAIL
        END
      END
    END
   IF @RGSTATE=STATEPROCESSDATA THEN
    DO
     CALL POLLSHARES
     CALL SETSESSIONVARS
     CALL SETSNSHARELISTSELECTED
     FOR TMPLOOP=1 TO SDCOUNT
      DO
       BNODEBUGMSG=FORMAT("99: ",TMPLOOP)+
                  "  SID:"+SDID(TMPLOOP)+
                   FORMAT("  SDODTTRACKINGLOC:999999",SDODTTRACKINGLOC(TMPLOOP))+
                   FORMAT("  SDODTSTATUS:99",SDODTSTATUS(TMPLOOP))+
                   FORMAT("  SDODTNEWSTATUS:99",SDODTNEWSTATUS(TMPLOOP))
       CALL BNODEBUGMSGADD
      END

     CALL UPDATERECORDS

     IF FMUPDATEERRORTRACKING=TRUE OR
        FMUPDATEERRORAUTHFEE=TRUE OR
        FMUPDATEERRORODTAMOUNT=TRUE THEN
      DO
       IF FMUPDATEERRORTRACKING=TRUE THEN
        DO
         BNOERRORCODE=BNOERRCODEFMSHTRKNGFAIL
         BNOERRCODE=BNOERRCODEFMSHTRKNGFAIL
         BNOERRMESSAGE="Error attempting to update share tracking: "+FMERROR
        END
       ELSE IF FMUPDATEERRORAUTHFEE=TRUE THEN
        DO
         BNOERRORCODE=BNOERRCODEFMSCANDAUTHFEEFAIL
         BNOERRCODE=BNOERRCODEFMSCANDAUTHFEEFAIL
         BNOERRMESSAGE="Error updating source code & auth/fee fields: "+FMERROR
        END
       ELSE IF FMUPDATEERRORODTAMOUNT=TRUE THEN
        DO   
         BNOERRORCODE=BNOERRCODEFMSHODTAMTFAIL
         BNOERRCODE=BNOERRCODEFMSHODTAMTFAIL
         BNOERRMESSAGE="Error updating share overdraft tolerance amount: "+FMERROR
        END
       CALL JSONOPEN
       CALL ERRORHANDLER
      END
     ELSE
      DO
       IF (SDODTSTATUS(TMPLOOP)<>SDODTNEWSTATUS(TMPLOOP)) OR
           SDODTTRACKINGLOC(TMPLOOP)=0 THEN
        DO
         CALL PRINTSHAREDETAIL
        END
      END
    END
  END

 CALL BNOPRINTRGDATA
 CALL BNOPRINTDEBUG
 CALL JSONCLOSE
END [PRINT]

PROCEDURE PRINTSHAREDETAIL
[* Loop through array of eligible shares and print properly formatted
** JSON for each share. If in state PRELOADDATA, include the terms and
** conditions, fee disclosure and revocation instructions
*]

 PRINT "{"
 NEWLINE

 CALL PRINTPROGRAMINFO

 PRINT "  "+Q+"memoMode"+Q+":  false,"
 NEWLINE
 PRINT "  "+Q+"results"+Q+": {"
 NEWLINE
 PRINT "  "+Q+"maxSharesExceeded"+Q+": "
 IF SDOVERMAX=TRUE THEN
  PRINT "true,"
 ELSE
  PRINT "false,"
 NEWLINE
 IF @RGSTATE=STATEPRELOADDATA THEN
  PRINT "  "+Q+"shareDetail"+Q+": ["
 ELSE
  DO
   IF SYSMEMOMODE=FALSE AND PARAMSUCCESSMSGLINES>0 THEN
    DO
     PRINT "  "+Q+"successMessage"+Q+": ["
     FOR TERMSLOOP=1 TO PARAMSUCCESSMSGLINES
      DO
       NEWLINE
       PRINT "   "+Q
        IF TERMSLOOP>1 AND
           PARAMSUCCESSMSG(TERMSLOOP)<>"" AND
           PARAMSUCCESSMSG(TERMSLOOP-1)<>"" THEN
         PRINT " "
        PRINT PARAMSUCCESSMSG(TERMSLOOP)+Q
        IF TERMSLOOP<PARAMSUCCESSMSGLINES THEN
         PRINT ","
      END
     NEWLINE
     PRINT "  "+"],"
     NEWLINE      
    END [IF SYSMEMOMODE=FALSE AND PARAMSUCCESSMSGLINES>0]
   ELSE IF SYSMEMOMODE=TRUE THEN
    DO [Use the Memo Mode Success Message. There is a default generic text]
     PRINT "  "+Q+"successMessage"+Q+": ["
     FOR TERMSLOOP=1 TO PARAMMEMOMODESUCCESSLINES
      DO
       NEWLINE
       PRINT "   "+Q
       IF TERMSLOOP>1 AND
          PARAMMEMOMODESUCCESS(TERMSLOOP)<>"" AND
          PARAMMEMOMODESUCCESS(TERMSLOOP-1)<>"" THEN
        PRINT " "
        PRINT PARAMMEMOMODESUCCESS(TERMSLOOP)+Q
        IF TERMSLOOP<PARAMMEMOMODESUCCESSLINES THEN
         PRINT ","
      END [ELSE IF SYSMEMOMODE=TRUE]
     NEWLINE
     PRINT "  "+"],"
     NEWLINE
    END   
   PRINT "  "+Q+"shareDetailUpdated"+Q+": ["
  END [ELSE IF @RGSTATE=STATEPROCESSDATA]
 LASTSID=""
 FOR TMPLOOP=1 TO SDCOUNT
  DO
   IF SDID(TMPLOOP)<>"" AND
     (@RGSTATE=STATEPRELOADDATA OR
     (@RGSTATE=STATEPROCESSDATA AND
      SDODTSTATUS(TMPLOOP)<>SDODTNEWSTATUS(TMPLOOP))) THEN
    DO
     LASTSID=SDID(TMPLOOP)
    END
  END
 FOR TMPLOOP=1 TO SDCOUNT
  DO
   IF SDID(TMPLOOP)<>"" AND
     (@RGSTATE=STATEPRELOADDATA OR
     (@RGSTATE=STATEPROCESSDATA AND
      SDODTSTATUS(TMPLOOP)<>SDODTNEWSTATUS(TMPLOOP))) THEN
    DO
     NEWLINE
     CALL JSONOPEN
     PRINT "   "+Q+"SID"+Q+": "+Q+SDID(TMPLOOP)+Q+","
     NEWLINE
     PRINT "   "+Q+"name"+Q+": "+Q+SDNAME(TMPLOOP)+Q+","
     NEWLINE
     TMPCHR=FORMAT("######9.99+",SDBALANCE(TMPLOOP))
     CALL NLS
     PRINT "   "+Q+"balance"+Q+": "+Q+TMPCHR+Q+","
     NEWLINE
     PRINT "   "+Q+"currentState"+Q+": "
     IF @RGSTATE=STATEPRELOADDATA THEN
      DO
       IF SDODTSTATUS(TMPLOOP)=TRUE THEN
        PRINT "true"
       ELSE
        PRINT "false"
      END
     ELSE
      DO
       IF SDODTNEWSTATUS(TMPLOOP)=TRUE THEN
        PRINT "true"
       ELSE
        PRINT "false"
      END
     NEWLINE
     PRINT "}"
     IF SDID(TMPLOOP)<>LASTSID THEN
      PRINT ","
     NEWLINE
    END
  END  [FOR TMPLOOP=1 TO SDCOUNT]
 PRINT "]"
 IF @RGSTATE=STATEPRELOADDATA THEN
  DO
   PRINT ","
   NEWLINE
   PRINT Q+"terms"+Q+": ["
   NEWLINE
   FOR TMPLOOP=1 TO PARAMCUSTOMTERMLINES
    DO
     PRINT Q+PARAMCUSTOMTERMS(TMPLOOP)+Q
     IF TMPLOOP<PARAMCUSTOMTERMLINES THEN
      PRINT ","
     NEWLINE
    END
   PRINT "],"
   NEWLINE

   PRINT Q+"feeDisclosure"+Q+": ["
   NEWLINE
   FOR TMPLOOP=1 TO PARAMFEEDISCLLINES
    DO
     PRINT Q+PARAMFEEDISCL(TMPLOOP)+Q
     IF TMPLOOP<PARAMFEEDISCLLINES THEN
      PRINT ","
     NEWLINE
    END
   PRINT "],"
   NEWLINE

   PRINT Q+"revocationInstructions"+Q+": ["
   NEWLINE
   FOR TMPLOOP=1 TO PARAMREVOKEINSTLINES
    DO
     PRINT Q+PARAMREVOKEINST(TMPLOOP)+Q
     IF TMPLOOP<PARAMREVOKEINSTLINES THEN
      PRINT ","
     NEWLINE
    END
   PRINT "],"
   NEWLINE

   PRINT Q+"servicesInstructions"+Q+": ["
   NEWLINE
   FOR TMPLOOP=1 TO PARAMSERVICEINSTLINES
    DO
     PRINT Q+PARAMSERVICEINST(TMPLOOP)+Q
     IF TMPLOOP<PARAMSERVICEINSTLINES THEN
      PRINT ","
     NEWLINE
    END
   PRINT "],"
   NEWLINE

   IF PARAMOPTINOUTINFOTEXTLINES>0 THEN
    DO
     PRINT Q+"optInOutInfoText"+Q+": ["
     NEWLINE
     FOR TMPLOOP=1 TO PARAMOPTINOUTINFOTEXTLINES
      DO
       PRINT Q+PARAMOPTINOUTINFOTEXT(TMPLOOP)+Q
       IF TMPLOOP<PARAMOPTINOUTINFOTEXTLINES THEN
        PRINT ","
       NEWLINE
      END
     PRINT "],"
     NEWLINE
    END

   PRINT Q+"optInInformationText"+Q+": ["
   NEWLINE
   FOR TMPLOOP=1 TO PARAMOPTININFOTEXTLINES
    DO
     PRINT Q+PARAMOPTININFOTEXT(TMPLOOP)+Q
     IF TMPLOOP<PARAMOPTININFOTEXTLINES THEN
      PRINT ","
     NEWLINE
    END
   PRINT "],"
   NEWLINE

   PRINT Q+"optOutInformationText"+Q+": ["
   NEWLINE
   FOR TMPLOOP=1 TO PARAMOPTOUTINFOTEXTLINES
    DO
     PRINT Q+PARAMOPTOUTINFOTEXT(TMPLOOP)+Q
     IF TMPLOOP<PARAMOPTOUTINFOTEXTLINES THEN
      PRINT ","
     NEWLINE
    END
   PRINT "]"
   NEWLINE
  END
 CALL JSONCLOSE
END [PROCEDURE]

PROCEDURE POLLSHARES
[* Create list of eligible shares. For each eigible share found, call
** procedure to add the share to the list.
*]
 WHILELIMIT=1000000
 SDCOUNT=0
 FOR TMPLOOP=0 TO SDMAX
  DO
   SDID(TMPLOOP)=""
   SDTYPE(TMPLOOP)=-1
   SDNAME(TMPLOOP)=""
   SDBALANCE(TMPLOOP)=$0.00
   SDODTSTATUS(TMPLOOP)=FALSE
   SDODTNEWSTATUS(TMPLOOP)=FALSE
   SDODTTRACKINGLOC(TMPLOOP)=0
   SDTRACKINGUPDATE(TMPLOOP)=FMUNCHANGED
   SDAUTHFEEUPDATE(TMPLOOP)=0
   SDOVERDRAFTTOLERANCE(TMPLOOP)=$0.00
  END

 FOR EACH SHARE
  DO
   SHAREINVALIDREASON=""
   IF SHARE:CLOSEDATE<>DATENULL THEN
    SHAREINVALIDREASON="Share closed"
   ELSE IF SHARE:CHARGEOFFDATE<>DATENULL THEN
    SHAREINVALIDREASON="Share Charged-off"
   ELSE IF VALIDSHARETYPES(SHARE:TYPE)=FALSE THEN
    SHAREINVALIDREASON="Invalid Share Type"
   ELSE IF SHARE:SHARECODE=2 THEN
    SHAREINVALIDREASON="Cert (Share Code 2)"
   ELSE
    DO
     CALL TESTFORSHAREWARNING
     IF SLAWARNINGFOUND=TRUE THEN
      SHAREINVALIDREASON="Share Warning"
     ELSE
      CALL ADDSHARETOLIST
    END
   IF SHAREINVALIDREASON<>"" THEN
    BNODEBUGMSG="Testing Share ID "+SHARE:ID+": Invalid - "+SHAREINVALIDREASON
   ELSE
    BNODEBUGMSG="Testing Share ID "+SHARE:ID+": Valid - Added"
   CALL BNODEBUGMSGADD
  END
END [PROCEDURE]

PROCEDURE TESTFORSHAREWARNING
[* Test share for targeted warning(s)
*]
 SLAWARNINGFOUND=FALSE
 FOR TMPLOOP=1 TO MAXWARNINGTYPES
  DO
   IF ANYWARNING(SHARE,TMPLOOP) AND
      WARNINGSSHARE(TMPLOOP)=TRUE THEN
    DO
     SLAWARNINGFOUND=TRUE
     TMPLOOP=MAXWARNINGTYPES
    END
  END
END [PROCEDURE]

PROCEDURE ADDSHARETOLIST
[* Increment share counter. If max shares have been reached then
** set flag, else add share to list. Current share ODT status is
** found in share tracking. The first unexpired share tracking found
** will be used.
*]
 SDCOUNT=SDCOUNT+1
 IF SDCOUNT>SDMAX THEN
  SDOVERMAX=TRUE
 ELSE
  DO
   TMPCHR=SHARE:DESCRIPTION
   CALL CLEANUPTEXT

   SDID(SDCOUNT)=SHARE:ID
   SDTYPE(SDCOUNT)=SHARE:TYPE
   SDNAME(SDCOUNT)=TMPCHR
   SDBALANCE(SDCOUNT)=SHARE:AVAILABLEBALANCE
   SDOVERDRAFTTOLERANCE(SDCOUNT)=SHARE:OVERDRAFTTOLERANCE
   FOR EACH SHARE TRACKING WITH (SHARE TRACKING:TYPE=PARAMSHARETRACKING AND
                                (SHARE TRACKING:EXPIREDATE=DATENULL OR
                                 SHARE TRACKING:EXPIREDATE>SYSTEMDATE) AND
                                 SDODTTRACKINGLOC(SDCOUNT)=0)
    DO
     SDODTTRACKINGLOC(SDCOUNT)=SHARE TRACKING:LOCATOR
     SDODTSTATUS(SDCOUNT)=SHARE TRACKING:USERCODE1
    END
  END
END [PROCEDURE]

PROCEDURE READCONFIGFILESETTINGS
[* Read parameter settings from the configuration Letter file.
**  IAT   PARAMINELIGIBLEACCTS  Ineligible Account Type(s) (in LISTEXPAND format)
**  TRK   PARAMSHARETRACKING    The Share tracking type used for ODT tracking
**  ST    PARAMVALIDSHARETYPES  Char list of valid Share types (in LISTEXPAND format)
**  AW    PARAMWARNINGSACCT     Acct level warnings which exclude account (in LISTEXPAND format)
**  SW    PARAMWARNINGSSHARE    Share warnings which exclude share (in LISTEXPAND format)
**  UD    PARAMUPDATEANDF       Should the program update the AUTHFEEOPTION:1 and ODTAUTHFEESRCCODELIST:1 fields
**  SCT   PARAMSC1TRUE          Source code 1 value if opt-in = true
**  SCF   PARAMSC1FALSE         Source code 1 value if opt-in = false
**  AFT   PARAMAF1TRUE          Auth & fee 1 value if opt-in = true
**  AFF   PARAMAF1FALSE         Auth & fee 1 value if opt-in = false
**  MMOSC ALLOWINMEMOMODE       Allow overdraft settings changes when the system is in memo mode (TRUE/FALSE)
**  EDM   PARAMERRDISPLAY       Custom error display messages
**  TC    PARAMCUSTOMTERMS      Custom terms and conditions
**  FD    PARAMFEEDISCL         Custom fee disclosure
**  RI    PARAMREVOKEINST       Revocation instructions
**  OIO   PARAMOPTINOUTINFO     Opt-in/Opt-out Information Text
**  SI    PARAMSERVICEINST      Service Instructions
**  OI    PARAMOPTININFO        Opt-in Information Text
**  OO    PARAMOPTOUTINFO       Opt-out Information Text
**  CMMS  PARAMMEMOMODESUCCESS  Custom overdraft settings changes during memo mode success message
**  CSM   PARAMSUCCESSMSG       Custom success message displayed when member changes overdraft settings
**  CMMM  PARAMMEMOMODEMSG      Custom memo mode message when "Allow maturity option changes in memo mode" is FALSE
**  OTA   PARAMOTAAMOUNT        Overdraft Tolerance Amount
**  COTA  PARAMCOTA             Clear ODT amount on opt-out
**  PID   PARAMINSTALLDATE      Date program installed at CU
*]
 INVALIDCONFIGPARAMS=FALSE
 PARAMDEBUGMODEFOUND=FALSE
 DEFAULTOTAVALUE=-$0.01

 FILEOPEN("LETTER",CONFIGFILENAME,"READ",LFNUMBER,LFERROR)

 IF LFERROR<>"" THEN
  DO
   READCONFIGERROR=TRUE
   READCONFIGERRORMSG="Error Opening Letterfile "+CONFIGFILENAME+": "+LFERROR
  END
 ELSE
  DO
   FILEREADLINE(LFNUMBER,LFLINE,LFERROR)
   WHILE LFERROR=""
    DO
     CALL NORMALIZEDATA
     IF PARAMNAME<>"" THEN
      DO
[* Ineligible Account Type(s)
*]
       IF PARAMNAME="IAT" AND
          PARAMVALUE<>"" THEN
        PARAMINELIGIBLEACCTS=PARAMVALUE

[* Share Tracking Type
*]
       IF PARAMNAME="TRK" AND
          PARAMVALUE<>"" THEN
        PARAMSHARETRACKING=VALUE(PARAMVALUE)

[* Valid Share Types
*]
       IF PARAMNAME="ST" THEN
        PARAMVALIDSHARETYPES=PARAMVALUE
[* Account Warnings
*]
       ELSE IF PARAMNAME="AW" AND
               PARAMVALUE<>"" THEN
        PARAMWARNINGSACCT=PARAMVALUE
[* Share Warnings
*]
       ELSE IF PARAMNAME="SW" AND
               PARAMVALUE<>"" THEN
        PARAMWARNINGSSHARE=PARAMVALUE
[* Update Auth And Fee
*]
       ELSE IF PARAMNAME="UD" THEN
        DO
         IF PARAMVALUE="FALSE" THEN
          PARAMUPDATEANDF=FALSE
        END
[* Source Code 1 when update A&F true & Opt-in true
*]
       ELSE IF PARAMNAME="SCT" THEN
        PARAMSC1TRUE=UPPERCASE(PARAMVALUE)
[* Source Code 1 when update A&F true & opt-in false
*]
       ELSE IF PARAMNAME="SCF" THEN
        PARAMSC1FALSE=UPPERCASE(PARAMVALUE)
[* Auth/Fee Option 1 when update A&F true & Opt-in true
*]
       ELSE IF PARAMNAME="AFT" AND
               PARAMVALUE<>"" THEN
        PARAMAF1TRUE=VALUE(PARAMVALUE)
[* Auth/Fee Option 1 when update A&F true & opt-in false
*]
       ELSE IF PARAMNAME="AFF" AND
               PARAMVALUE<>"" THEN
        PARAMAF1FALSE=VALUE(PARAMVALUE)
[* Overdraft Tolerance Amount
*]
       ELSE IF PARAMNAME="OTA" AND
               PARAMVALUE<>"" THEN
        DO
         COLONPOS=CHARACTERSEARCH(PARAMVALUE,":")
         IF COLONPOS>1 AND
            COLONPOS<LENGTH(PARAMVALUE) THEN
          DO
           IF UPPERCASE(SEGMENT(PARAMVALUE,1,COLONPOS-1))="XXXX" THEN
            DO
             DEFAULTOTAVALUE=MONEY(VALUE(SEGMENT(PARAMVALUE,COLONPOS+1,LENGTH(PARAMVALUE))))
             TMPCHR=FORMAT("###,###,##9.99",DEFAULTOTAVALUE)
             CALL NLS
             DEFAULTOTAVALUECHR=TMPCHR
             BNODEBUGMSG="Default OTA value FOUND: $"+DEFAULTOTAVALUECHR
             CALL BNODEBUGMSGADD
            END
           ELSE IF PARAMOTACOUNT<PARAMOTAMAX THEN
            DO
             PARAMOTACOUNT=PARAMOTACOUNT+1
             PARAMOTASHARETYPE(PARAMOTACOUNT)=VALUE(SEGMENT(PARAMVALUE,1,COLONPOS-1))
             PARAMOTAAMOUNT(PARAMOTACOUNT)=MONEY(VALUE(SEGMENT(PARAMVALUE,COLONPOS+1,LENGTH(PARAMVALUE))))
            END
          END [IF COLONPOS>1 AND...]
        END [ELSE IF PARAMNAME="OTA" AND...]
       ELSE IF PARAMNAME="COTA" THEN
        DO
         IF CHARACTERSEARCH("YESTRUE1",UPPERCASE(PARAMVALUE))>0 THEN
          PARAMCOTA=TRUE
         ELSE
          PARAMCOTA=FALSE
        END [ELSE IF PARAMNAME="COTA"]
[* Debug mode. This is a hidden parameter setting which can override the default debug
** mode setting. Use this "DB:" parameter setting in the CFG Letter file with "ON"
** or "OFF" to force the debug mode to be other than the default value of being on for
** the first 90 days after the most recent program modification date.
*]
       ELSE IF PARAMNAME="DB" THEN
        DO
         PARAMDEBUGMODEFOUND=TRUE
         IF CHARACTERSEARCH("ONTRUEYES",UPPERCASE(PARAMVALUE))>0 THEN
          PARAMDEBUGMODE=BNODEBUGMODEON
         ELSE IF CHARACTERSEARCH("OFFFALSENO",UPPERCASE(PARAMVALUE))>0 THEN
          PARAMDEBUGMODE=BNODEBUGMODEOFF
        END
[* Allow overdraft settings changes in memo mode?
*]
       ELSE IF PARAMNAME="MMOSC" AND
               CHARACTERSEARCH("ONTRUEYES",UPPERCASE(PARAMVALUE))>0 THEN
        ALLOWINMEMOMODE=TRUE

[* Custom error display messages
*]
       ELSE IF SEGMENT(PARAMNAME,1,3)="EDM" THEN
        DO
         TMPERRCODE=VALUE(SEGMENT(PARAMNAME,4,6))
         IF CHARACTERSEARCH(PARAMERRDISPLAYERRLIST,FORMAT("999",TMPERRCODE))>0 THEN
          DO
           TMPCHR=PARAMVALUE
           CALL NTS
           CALL CLEANUPTEXT
[* Retain only first 99 characters of value (whole cfg line can be 106) 
** to account for JSON spacing and field delimiters
*]
           TMPDISPLAYLINE=SEGMENT(TMPCHR,1,99)

           CALL PARAMERRDISPLAYADD
          END
        END

[* Custom terms & conditions
*]
       ELSE IF PARAMNAME="TC" THEN
        DO
         IF PARAMCUSTOMTERMLINES<PARAMCUSTOMTERMLINESMAX THEN
          DO
           PARAMCUSTOMTERMLINES=PARAMCUSTOMTERMLINES+1
           TMPCHR=PARAMVALUE
           CALL NTS
           CALL CLEANUPTEXT
           PARAMCUSTOMTERMS(PARAMCUSTOMTERMLINES)=TMPCHR
          END
        END
[* Custom Fee Disclosure
*]
       ELSE IF PARAMNAME="FD" THEN
        DO
         IF PARAMFEEDISCLLINES<PARAMCUSTOMTERMLINESMAX THEN
          DO
           PARAMFEEDISCLLINES=PARAMFEEDISCLLINES+1
           TMPCHR=PARAMVALUE
           CALL NTS
           CALL CLEANUPTEXT
           PARAMFEEDISCL(PARAMFEEDISCLLINES)=TMPCHR
          END
        END
[* Revocation Instructions
*]
       ELSE IF PARAMNAME="RI" THEN
        DO
         IF PARAMREVOKEINSTLINES<PARAMREVOKEINSTLINESMAX THEN
          DO
           PARAMREVOKEINSTLINES=PARAMREVOKEINSTLINES+1
           TMPCHR=PARAMVALUE
           CALL NTS
           CALL CLEANUPTEXT
           PARAMREVOKEINST(PARAMREVOKEINSTLINES)=TMPCHR
          END
        END
[* Service Instructions
*]
       ELSE IF PARAMNAME="SI" THEN
        DO
         IF PARAMSERVICEINSTLINES<PARAMSERVICEINSTLINESMAX THEN
          DO
           PARAMSERVICEINSTLINES=PARAMSERVICEINSTLINES+1
           TMPCHR=PARAMVALUE
           CALL NTS
           CALL CLEANUPTEXT
           PARAMSERVICEINST(PARAMSERVICEINSTLINES)=TMPCHR
          END
        END
[* Opt-in Information Text
*]
       ELSE IF PARAMNAME="OI" THEN
        DO
         IF PARAMOPTININFOTEXTLINES<PARAMOPTININFOTEXTLINESMAX THEN
          DO
           PARAMOPTININFOTEXTLINES=PARAMOPTININFOTEXTLINES+1
           TMPCHR=PARAMVALUE
           CALL NTS
           CALL CLEANUPTEXT
           PARAMOPTININFOTEXT(PARAMOPTININFOTEXTLINES)=TMPCHR
          END
        END
[* Opt-out Information Text
*]
       ELSE IF PARAMNAME="OO" THEN
        DO
         IF PARAMOPTOUTINFOTEXTLINES<PARAMOPTOUTINFOTEXTLINESMAX THEN
          DO
           PARAMOPTOUTINFOTEXTLINES=PARAMOPTOUTINFOTEXTLINES+1
           TMPCHR=PARAMVALUE
           CALL NTS
           CALL CLEANUPTEXT
           PARAMOPTOUTINFOTEXT(PARAMOPTOUTINFOTEXTLINES)=TMPCHR
          END
        END
[* Opt-in/Opt-out Information Text
*]
       ELSE IF PARAMNAME="OIO" THEN
        DO
         IF PARAMOPTINOUTINFOTEXTLINES<PARAMOPTINOUTINFOTEXTLINESMAX THEN
          DO
           PARAMOPTINOUTINFOTEXTLINES=PARAMOPTINOUTINFOTEXTLINES+1
           TMPCHR=PARAMVALUE
           CALL NTS
           CALL CLEANUPTEXT
           PARAMOPTINOUTINFOTEXT(PARAMOPTINOUTINFOTEXTLINES)=TMPCHR
          END
        END
[* Custom memo mode message
*]
       ELSE IF PARAMNAME="CMMS" THEN
        DO
         IF MEMOSUCCESSMSGSETFLAG=FALSE THEN
          DO
           MEMOSUCCESSMSGSETFLAG=TRUE
           PARAMMEMOMODESUCCESSLINES=0 [Blank the defalut values, as "CMMS:" is set in the CFG]
           PARAMMEMOMODESUCCESS(1)=""
           PARAMMEMOMODESUCCESS(2)=""         
          END
         IF PARAMMEMOMODESUCCESSLINES<PARAMMEMOMODESUCCESSLINESMAX THEN
          DO
           PARAMMEMOMODESUCCESSLINES=PARAMMEMOMODESUCCESSLINES+1
           TMPCHR=PARAMVALUE
           CALL NTS
           CALL CLEANUPTEXT
           PARAMMEMOMODESUCCESS(PARAMMEMOMODESUCCESSLINES)=TMPCHR
          END
        END
[* Custom success message
*]
       ELSE IF PARAMNAME="CSM" THEN
        DO
         IF PARAMSUCCESSMSGLINES<PARAMSUCCESSMSGLINESMAX THEN
          DO
           PARAMSUCCESSMSGLINES=PARAMSUCCESSMSGLINES+1
           TMPCHR=PARAMVALUE
           CALL NTS
           CALL CLEANUPTEXT
           PARAMSUCCESSMSG(PARAMSUCCESSMSGLINES)=TMPCHR
          END
        END        
[* Custom Memo Mode Message
*]
       ELSE IF PARAMNAME="CMMM" THEN
        DO
         IF PARAMMEMOMODEMSGLINES<PARAMMEMOMODEMSGLINESMAX THEN
          DO
           PARAMMEMOMODEMSGLINES=PARAMMEMOMODEMSGLINES+1
           TMPCHR=PARAMVALUE
           CALL NTS
           CALL CLEANUPTEXT
           PARAMMEMOMODEMSG(PARAMMEMOMODEMSGLINES)=TMPCHR
          END
        END   
    
[* Program Installation Date
*]
       ELSE IF PARAMNAME="PID" AND
               PARAMVALUE<>"" THEN
        PARAMINSTALLDATE=DATEVALUE(PARAMVALUE)
      END

     PARAMNAME=""
     PARAMVALUE=""
     FILEREADLINE(LFNUMBER,LFLINE,LFERROR)
    END [WHILE LFERROR=""]

   IF PARAMOPTINOUTINFOTEXTLINES=1 AND
      PARAMOPTINOUTINFOTEXT(1)="" THEN
    PARAMOPTINOUTINFOTEXTLINES=0

   IF LFERROR<>"" AND
      LFERROR<>"EOF" THEN
    DO
     READCONFIGERROR=TRUE
     READCONFIGERRORMSG="Error Reading Letterfile "+CONFIGFILENAME+": "+LFERROR
    END
   FILECLOSE(LFNUMBER,LFERROR)
  END

[* Ignore error display messages for a code if only one blank line is configured
*]
 FOR TMPLOOP=1 TO PARAMERRDISPLAYCOUNT
  DO
   IF PARAMERRDISPLAY(TMPLOOP,ERRDISPLAYLINECOUNT)=1 AND 
      PARAMERRDISPLAYLINES(TMPLOOP,1)="" THEN
    PARAMERRDISPLAY(TMPLOOP,ERRDISPLAYLINECOUNT)=0
  END

[* Update debugmode
**   If the "DB" parameter is found and it's set to false, then force debug
**     mode to off (overrides all other debug mode logic settings).
**   If the "DB" parameter is set to true or the installation date was found and
**     less than 90 days prior, set the debug mode to true.
**   Otherwise, use the current state of the debug mode as set by the last
**     mod date.
*]

 IF PARAMDEBUGMODEFOUND=TRUE AND
    PARAMDEBUGMODE=BNODEBUGMODEOFF THEN
  BNODEBUGMODE=BNODEBUGMODEOFF
 ELSE
  DO
   IF PARAMDEBUGMODE=BNODEBUGMODEON OR
     (PARAMINSTALLDATE<>DATENULL AND
      PARAMINSTALLDATE+90>SYSTEMDATE) THEN
    BNODEBUGMODE=BNODEBUGMODEON
  END

[* Add the parameter settings to the debug output
*]
 IF BNOINCLUDEPARMINDEBUG=TRUE THEN
  DO
   BNODEBUGMSG=REPEATCHR("=",120) CALL BNODEBUGMSGADD
   BNODEBUGMSG="START PARAMETER SETTINGS:" CALL BNODEBUGMSGADD
   BNODEBUGMSG="  TRK: "+FORMAT("99",PARAMSHARETRACKING) CALL BNODEBUGMSGADD
   BNODEBUGMSG="  IAT: "+PARAMINELIGIBLEACCTS CALL BNODEBUGMSGADD
   BNODEBUGMSG="  ST: "+PARAMVALIDSHARETYPES CALL BNODEBUGMSGADD
   BNODEBUGMSG="  AW: "+PARAMWARNINGSACCT CALL BNODEBUGMSGADD
   BNODEBUGMSG="  SW: "+PARAMWARNINGSSHARE CALL BNODEBUGMSGADD
   BNODEBUGMSG="  UD: "+FORMAT("9",PARAMUPDATEANDF) CALL BNODEBUGMSGADD
   BNODEBUGMSG="  SCT: "+PARAMSC1TRUE CALL BNODEBUGMSGADD
   BNODEBUGMSG="  SCF: "+PARAMSC1FALSE CALL BNODEBUGMSGADD
   BNODEBUGMSG="  AFT: "+FORMAT("9",PARAMAF1TRUE) CALL BNODEBUGMSGADD
   BNODEBUGMSG="  AFF: "+FORMAT("9",PARAMAF1FALSE) CALL BNODEBUGMSGADD
   BNODEBUGMSG="  PARAMDEBUGMODE: "+FORMAT("9",PARAMDEBUGMODE) CALL BNODEBUGMSGADD
   BNODEBUGMSG="  PID: "+FORMAT("99/99/9999",PARAMINSTALLDATE) CALL BNODEBUGMSGADD
   BNODEBUGMSG="  COTA: "+FORMAT("9",PARAMCOTA) CALL BNODEBUGMSGADD
   BNODEBUGMSG="  ALLOWINMEMOMODE: "+BOOLEANCHR(ALLOWINMEMOMODE) CALL BNODEBUGMSGADD
   BNODEBUGMSG="  BNODEBUGMODE: "+BOOLEANCHR(BNODEBUGMODE) CALL BNODEBUGMSGADD

   IF DEFAULTOTAVALUE>=$0.00 THEN
    DO
     TMPCHR=FORMAT("###,###,##9.99",DEFAULTOTAVALUE)
     CALL NLS
     BNODEBUGMSG="  OTA DEFAULT 'XXXX' AMOUNT $"+TMPCHR
     CALL BNODEBUGMSGADD
    END
   FOR TMPLOOP=1 TO PARAMOTACOUNT
    DO
     TMPCHR=FORMAT("###,###,##9.99",PARAMOTAAMOUNT(TMPLOOP))
     CALL NLS
     BNODEBUGMSG=FORMAT("  OTA 99 -",TMPLOOP)+
                 FORMAT("  SHARE TYPE 9999  ",PARAMOTASHARETYPE(TMPLOOP))+
                 "  OT AMOUNT $"+TMPCHR
     CALL BNODEBUGMSGADD
    END

   BNODEBUGMSG="Custom EDM:"
   CALL BNODEBUGMSGADD
   FOR TMPLOOP=1 TO PARAMERRDISPLAYCOUNT
    DO
     FOR TMPLOOP2=1 TO PARAMERRDISPLAY(TMPLOOP,ERRDISPLAYLINECOUNT)
      DO
       TMPCHR=PARAMERRDISPLAYLINES(TMPLOOP,TMPLOOP2)
       CALL NTS
       BNOERRDISPLAYLINE=TMPCHR
        IF PARAMERRDISPLAY(TMPLOOP,ERRDISPLAYLINECOUNT)>0 THEN
         DO
          BNODEBUGMSG="EC "+FORMAT("999:",PARAMERRDISPLAY(TMPLOOP,ERRDISPLAYERRCODE))+"'"
          BNODEBUGMSG=BNODEBUGMSG+FORMAT("999:",TMPLOOP2)+"'"+BNOERRDISPLAYLINE+"'"
          CALL BNODEBUGMSGADD
         END
      END
    END

   BNODEBUGMSG="Custom TOC:"
   CALL BNODEBUGMSGADD
   FOR TMPLOOP=1 TO PARAMCUSTOMTERMLINES
    DO
     BNODEBUGMSG=FORMAT("999:",TMPLOOP)+"'"+PARAMCUSTOMTERMS(TMPLOOP)+"'"
     CALL BNODEBUGMSGADD
    END

   BNODEBUGMSG="Custom Fee Disclosure:"
   CALL BNODEBUGMSGADD
   FOR TMPLOOP=1 TO PARAMFEEDISCLLINES
    DO
     BNODEBUGMSG=FORMAT("999:",TMPLOOP)+"'"+PARAMFEEDISCL(TMPLOOP)+"'"
     CALL BNODEBUGMSGADD
    END

   BNODEBUGMSG="Custom Revoke Instructions:"
   CALL BNODEBUGMSGADD
   FOR TMPLOOP=1 TO PARAMREVOKEINSTLINES
    DO
     BNODEBUGMSG=FORMAT("999:",TMPLOOP)+"'"+PARAMREVOKEINST(TMPLOOP)+"'"
     CALL BNODEBUGMSGADD
    END

   BNODEBUGMSG="Custom Service Instructions:"
   CALL BNODEBUGMSGADD
   FOR TMPLOOP=1 TO PARAMSERVICEINSTLINES
    DO
     BNODEBUGMSG= FORMAT("999:",TMPLOOP)+"'"+PARAMSERVICEINST(TMPLOOP)+"'"
     CALL BNODEBUGMSGADD
    END

   BNODEBUGMSG="Custom Opt-in/out Instructions:"
   CALL BNODEBUGMSGADD
   FOR TMPLOOP=1 TO PARAMOPTINOUTINFOTEXTLINES
    DO
     BNODEBUGMSG= FORMAT("999:",TMPLOOP)+"'"+PARAMOPTINOUTINFOTEXT(TMPLOOP)+"'"
     CALL BNODEBUGMSGADD
    END

   BNODEBUGMSG="Custom Opt-in Instructions:"
   CALL BNODEBUGMSGADD
   FOR TMPLOOP=1 TO PARAMOPTININFOTEXTLINES
    DO
     BNODEBUGMSG= FORMAT("999:",TMPLOOP)+"'"+PARAMOPTININFOTEXT(TMPLOOP)+"'"
     CALL BNODEBUGMSGADD
    END

   BNODEBUGMSG="Custom Opt-out Instructions:"
   CALL BNODEBUGMSGADD
   FOR TMPLOOP=1 TO PARAMOPTOUTINFOTEXTLINES
    DO
     BNODEBUGMSG= FORMAT("999:",TMPLOOP)+"'"+PARAMOPTOUTINFOTEXT(TMPLOOP)+"'"
     CALL BNODEBUGMSGADD
    END

   BNODEBUGMSG="Custom Memo Mode Success Message:"
   CALL BNODEBUGMSGADD
   FOR TMPLOOP=1 TO PARAMMEMOMODESUCCESSLINES
    DO
     BNODEBUGMSG= FORMAT("999:",TMPLOOP)+"'"+PARAMMEMOMODESUCCESS(TMPLOOP)+"'"
     CALL BNODEBUGMSGADD
    END

   BNODEBUGMSG="Custom Success Message:"
   CALL BNODEBUGMSGADD
   FOR TMPLOOP=1 TO PARAMSUCCESSMSGLINES
    DO
     BNODEBUGMSG= FORMAT("999:",TMPLOOP)+"'"+PARAMSUCCESSMSG(TMPLOOP)+"'"
     CALL BNODEBUGMSGADD
    END

   BNODEBUGMSG="Custom Memo Mode Message:"
   CALL BNODEBUGMSGADD
   FOR TMPLOOP=1 TO PARAMMEMOMODEMSGLINES
    DO
     BNODEBUGMSG= FORMAT("999:",TMPLOOP)+"'"+PARAMMEMOMODEMSG(TMPLOOP)+"'"
     CALL BNODEBUGMSGADD
    END

   BNODEBUGMSG="END PARAMETER SETTINGS:" CALL BNODEBUGMSGADD
   BNODEBUGMSG=REPEATCHR("=",120) CALL BNODEBUGMSGADD
  END [IF BNOINCLUDEPARMINDEBUG=TRUE]

 LELISTINPUT=PARAMINELIGIBLEACCTS
 IF LELISTINPUT="" THEN
  LELISTINPUT="NONE"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO 9999
  DO
   INVALIDACCTYPES(TMPLOOP)=LELIST(TMPLOOP)
  END

 LELISTINPUT=PARAMVALIDSHARETYPES
 IF LELISTINPUT="" THEN
  LELISTINPUT="ALL"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO MAXSLTYPES
  DO
   VALIDSHARETYPES(TMPLOOP)=LELIST(TMPLOOP)
  END

 LELISTINPUT=PARAMWARNINGSACCT
 IF LELISTINPUT="" THEN
  LELISTINPUT="NONE"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO MAXWARNINGTYPES
  DO
   WARNINGSACCT(TMPLOOP)=LELIST(TMPLOOP)
  END

 LELISTINPUT=PARAMWARNINGSSHARE
 IF LELISTINPUT="" THEN
  LELISTINPUT="NONE"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO MAXWARNINGTYPES
  DO
   WARNINGSSHARE(TMPLOOP)=LELIST(TMPLOOP)
  END

 FOR TMPLOOP=1 TO PARAMERRDISPLAYCOUNT
  DO
   FOR TMPLOOP2=1 TO PARAMERRDISPLAY(TMPLOOP,ERRDISPLAYLINECOUNT)
    DO
     TMPCHR=PARAMERRDISPLAYLINES(TMPLOOP,TMPLOOP2)
     CALL NTS
     BNOERRDISPLAYLINE=TMPCHR
     CALL BNOERRDISPLAYAPPEND
    END
   BNOERRCODE=PARAMERRDISPLAY(TMPLOOP,ERRDISPLAYERRCODE) 
   CALL BNOERRDISPLAYUPDATE
  END

 IF READCONFIGERROR=TRUE THEN
  DO
   NEWLINE
   CALL JSONOPEN
   BNOERRORCODE=BNOERRCODECFGPARSE
   BNOERRCODE=BNOERRCODECFGPARSE
   BNOERRMESSAGE=READCONFIGERRORMSG
   CALL ERRORHANDLER
   @RGSTATE=STATEEND
  END
 ELSE
  CALL VALIDATEPARAMS

END [PROCEDURE]

PROCEDURE VALIDATEPARAMS
[* Validate required parameters to make sure all necessary
** parameter settings are present and within required ranges
*]
 PARAMVALIDATIONERROR=FALSE
[* Validate tracking record (<=3 and <=99)
*]
 IF PARAMSHARETRACKING<30 OR
    PARAMSHARETRACKING>99 THEN
  DO
   PARAMVALIDATIONERROR=TRUE
   PARAMVALIDATIONERRORCHR="Invalid tracking type"
  END

[* validate source code list entries  - if true or false
*]
 IF PARAMVALIDATIONERROR=FALSE AND
    PARAMUPDATEANDF=TRUE AND
    LENGTH(PARAMSC1TRUE)>0 THEN
  DO
   FOR TMPLOOP=1 TO LENGTH(PARAMSC1TRUE)
    DO
     TMPCHR=SEGMENT(PARAMSC1TRUE,TMPLOOP,TMPLOOP)
     IF CHARACTERSEARCH(VALIDSOURCECODELIST,TMPCHR)=0 THEN
      DO
       PARAMVALIDATIONERROR=TRUE
       PARAMVALIDATIONERRORCHR="Invalid source code for SCT in CFG"
       TMPLOOP=LENGTH(PARAMSC1TRUE)
      END
    END
  END

 IF PARAMVALIDATIONERROR=FALSE AND
    PARAMUPDATEANDF=TRUE AND
    LENGTH(PARAMSC1FALSE)>0 THEN
  DO
   FOR TMPLOOP=1 TO LENGTH(PARAMSC1FALSE)
    DO
     TMPCHR=SEGMENT(PARAMSC1FALSE,TMPLOOP,TMPLOOP)
     IF CHARACTERSEARCH(VALIDSOURCECODELIST,TMPCHR)=0 THEN
      DO
       PARAMVALIDATIONERROR=TRUE
       PARAMVALIDATIONERRORCHR="Invalid source code for SCF in CFG"
       TMPLOOP=LENGTH(PARAMSC1FALSE)
      END
    END
  END

 IF PARAMVALIDATIONERROR=FALSE AND
    PARAMUPDATEANDF=TRUE AND
   (PARAMAF1TRUE<0 OR
    PARAMAF1TRUE>7) THEN
  DO
   PARAMVALIDATIONERROR=TRUE
   PARAMVALIDATIONERRORCHR="Invalid auth/fee option for AFT in CFG"
  END

 IF PARAMVALIDATIONERROR=FALSE AND
    PARAMUPDATEANDF=TRUE AND
   (PARAMAF1FALSE<0 OR
    PARAMAF1FALSE>7) THEN
  DO
   PARAMVALIDATIONERROR=TRUE
   PARAMVALIDATIONERRORCHR="Invalid auth/fee option for AFF in CFG"
  END

 IF PARAMVALIDATIONERROR=TRUE THEN
  DO
   NEWLINE
   CALL JSONOPEN
   BNOERRORCODE=BNOERRCODEINVALIDPARAM
   BNOERRCODE=BNOERRCODEINVALIDPARAM
   BNOERRMESSAGE="Config file validation error: "+PARAMVALIDATIONERRORCHR
   CALL ERRORHANDLER
   @RGSTATE=STATEEND
  END
END [PROCEDURE]

PROCEDURE NORMALIZEDATA
[* Normalize the data and if a parameter, separate into
** parameter name and value
** PASS    LFLINE          Character line read in
** RETURN  PARAMNAME       Parameter name found
** RETURN  PARAMVALUE      Parameter value
**
*]
 PARAMNAME=""
 PARAMVALUE=""

 POS=CHARACTERSEARCH(LFLINE,":")
 IF LFLINE<>"" AND
    SEGMENT(LFLINE,1,1)<>"*" AND
    POS>1 THEN
  DO
   TMPCHR=SEGMENT(LFLINE,1,POS-1)
   CALL NLTS
   PARAMNAME=UPPERCASE(TMPCHR)

   TMPCHR=SEGMENT(LFLINE,POS+1,LENGTH(LFLINE))
   CALL NLTS
   PARAMVALUE=TMPCHR
  END
END [PROCEDURE]

PROCEDURE NLTS
[* Remove leading AND trailing spaces
**  PASS       TMPCHR
**  RETURN     TMPCHR
*]
 CALL NTS
 IF TMPCHR<>"" THEN
  CALL NLS
END [PROCEDURE]

PROCEDURE NLS
[* Remove leading spaces
**  PASS       TMPCHR
**  RETURN     TMPCHR
*]
 WHILE (LENGTH(TMPCHR)>0 AND
        SEGMENT(TMPCHR,1,1)=" ")
  DO
   IF LENGTH(TMPCHR)=1 THEN
    TMPCHR=""
   ELSE
    TMPCHR=SEGMENT(TMPCHR,2,LENGTH(TMPCHR))
  END
 IF LENGTH(TMPCHR)=0 THEN
  TMPCHR=""
END [PROCEDURE]

PROCEDURE NTS
[* Remove trailing spaces
**  PASS       TMPCHR
**  RETURN     TMPCHR
*]
 IF TMPCHR<>"" THEN
  TMPCHR=SEGMENT(TMPCHR,1,LENGTH(TMPCHR))
 IF LENGTH(TMPCHR)=0 THEN
  TMPCHR=""
END [PROCEDURE]

PROCEDURE CLEANUPTEXT
[* Check character string and remove out any characters or hidden
** characters which have an ASCII value which is not established in
** the VALIDCHRINPUT1 string in the SETUP division . This is to avoid
** display issues with displaying the terms or conditions. Additionally,
** if a back-slash or double quote is encountered, add a preceding
** backslash
**  PASS       TMPCHR   String to test
**  RETURN     TMPCHR   Updated string
*]
 LELISTINPUT=VALIDCHRINPUT1
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO MAXCHRVALUE
  DO
   VALIDCHARS(TMPLOOP)=LELIST(TMPLOOP)
  END
 TMPTEXT=""

 IF TMPCHR<>"" THEN
  DO
   FOR TMPTEXTLOOP=1 TO LENGTH(TMPCHR)
    DO
     CHRVAL=CHRVALUE(SEGMENT(TMPCHR,TMPTEXTLOOP,TMPTEXTLOOP))
     IF  VALIDCHARS(CHRVAL)=TRUE THEN
      DO
[* Check for back-slash or double-quote. If found, precede with a back-slash
*]
       IF (CHRVAL=92 OR CHRVAL=34) THEN
        TMPTEXT=TMPTEXT+BACKSLASH+SEGMENT(TMPCHR,TMPTEXTLOOP,TMPTEXTLOOP)
       ELSE
        TMPTEXT=TMPTEXT+SEGMENT(TMPCHR,TMPTEXTLOOP,TMPTEXTLOOP)
      END
    END
  END
 TMPCHR=TMPTEXT
END [PROCEDURE]

PROCEDURE INITIALIZEDATA
[* Initialize state variables
*]
 WHILELIMIT=100000
 LFNUMBER=0
 LFERROR=""
 MEMBERNUM=""
 SLTYPE=""
 SLID=""
 READCONFIGERROR=FALSE
 READCONFIGERRORMSG=""
 LFERROR=""
 LFNUMBER=0
 BNOERRORCODE=0

 PARAMINELIGIBLEACCTS="NONE"
 PARAMVALIDSHARETYPES="ALL"
 PARAMWARNINGSACCT="NONE"
 PARAMWARNINGSSHARE="NONE"
 PARAMUPDATEANDF=TRUE
 PARAMSC1TRUE=""
 PARAMSC1FALSE="GOBA"
 PARAMAF1TRUE=0
 PARAMAF1FALSE=7
 PARAMCUSTOMTERMLINES=0
 PARAMREVOKEINSTLINES=0
 PARAMSERVICEINSTLINES=0
 PARAMOPTININFOTEXTLINES=0
 PARAMOPTOUTINFOTEXTLINES=0
 PARAMOPTINOUTINFOTEXTLINES=0
 PARAMSHARETRACKING=0
 PARAMOTACOUNT=0
 PARAMINSTALLDATE=DATENULL
 ALLOWINMEMOMODE=FALSE
 PARAMMEMOMODESUCCESSLINES=0
 PARAMSUCCESSMSGLINES=0
 PARAMMEMOMODEMSGLINES=0
 PARAMERRDISPLAYCOUNT=0
 MEMOSUCCESSMSGSETFLAG=FALSE
 PARAMMEMOMODESUCCESSLINES=2 [In case "CMMS:" is not used in CFG, provide default value]
 PARAMMEMOMODESUCCESS(1)="Nightly processing is underway. Your overdraft settings have been processed"
 PARAMMEMOMODESUCCESS(2)="and will be reflected the next business day."
 FOR TMPLOOP=0 TO PARAMERRDISPLAYMAX
  DO
   PARAMERRDISPLAY(TMPLOOP,ERRDISPLAYERRCODE)=0
   PARAMERRDISPLAY(TMPLOOP,ERRDISPLAYLINECOUNT)=0
  END

 FOR TMPLOOP=0 TO PARAMCUSTOMTERMLINESMAX
  DO
   PARAMCUSTOMTERMS(TMPLOOP)=""
   PARAMFEEDISCL(TMPLOOP)=""
  END

 FOR TMPLOOP=0 TO PARAMREVOKEINSTLINESMAX
  DO
   PARAMREVOKEINST(TMPLOOP)=""
  END

 FOR TMPLOOP=0 TO PARAMSERVICEINSTLINESMAX
  DO
   PARAMSERVICEINST(TMPLOOP)=""
  END

 FOR TMPLOOP=0 TO PARAMOPTININFOTEXTLINESMAX
  DO
   PARAMOPTININFOTEXT(TMPLOOP)=""
  END

 FOR TMPLOOP=0 TO PARAMOPTOUTINFOTEXTLINESMAX
  DO
   PARAMOPTOUTINFOTEXT(TMPLOOP)=""
  END

 FOR TMPLOOP=0 TO PARAMOPTINOUTINFOTEXTLINESMAX
  DO
   PARAMOPTINOUTINFOTEXT(TMPLOOP)=""
  END

 FOR TMPLOOP=0 TO MAXSLTYPES
  DO
   VALIDSHARETYPES(TMPLOOP)=FALSE
  END

 FOR TMPLOOP=0 TO MAXWARNINGTYPES
  DO
   WARNINGSACCT(TMPLOOP)=FALSE
   WARNINGSSHARE(TMPLOOP)=FALSE
  END
END [PROCEDURE]

PROCEDURE PARAMERRDISPLAYADD
[* Adds the lines of custom display soft text for Error Messages that are filled in
** in the configuration file to the initial PARAMERRDISPLAY arrays. And the data is later
** reorganized in the BNOERRDISPLAYMSGS arrays in another procedure BNOERRDISPLAYUPDATE.
*]
 FOUNDINDEX=1
 FOUND=FALSE
 WHILE FOUNDINDEX<=PARAMERRDISPLAYCOUNT AND FOUND=FALSE
  DO
   IF PARAMERRDISPLAY(FOUNDINDEX,ERRDISPLAYERRCODE)=TMPERRCODE THEN
    FOUND=TRUE
   ELSE 
    FOUNDINDEX=FOUNDINDEX+1
  END

 IF FOUNDINDEX<=PARAMERRDISPLAYMAX THEN
  DO
   IF FOUND=FALSE THEN
    DO
     PARAMERRDISPLAYCOUNT=FOUNDINDEX
     PARAMERRDISPLAY(FOUNDINDEX,ERRDISPLAYERRCODE)=TMPERRCODE
     PARAMERRDISPLAY(FOUNDINDEX,ERRDISPLAYLINECOUNT)=1
     PARAMERRDISPLAYLINES(FOUNDINDEX,1)=TMPDISPLAYLINE
    END
   ELSE IF PARAMERRDISPLAY(FOUNDINDEX,ERRDISPLAYLINECOUNT)<PARAMERRDISPLAYLINESMAX THEN
    DO
     PARAMERRDISPLAY(FOUNDINDEX,ERRDISPLAYLINECOUNT)=PARAMERRDISPLAY(FOUNDINDEX,ERRDISPLAYLINECOUNT)+1
     PARAMERRDISPLAYLINES(FOUNDINDEX,PARAMERRDISPLAY(FOUNDINDEX,ERRDISPLAYLINECOUNT))=TMPDISPLAYLINE
    END 
  END
END [PROCEDURE]
[*
**  --------------------------------------------------------------------
**  Debug/Error Processing Procedures
**  --------------------------------------------------------------------
*]
PROCEDURE BNOERRADD
[* Adds an error code to the valid list of error codes
**
**  PASS    BNOERRCODE       Numeric error code
**  PASS    BNOERRMESSAGE    Error description
*]

 IF BNOERRCOUNT<BNOERRMAX THEN
  DO
   BNOERRCOUNT=BNOERRCOUNT+1
   BNOERRCODES(BNOERRCOUNT)=BNOERRCODE
   BNOERRMESSAGES(BNOERRCOUNT)=BNOERRMESSAGE
  END
 BNOERRMESSAGE=""
END [PROCEDURE]

PROCEDURE BNOERRUPDATE
[* Updates an error code error message or display message
**
**  PASS    BNOERRCODE       Numeric error code
**  PASS    BNOERRMESSAGE    Error description
*]

 BNOERRTMPCOUNT=1
 BNOERRFOUND=FALSE
 WHILE BNOERRTMPCOUNT<=BNOERRCOUNT AND 
       BNOERRFOUND=FALSE
  DO
   IF BNOERRCODES(BNOERRTMPCOUNT)=BNOERRCODE THEN
    DO
     BNOERRFOUND=TRUE
     BNOERRMESSAGES(BNOERRTMPCOUNT)=BNOERRMESSAGE
    END
   BNOERRTMPCOUNT=BNOERRTMPCOUNT+1
  END
 BNOERRMESSAGE=""
END [PROCEDURE]

PROCEDURE BNOERRDISPLAYAPPEND
[* Pre-store up to 5 lines of custom display soft text for Error Messages
** in the ERRORDISPLAYMSG arrays for later use.
*] 
 IF BNOERRDISPLAYMSGCOUNT<BNOERRDISPLAYMSGSMAX THEN
  DO
   BNOERRDISPLAYMSGCOUNT=BNOERRDISPLAYMSGCOUNT+1
   BNOERRDISPLAYMSG(BNOERRDISPLAYMSGCOUNT)=BNOERRDISPLAYLINE
  END 
END [PROCEDURE]

PROCEDURE BNOERRDISPLAYUPDATE
[* For each error code other than EC 500, retrieve up to 5 lines of custom display soft text
** from the ERRORDISPLAYMSG array and populate the BNOERRDISPLAYMSGS array.
** This applies to all error codes that have custom display text defined 
** either in the configuration file or through other means. 
*]
 BNOERRTMPCOUNT=1
 BNOERRFOUND=FALSE
 WHILE BNOERRTMPCOUNT<=BNOERRCOUNT AND 
       BNOERRFOUND=FALSE
  DO
   IF BNOERRCODES(BNOERRTMPCOUNT)=BNOERRCODE THEN
    DO
     BNOERRFOUND=TRUE
     BNOERRDISPLAYMSGSCOUNT(BNOERRTMPCOUNT)=BNOERRDISPLAYMSGCOUNT
     FOR BNOERRTMPCOUNT2=1 TO BNOERRDISPLAYMSGCOUNT
      DO
       BNOERRDISPLAYMSGS(BNOERRTMPCOUNT,BNOERRTMPCOUNT2)=BNOERRDISPLAYMSG(BNOERRTMPCOUNT2)
      END
    END
   BNOERRTMPCOUNT=BNOERRTMPCOUNT+1
  END
 BNOERRDISPLAYMSGCOUNT=0
END [PROCEDURE]

PROCEDURE BNOERRGET
[* Gets the error message associated with the BNOERRORCODE
**
**  PASS    BNOERRORCODE        Numeric error code
**
**  RETURN  BNOERRCODE          Error code
**  RETURN  BNOERRMESSAGE       Error description
**  RETURN  BNOERRDISPLAYMSG    Error display message
*]

 BNOERRMESSAGE=BNOERRUNDEFINED
 BNOERRCODE=BNOERRORCODE
 BNOERRTMPCOUNT=1
 WHILE BNOERRTMPCOUNT<=BNOERRCOUNT AND
       BNOERRMESSAGE=BNOERRUNDEFINED
  DO
   IF BNOERRCODES(BNOERRTMPCOUNT)=BNOERRORCODE THEN
    DO
     BNOERRMESSAGE=BNOERRMESSAGES(BNOERRTMPCOUNT)
     BNOERRDISPLAYMSGCOUNT=BNOERRDISPLAYMSGSCOUNT(BNOERRTMPCOUNT)
     FOR BNOERRTMPCOUNT2=1 TO BNOERRDISPLAYMSGCOUNT
      DO
       BNOERRDISPLAYMSG(BNOERRTMPCOUNT2)=BNOERRDISPLAYMSGS(BNOERRTMPCOUNT,BNOERRTMPCOUNT2)
      END
    END 
   BNOERRTMPCOUNT=BNOERRTMPCOUNT+1
  END
END [PROCEDURE]

PROCEDURE ERRORHANDLER
[* Print error code information to output.
**  PASS       BNOERRORCODE      Error code to print
**  PASS       ERRORMSG          Error type to print
**  PASS       ERRORDETAIL       Specific error detail
**
** ERROR CODES
**  500 - Program running in memo mode
**  501 - Config file read error
**  502 - Config file validation error
**  503 - No eligible shares to be created
**  504 - Ineligible account type
**  505 - Account warning exists
**  506 - Error updating/creating share tracking
**  507 - Error updating Auth/Fee fields
**  508 - Error updating Overdraft Tolerance amount
*]
 ERRORMSG="loggingErrorMessage"
 CALL BNOERRUPDATE [updates the changes made to the selected BNOERRORCODE using what's in the ERRORDETAIL ARRAY]
 CALL BNOERRGET [gets the error message and error description associated with the BNOERRORCODE]

 PRINT "    "+Q+"errorCode"+Q+": "+FORMAT(Q+"999"+Q,BNOERRCODE)+","
 NEWLINE
 PRINT "  "+Q+ERRORMSG+Q+": "+
           Q+BNOERRMESSAGE+Q
 NEWLINE

 IF BNOERRORCODE<>500 THEN
  DO [* 10/21/25-JPK: Non 500 Error Codes now require Error Display Message, as previously ECs were forced to 500 *]
   PRINT ","
   NEWLINE
   PRINT "    "+Q+"errorMessage"+Q+": ["
   NEWLINE
   IF BNOERRDISPLAYMSGCOUNT>0 THEN [* Soft coded Error Display Message filled in in configuration file *]
    DO
     FOR TMPLOOP=1 TO BNOERRDISPLAYMSGCOUNT
      DO
       TMPCHR=BNOERRDISPLAYMSG(TMPLOOP)
       CALL NTS
       PRINT Q+TMPCHR+Q
       IF TMPLOOP<BNOERRDISPLAYMSGCOUNT THEN
        PRINT ","
       NEWLINE
      END
    END
   ELSE 
    DO [* Use same generic Error Display Message that non Memo Mode EC 500 had hard coded, for non 500 EC *]
     FOR TMPLOOP=1 TO GENERICERRDISPLAYMSGCOUNT
      DO
       PRINT Q+GENERICERRDISPLAYMSG(TMPLOOP)+Q
       IF TMPLOOP<GENERICERRDISPLAYMSGCOUNT THEN
        PRINT ","
       NEWLINE
      END
    END
   PRINT "]"
   NEWLINE
  END [ IF BNOERRORCODE<>500 ]
END [PROCEDURE]

PROCEDURE JSONOPEN
 PRINT "{"
 NEWLINE
END [PROCEDURE]

PROCEDURE JSONCLOSE
 PRINT "}"
 NEWLINE
END [PROCEDURE]

PROCEDURE VALIDATEACCOUNT

 INVALIDACCTTYPEFOUND=FALSE
 IF INVALIDACCTYPES(ACCOUNT:TYPE)=TRUE THEN
  INVALIDACCTTYPEFOUND=TRUE

 SLAWARNINGFOUND=FALSE
 FOR TMPLOOP=1 TO MAXWARNINGTYPES
  DO
   IF WARNINGSACCT(TMPLOOP)=TRUE AND
      ANYWARNING(ACCOUNT,TMPLOOP) THEN
    DO
     SLAWARNINGFOUND=TMPLOOP
     TMPLOOP=MAXWARNINGTYPES
    END
  END

 IF INVALIDACCTTYPEFOUND=TRUE THEN
  DO
   CALL JSONOPEN
   BNOERRORCODE=BNOERRCODEINELIGACCTYPE
   BNOERRCODE=BNOERRCODEINELIGACCTYPE
   BNOERRMESSAGE=FORMAT("Ineligible Acct Type 9999 found",ACCOUNT:TYPE)
   CALL ERRORHANDLER
   @RGSTATE=STATEEND
  END

 IF SLAWARNINGFOUND<>FALSE THEN
  DO
   CALL JSONOPEN
   BNOERRORCODE=BNOERRCODACCTWARNEXISTS
   BNOERRCODE=BNOERRCODACCTWARNEXISTS
   BNOERRMESSAGE=FORMAT("Account warning 999 exists",SLAWARNINGFOUND)
   CALL ERRORHANDLER
   @RGSTATE=STATEEND
  END
END [PROCEDURE]

PROCEDURE VALIDATESYSMEMOMODE
[* The design is to only call VALIDATESYSMEMOMODE if in the CFG 
** "ALLOW OVERDRAFT SETTINGS CHANGES IN MEMO MODE" is set to "FALSE" or isn't set.
** Check to see if the system is in MemoMode and if so, return JSON line
** "memoMode: true" .
** And if in the CFG "CMMM" is filled in, then return JSON lines
** ","
** "memoModeMessage:["an","array","of","lines"]".
*]
 SYSTEMMEMOMODE=SYSMEMOMODE

 IF SYSTEMMEMOMODE=TRUE THEN
  DO
   NEWLINE
   CALL JSONOPEN
   PRINT "  "+Q+"memoMode"+Q+": true"
   NEWLINE
   IF PARAMMEMOMODEMSGLINES>0 THEN
    DO
     PRINT ","
     NEWLINE  
     PRINT "  "+Q+"memoModeMessage"+Q+": ["
     FOR TERMSLOOP=1 TO PARAMMEMOMODEMSGLINES
      DO
       NEWLINE
       PRINT "   "+Q
       IF TERMSLOOP>1 AND
          PARAMMEMOMODEMSG(TERMSLOOP)<>"" AND
          PARAMMEMOMODEMSG(TERMSLOOP-1)<>"" THEN
        PRINT " "
       PRINT PARAMMEMOMODEMSG(TERMSLOOP)+Q
       IF TERMSLOOP<PARAMMEMOMODEMSGLINES THEN
        PRINT ","
      END
     NEWLINE
     PRINT "  "+"]"
     NEWLINE      
    END
   @RGSTATE=STATEEND
  END
END [PROCEDURE]

PROCEDURE SETSESSIONVARS
[* Pull the values from the state character arrays and store in
** an array for processing.
*]
 SNSHARELIST(1)=@RGUSERCHR1
 SNSHARELIST(2)=@RGUSERCHR2
 SNSHARELIST(3)=@RGUSERCHR3
 SNSHARELIST(4)=@RGUSERCHR4
 SNSHARELIST(5)=@RGUSERCHR5
END [PROCEDURE]

PROCEDURE SETSNSHARELISTSELECTED
[* UX will pass back up to 5 strings of data consisting of those Share
** IDs which are to be enrolled in ODT, passed data will be formatted
** as 4-chracter Share IDs with comma dilineation.
*]

 FOR TMPLOOP=1 TO SDMAX
  DO
   SDODTNEWSTATUS(TMPLOOP)=FALSE
  END

 SHARELISTINDEX=1
 WHILE SHARELISTINDEX<=5
  DO
   SHARELIST=SNSHARELIST(SHARELISTINDEX)
   WHILE SHARELIST<>""
    DO
     COMMAPOS=CHARACTERSEARCH(SHARELIST,",")
     IF COMMAPOS>0 THEN
      DO
       SLID=SEGMENT(SHARELIST,1,COMMAPOS-1)
       IF COMMAPOS=LENGTH(SHARELIST) THEN
        SHARELIST=""
       ELSE
	  SHARELIST=SEGMENT(SHARELIST,COMMAPOS+1,LENGTH(SHARELIST))
      END
     ELSE
      DO
       SLID=SHARELIST
       SHARELIST=""
      END
     IF SLID<>"" THEN
      DO
       SLID="0000"+SLID
       SLID=SEGMENT(SLID,LENGTH(SLID)-SLIDLEN+1,LENGTH(SLID))
       FOUND=FALSE
       TMPLOOP=1
       WHILE FOUND=FALSE AND TMPLOOP<=SDCOUNT
        DO
         IF SDID(TMPLOOP)=SLID THEN
          DO
           FOUND=TRUE
           SDODTNEWSTATUS(TMPLOOP)=TRUE
          END
         TMPLOOP=TMPLOOP+1
        END
      END
    END
   SHARELISTINDEX=SHARELISTINDEX+1
  END
END [PROCEDURE]

PROCEDURE UPDATERECORDS
[* Update or create share tracking records as needed and, if the parameter
** is set, the auth/fee and surcecode fields.
*]
 TMPLOOP=1
 FMERROR=""
 FMUPDATEERRORTRACKING=FALSE

 WHILE (TMPLOOP<=SDCOUNT)
  DO
   IF (SDODTSTATUS(TMPLOOP)<>SDODTNEWSTATUS(TMPLOOP)) OR
       SDODTTRACKINGLOC(TMPLOOP)=0 OR
       PARAMUPDATEANDF=TRUE THEN
    DO
     IF SDODTNEWSTATUS(TMPLOOP)=TRUE THEN
      NEWSTATUS=1
     ELSE
      NEWSTATUS=0
     IF SDODTTRACKINGLOC(TMPLOOP)=0 THEN
      DO
       FMTRACKINGLOCATOR=-1
       FMPERFORM CREATE SHARE SDID(TMPLOOP) TRACKING LOC FMTRACKINGLOCATOR
                (0,PARAMSHARETRACKING,TEMPLOC,FMERROR)
        DO
         SET USERCODE1   TO NEWSTATUS
         SET USERDATE1   TO SYSTEMDATE
        END
      END
     ELSE
      DO
       FMTRACKINGLOCATOR=SDODTTRACKINGLOC(TMPLOOP)
       FMPERFORM REVISE SHARE SDID(TMPLOOP) TRACKING LOC FMTRACKINGLOCATOR
                (0,PARAMSHARETRACKING,FMERROR)
        DO
         SET USERCODE1   TO NEWSTATUS
         SET USERDATE1   TO SYSTEMDATE
        END
      END
     IF FMERROR<>"" THEN
      DO
       SDTRACKINGUPDATE(TMPLOOP)=FMUNSUCCESSFUL
       FMUPDATEERRORTRACKING=TRUE
      END
     ELSE
      SDTRACKINGUPDATE(TMPLOOP)=FMSUCCESSFUL

     IF PARAMUPDATEANDF=TRUE THEN
      CALL FMAUTHFEEFIELDS

     CALL FMODTAMOUNT
    END
   TMPLOOP=TMPLOOP+1
  END [IF (SDODTSTATUS(TMPLOOP)<>SDODTNEWSTATUS(TMPLOOP)) OR...]
END [PROCEDURE]

PROCEDURE FMAUTHFEEFIELDS
[* If parameter is set, update the Auth/Fee and Sourcecode fields
*]
 FMERROR=""
 FMUPDATEERRORAUTHFEE=FALSE

 IF SDODTNEWSTATUS(TMPLOOP)=TRUE THEN
  DO
   NEWSOURCECODE1=PARAMSC1TRUE
   NEWAUTFEEOPTION1=PARAMAF1TRUE
  END
 ELSE
  DO
   NEWSOURCECODE1=PARAMSC1FALSE
   NEWAUTFEEOPTION1=PARAMAF1FALSE
  END

 FMPERFORM REVISE SHARE SDID(TMPLOOP) (0,0,FMERROR)
  DO
   SET ODTAUTHFEESRCCODELIST:1 TO NEWSOURCECODE1
   SET AUTHFEEOPTION:1 TO NEWAUTFEEOPTION1
  END

 IF FMERROR<>"" THEN
  DO
   SDAUTHFEEUPDATE(TMPLOOP)=FMUNSUCCESSFUL
   FMUPDATEERRORAUTHFEE=TRUE
  END
 ELSE
  SDAUTHFEEUPDATE(TMPLOOP)=FMSUCCESSFUL
END [PROCEDURE]

PROCEDURE FMODTAMOUNT
[* Update OVERDRAFTTOLERANCE amount in the SHARE record
*]
 FMERROR=""
 FMUPDATEERRORODTAMOUNT=FALSE

 BNODEBUGMSG=FORMAT("FMODTAMOUNT-SDODTSTATUS(99):",TMPLOOP)+
             BNOTRUEFALSECHR(SDODTSTATUS(TMPLOOP))+
             FORMAT(" - SDODTNEWSTATUS(99):",TMPLOOP)+
             BNOTRUEFALSECHR(SDODTNEWSTATUS(TMPLOOP))
 CALL BNODEBUGMSGADD

 IF SDODTSTATUS(TMPLOOP)<>SDODTNEWSTATUS(TMPLOOP) THEN
  DO
   IF SDODTNEWSTATUS(TMPLOOP)=FALSE THEN
    DO
     IF PARAMCOTA=TRUE THEN
      DO
       NEWODTAMOUNT=$0.00
       BNODEBUGMSG="SETTING NEW ODT AMOUNT TO $0.00"
       CALL BNODEBUGMSGADD
      END
     ELSE
      NEWODTAMOUNT=SDOVERDRAFTTOLERANCE(TMPLOOP)
    END
   ELSE
    DO
     NEWODTAMOUNT=SDOVERDRAFTTOLERANCE(TMPLOOP)
     PARAMINDEX=1
     PARAMFOUND=FALSE
     WHILE (PARAMFOUND=FALSE AND PARAMINDEX<=PARAMOTACOUNT)
      DO
       IF PARAMOTASHARETYPE(PARAMINDEX)=SDTYPE(TMPLOOP) THEN
        DO
         PARAMFOUND=TRUE
         NEWODTAMOUNT=PARAMOTAAMOUNT(PARAMINDEX)
        END
       PARAMINDEX=PARAMINDEX+1
      END [WHILE (PARAMFOUND=FALSE AND...]
     IF PARAMFOUND=FALSE AND
        DEFAULTOTAVALUE>=$0.00 THEN
      NEWODTAMOUNT=DEFAULTOTAVALUE
    END [ELSE]

   BNODEBUGMSG=FORMAT("SDOVERDRAFTTOLERANCE(99):",TMPLOOP)+
               FORMAT(" ###,##9.99 - ",SDOVERDRAFTTOLERANCE(TMPLOOP))+
               FORMAT("NEWODTAMOUNT: ###,##9.99",NEWODTAMOUNT)
   CALL BNODEBUGMSGADD

   IF NEWODTAMOUNT<>SDOVERDRAFTTOLERANCE(TMPLOOP) THEN
    DO
     FMPERFORM REVISE SHARE SDID(TMPLOOP) (0,0,FMERROR)
      DO
       SET OVERDRAFTTOLERANCE TO NEWODTAMOUNT
      END
    END [IF NEWODTAMOUNT<>SDOVERDRAFTTOLERANCE(TMPLOOP)]
  END [IF SDODTSTATUS(TMPLOOP)<>SDODTNEWSTATUS(TMPLOOP)]

 IF FMERROR<>"" THEN
  FMUPDATEERRORODTAMOUNT=TRUE
END [PROCEDURE]

PROCEDURE PRINTPROGRAMINFO
 PRINT "  "+Q+"programInfo"+Q+": {"
 NEWLINE
 PRINT "    "+Q+"programName"+Q+": "+Q+PROGRAMNAME+Q+","
 NEWLINE
 PRINT "    "+Q+"programVersion"+Q+": "+Q+PROGRAMVERSION+Q+","
 NEWLINE
 PRINT "    "+Q+"programLastModDate"+Q+": "+Q+FORMAT("99/99/99-",LASTMODDATE)+LASTMODTIME+Q+","
 NEWLINE
 PRINT "    "+Q+"programInstallDate"+Q+": "+Q+FORMAT("99/99/99",PARAMINSTALLDATE)+Q
 NEWLINE
 PRINT "  "+"},"
 NEWLINE
END [PROCEDURE]

PROCEDURE BNOPRINTRGDATA
[* Print @RGUSER[CHR,NUM] data passed from the UX in proper JSON format
**
**  PASS    BNODEBUGMODE        Boolean: Print debug data, T/F
*]
 IF BNODEBUGMODE=BNODEBUGMODEON AND
    BNOINCLUDERGDATAINDEBUG=TRUE THEN
  DO
   PRINT ","
   NEWLINE
   PRINT BNOINDENT(1)+Q+"rgData"+Q+": ["
   NEWLINE
   PRINT BNOINDENT(2)+Q+"CHR1:'"+SEGMENT(@RGUSERCHR1,1,120)+"'"+Q+","
   NEWLINE
   PRINT BNOINDENT(2)+Q+"CHR2:'"+SEGMENT(@RGUSERCHR2,1,120)+"'"+Q+","
   NEWLINE
   PRINT BNOINDENT(2)+Q+"CHR3:'"+SEGMENT(@RGUSERCHR3,1,120)+"'"+Q+","
   NEWLINE
   PRINT BNOINDENT(2)+Q+"CHR4:'"+SEGMENT(@RGUSERCHR4,1,120)+"'"+Q+","
   NEWLINE
   PRINT BNOINDENT(2)+Q+"CHR5:'"+SEGMENT(@RGUSERCHR5,1,120)+"'"+Q+","
   NEWLINE
   PRINT BNOINDENT(2)+Q+
                     "NUM1:"+FORMAT("#########9 ",@RGUSERNUM1)+
                     "NUM2:"+FORMAT("#########9 ",@RGUSERNUM2)+
                     "NUM3:"+FORMAT("#########9 ",@RGUSERNUM3)+
                     "NUM4:"+FORMAT("#########9 ",@RGUSERNUM4)+
                     "NUM5:"+FORMAT("#########9",@RGUSERNUM5)+Q
   NEWLINE
   PRINT BNOINDENT(1)+"]"
   NEWLINE
  END
END [PROCEDURE]

PROCEDURE BNOPRINTDEBUG
[* Print debug output in proper JSON format. Requires BNODEBUGMODE to be
** on (or true).
**
**  PASS  BNODEBUGMODE        Boolean: Print debug data, T/F
**  PASS  BNODEBUGMSGLIST(A)  Array of debug messages to print
**  PASS  BNODEBUGCOUNT       Number of debug lines to print
*]
 IF BNODEBUGMODE=BNODEBUGMODEON THEN
  DO
   PRINT ","
   NEWLINE
   PRINT BNOINDENT(2)+Q+"debugData"+Q+": ["
   NEWLINE
   PRINT BNOINDENT(2)+Q+"Debug note: Debug lines truncated to 120 characters"+Q
   FOR BNODEBUGLOOP=1 TO BNODEBUGCOUNT
    DO
     PRINT ","
     NEWLINE
     PRINT BNOINDENT(3)+Q+SEGMENT(BNODEBUGMSGLIST(BNODEBUGLOOP),1,120)+Q
    END [FOR BNODEBUGLOOP=1 TO BNODEBUGCOUNT]
   PRINT BNOINDENT(2)+"]"
   NEWLINE
  END
END [PROCEDURE]

PROCEDURE BNODEBUGMSGADD
[* Add a message line to the debug message array
**
** PASS    BNODEBUGMSGMAX     Current array index max lines allowed
** PASS    BNODEBUGMSG        Debug message to add to array
**
** RETURN  BNODEBUGCOUNT      Count of debug message lines
** RETURN  BNODEBUGMSGLIST(A) Debug lines of data to print
**
*]
 IF BNODEBUGCOUNT<BNODEBUGMSGMAX THEN
  DO
   BNODEBUGCOUNT=BNODEBUGCOUNT+1
   BNODEBUGMSGLIST(BNODEBUGCOUNT)=SEGMENT(BNODEBUGMSG,1,126)
   BNODEBUGMSG=""
  END
END [PROCEDURE]

#INCLUDE "RB.LISTEXPAND"

