
[*  Copyright 2025 Jack Henry and Associates
**
**  PowerOn Name:                     BANNO.ODTOPTIN.V2.POW
**  Configuration Letterfile Name:    BANNO.ODTOPTIN.V2.CFG
**
**  --------------------------------------------------------------------
**  Program Summary
**  --------------------------------------------------------------------
**  This Banno service PowerOn allows the user to Opt-In or Opt-out
**  of the Reg-E overdraft service
**
**  For more information check
**  https://github.com/Banno/banno-powerons
**
**  Banno is not responsible for any modifications to this file
**  made by unauthorized personnel.
**
**  --------------------------------------------------------------------
**  Program states and JSON returns
**  --------------------------------------------------------------------
**    STATE:  PRELOADDATA
**  PROCESS:  Process PRELOADDATA state and create json response
**     PASS:  @RGUSERCHR1 10-character member number/account number
**            @RGUSERNUM1 ????
**   RETURN:  Provides UX PRELOADDATA response
**
**    STATE:  PROCESSDATA
**  PROCESS:  Process PROCESSDATA state and create json response
**     PASS:  @RGUSERCHR1 10-character member number/account number
**            @RGUSERNUM1 ????
**   RETURN:  Provides UX PROCESSDATA response
**
**  --------------------------------------------------------------------
**  Error codes and Logging Messages
**  --------------------------------------------------------------------
**  500: System in memo mode
**  501: Error reading/opening config file
**  502: Config file validation error
**
**  --------------------------------------------------------------------
**  Additional Information
**  --------------------------------------------------------------------
**
**  --------------------------------------------------------------------
**  Modification History
**  --------------------------------------------------------------------
**    Ver. 2.0.0  12/31/2025 R. Robison: Original V2 version of ODT Opt-In PowerOn
**                           Feature set based on: BANNO.ODTOPTIN.V1.POW Ver. 1.5.0  10/21/25
**    
*]
SYMCONNECT
STATELESS

TARGET=ACCOUNT

DEFINE
 #INCLUDE "RD.GETDATA.DEF"
 #INCLUDE "RB.LISTEXPAND.DEF"

 BNOLASTMODDATE            = '12/31/25'
 BNOLASTMODTIME            = "17:30 MT"
 BNOPROGRAMNAME            = "BANNO.ODTOPTIN.V2.POW"
 BNOCFGFILENAME            = "BANNO.ODTOPTIN.V2.CFG"
 BNOPROGRAMVERSION         = "2.0.0"
 BNOPROGRAMNOTE1           = "New PowerOn"
 BNOPROGRAMNOTE2           = ""

 BNODEBUGPRINTINFODAYS     = 60
 BNODEBUGINCLUDEPARAMS     = 1

 STATEPRELOADDATA             = "PRELOADDATA"
 STATEPROCESSDATA             = "PROCESSDATA"
 STATEEND                     = "STATEEND"

[* Error code setup
*]
 BNOERRCODEMEMOMODE           = 500
 BNOERRCODECONFIGREAD         = 501
  BNOERRMODOPEN               = "[configuration file name] open error - [system generated letter file read error message]"
  BNOERRMODREAD               = "[configuration file name] read error - [system generated letter file read error message]"
 BNOERRCODECONFIGVALIDATE     = 502
  BNOERRMODDUPLICATEPARAM     = "Duplicate Param file entry([parameter name])"
  BNOERRMODINVALIDVALUE       = "Invalid Param Value([parameter name])"
  BNOERRMODINVALIDTRTYPE      = "Invalid tracking type"
  BNOERRMODINVALIDSCSCT       = "Invalid source code for SCT in CFG"
  BNOERRMODINVALIDSCSCF       = "Invalid source code for SCF in CFG"
  BNERRMODINVALIDAFOAFT       = "Invalid auth/fee option for AFT in CFG"
  BNERRMODINVALIDAFOAFF       = "Invalid auth/fee option for AFF in CFG"
 BNOERRCODENOELIGSHARES       = 503
 BNOERRCODEINELIGACCTYPE      = 504
 BNOERRCODACCTWARNEXISTS      = 505
 BNOERRCODEFMSHTRKNGFAIL      = 506
 BNOERRCODEFMSCANDAUTHFEEFAIL = 507
 BNOERRCODEFMSHODTAMTFAIL     = 508
 BNOERRUNHANDLED              = 509

[* RGUSER Pass variables - passed from UX code
*]
 RGLANGUAGE=NUMBER
 RGMEMBERNUMBER=CHARACTER(10)
 RGSHARESMAX=NUMBER

[* Main PowerOn variables and data structures for json
*]
 MAXSLTYPES=NUMBER
 SDMAX=NUMBER
 SDCOUNT=NUMBER
 SDOVERMAX=NUMBER
 SDID=CHARACTER(4) ARRAY(132)
 SDTYPE=NUMBER ARRAY(132)
 SDNAME=CHARACTER(40) ARRAY(132)
 SDBALANCE=MONEY ARRAY(132)
 SDODTSTATUS=NUMBER ARRAY(132)
 SDODTNEWSTATUS=NUMBER ARRAY(132)
 SDODTTRACKINGLOC=NUMBER ARRAY(132)
 SDTRACKINGUPDATE=NUMBER ARRAY(132)
 SDAUTHFEEUPDATE=NUMBER ARRAY(132)
 SDOVERDRAFTTOLERANCE=MONEY ARRAY(132)

 SHAREINVALIDREASON=CHARACTER
 SLAWARNINGFOUND=NUMBER


[* CFG Parameter variables specific to this PowerOn
*]
 PARAMINVALIDACCTYPESLIST=CHARACTER
 PARAMINVALIDACCTYPES= NUMBER ARRAY(9999)
 PARAMVALIDSHARETYPESLIST=CHARACTER
 PARAMVALIDSHARETYPES=NUMBER ARRAY(9999)
 PARAMWARNINGSACCTLIST=CHARACTER
 PARAMWARNINGSACCT=NUMBER ARRAY(999)
 PARAMWARNINGSSHARELIST=CHARACTER
 PARAMWARNINGSSHARE=NUMBER ARRAY(999)
 PARAMSHARETRACKING=NUMBER
 PARAMUPDATEANDF=NUMBER
 PARAMSC1TRUE=CHARACTER
 PARAMSC1FALSE=CHARACTER
 PARAMAF1TRUE=NUMBER
 PARAMAF1FALSE=NUMBER
 PARAMOTAAMOUNT=MONEY ARRAY(99)
 PARAMOTASHARETYPE=NUMBER ARRAY(99)
 PARAMOTACOUNT=NUMBER
 PARAMOTAMAX=99
 PARAMCOTA=NUMBER
 PARAMALLOWINMEMOMODE=NUMBER
 PARAMDEFAULTOTAVALUE=MONEY

[* CFG Parameter variables -- common
*]
 PARAMLANGSPANISH=NUMBER
 PARAMDEBUGMODE=NUMBER
 PARAMTESTMODE=NUMBER
 PARAMTESTEC=NUMBER
 PARAMPROGINSTALLDATE=DATE

[* CFG Parameter variables for soft text messages
*]
 PARAMMSGTAGSMAX=20
 PARAMMSGTAGSCOUNT=NUMBER
 PARAMMSGTAG=CHARACTER
 PARAMMSGPROP=CHARACTER
 PARAMMSGOPT=NUMBER
 PARAMMSGMAXLINES=NUMBER
 PARAMMSGTAGLANG=NUMBER

 PARAMMSGTAGS=CHARACTER ARRAY(20)
 PARAMMSGPROPS=CHARACTER ARRAY(20)
 PARAMMSGOPTIONAL=NUMBER ARRAY(20)
 PARAMMSGDEFINED=NUMBER ARRAY(20)
 PARAMMSGMAX=NUMBER ARRAY(20)
 PARAMMSGALLMAX=800
 PARAMMSGALL=CHARACTER ARRAY(800)
 PARAMMSGALLTAGS=CHARACTER ARRAY(800)
 PARAMMSGALLTAGSLANG=NUMBER ARRAY(800)
 PARAMMSGTAGNONE=0
 PARAMMSGTAGENGLISH=1
 PARAMMSGTAGSPANISH=2
 PARAMMSGTAGENGLISHSFX="_EN"
 PARAMMSGTAGSPANISHSFX="_SP"
 PARAMMSGALLCOUNT=NUMBER
 PARAMMSGTAGFOUND=NUMBER
 PARAMMSGTAGINDEX=NUMBER
 PARAMMSGALLINDEX=NUMBER
 PARAMMSGDEFAULTMAX=20 [each message can be up to 20 lines long by default]
 
 PARAMMSGALLLANG=NUMBER
 PARAMMSGALLTAG=CHARACTER
 PARAMMSGALLVAL=CHARACTER
 PARAMMSGALLTAGFOUND=NUMBER

[* CFG Parameter variables for errorDisplayMessages (EDM)
*] 
 PARAMERRDISPLAYMAX=200
 PARAMERRDISPLAYERRCODES=NUMBER ARRAY(200)
 PARAMERRDISPLAYLINES=CHARACTER ARRAY(200)
 PARAMERRDISPLAYLANG=NUMBER ARRAY(200)
 PARAMERRDISPLAYCOUNT=NUMBER
 PARAMERRDISPLAYINDEX=NUMBER

[* CFG Parameter processing - general
*]
 BNOCFGPARAMMAX=200
 BNOCFGPARAMCOUNT=NUMBER
 BNOCFGPARAM=CHARACTER ARRAY(200)
 BNOCFGPARAMVAL=CHARACTER ARRAY(200)
 BNOCFGFILENUMBER=NUMBER
 BNOCFGFILEFERROR=CHARACTER
 BNOCFGFILELINE=CHARACTER
 BNOCFGPARAMALLOWDUPS=NUMBER

 BNOPARAMFOUND=NUMBER
 BNOPARAMFOUNDINDEX=NUMBER
 BNOPARAMFIND=CHARACTER
 BNOPARAMVAL=CHARACTER
 BNOPARAMTMP=CHARACTER
 BNOPARAMVALTMP=CHARACTER
 BNOPARAMLOOP=NUMBER

[* Debug handling variables
*]
 BNODEBUGMSGMAX=999
 BNODEBUGMSGLIST=CHARACTER ARRAY(999)
 BNODEBUGLOOP=NUMBER
 BNODEBUGCOUNT=NUMBER
 BNODEBUGMSG=CHARACTER
 BNODEBUGMODE=NUMBER

[* Error handling variables
*]
 BNOERRORCODE=NUMBER
 BNOERRORMODIFIER=CHARACTER
 BNOERRCODE=NUMBER
 BNOERRMESSAGE=CHARACTER
 BNOERRMODIFIER=CHARACTER
 BNOERRCOUNT=NUMBER
 BNOERRTMPCOUNT=NUMBER
 BNOERRTMPCOUNT2=NUMBER
 BNOERRDISPLAYLIST=CHARACTER
 BNOERRDISPLAYCODE=NUMBER
 BNOERRFOUND=NUMBER
 BNOERRCODES=NUMBER ARRAY(99)
 BNOERRMESSAGES=CHARACTER ARRAY(99)
 BNOERRMAX=99
 BNOERRUNDEFINED="**Undefined**"

 BNOERRDISPLAYMSGSMAX=5
 BNOERRDISPLAYMSG=CHARACTER ARRAY(5)
 BNOERRDISPLAYMSGCOUNT=NUMBER
 BNOERRDISPLAYLINE=CHARACTER

[* Misc. Variables
*]
 BNOTEXT=CHARACTER
 BNOAMT=MONEY
 BNORATE=RATE
 BNONUM=NUMBER
 BNOTMPLOOP=NUMBER
 BNOPOS=NUMBER 
 BNOIDLENGTH=NUMBER
 BNOSLTYPELENGTH=NUMBER

 JSONBOOLEAN=CHARACTER ARRAY(1)
 JSONPROPNAME=CHARACTER
 JSONOBJFIRSTPROP=NUMBER

 TMPLOOP=NUMBER
 TMPLOOP2=NUMBER
 TMPCHR=CHARACTER
 QQ=CHARACTER
 TMPERRCODE=NUMBER
 TMPDISPLAYLINE=CHARACTER
 CHRVAL=NUMBER
 TMPLINECOUNT=NUMBER
 LINECOUNT=NUMBER
 MSGTAGSELECTED=NUMBER
 MSGPROPSELECT=CHARACTER
 MSGPROPSELECTLIST=CHARACTER
 TAGSFXPOS=NUMBER
 COLONPOS=NUMBER
 
 SYMXINSTANCE=NUMBER
 SYMXCLIENTNUM=NUMBER

[* BNOPARSEDATALINE variables
*]
 BNODATALINE=CHARACTER
 BNODLINDEX=NUMBER
 BNODLFIELDCOUNT=NUMBER
 BNODLFIELD=CHARACTER ARRAY(99)
 BNODLFIELDMAX=99
 BNODLPOS=NUMBER
 BNODLDELIMITER=CHARACTER

[* BNOCLEANUP variables
*]
 BNOCLEANLOOP=NUMBER
 BNOCLEANVALIDCHRLIST="32-126,128-175,181-184,189,190,198,199,208-216,221,222,224-253"
 BNOCLEANVALIDCHRS=NUMBER ARRAY(255)
 BNOCLEANVALIDCHRMAX=255

[* Replace variables
*]
 TRUE=1
 FALSE=0
 DATENULL='--/--/--'
 BNODEBUGMODEOFF=0
 BNODEBUGMODEON=1
 BNODEBUGMODEUNDEFINED=9999

 FMUNCHANGED=0
 FMSUCCESSFUL=1
 FMUNSUCCESSFUL=2
 VALIDSOURCECODELIST="ABCDEFGHIJKLNOPRSTVW"
 MAXWARNINGTYPES=999

 CHRVALQUOTE=34
 CHRVALBACKSLASH=92
END [DEFINE]

SETUP
 CALL BNOERRINIT

[* Register supported error messages
*] 
 BNOERRCODE=BNOERRCODEMEMOMODE           BNOERRMESSAGE="Program running in memo mode"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODECONFIGREAD         BNOERRMESSAGE="Error opening/reading config file"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODECONFIGVALIDATE     BNOERRMESSAGE="Config file validation error"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODENOELIGSHARES       BNOERRMESSAGE="No eligible shares."
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEINELIGACCTYPE      BNOERRMESSAGE="Ineligible Acct Type found"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODACCTWARNEXISTS      BNOERRMESSAGE="Account warning exists"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEFMSHTRKNGFAIL      BNOERRMESSAGE="Error attempting to update share tracking"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEFMSCANDAUTHFEEFAIL BNOERRMESSAGE="Error updating source code & auth/fee fields"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEFMSHODTAMTFAIL     BNOERRMESSAGE="Error updating share overdraft tolerance amount"
 CALL BNOERRADD
 BNOERRCODE=BNOERRUNHANDLED              BNOERRMESSAGE="Unhandled Error"
 CALL BNOERRADD

 [* Set any errors that support display messages
 *]
 BNOERRDISPLAYCODE=BNOERRCODECONFIGREAD
 CALL BNOERRDISPLAYLISTADD
 BNOERRDISPLAYCODE=BNOERRCODECONFIGVALIDATE
 CALL BNOERRDISPLAYLISTADD
 BNOERRDISPLAYCODE=BNOERRCODENOELIGSHARES
 CALL BNOERRDISPLAYLISTADD
 BNOERRDISPLAYCODE=BNOERRCODEINELIGACCTYPE
 CALL BNOERRDISPLAYLISTADD
 BNOERRDISPLAYCODE=BNOERRCODACCTWARNEXISTS
 CALL BNOERRDISPLAYLISTADD
 BNOERRDISPLAYCODE=BNOERRCODEFMSHTRKNGFAIL
 CALL BNOERRDISPLAYLISTADD
 BNOERRDISPLAYCODE=BNOERRCODEFMSCANDAUTHFEEFAIL
 CALL BNOERRDISPLAYLISTADD
 BNOERRDISPLAYCODE=BNOERRCODEFMSHODTAMTFAIL
 CALL BNOERRDISPLAYLISTADD

[* This is where you define all the soft text CFG tags and json properties
**  - Optionally set PARAMMSGMAXLINES to override the default of 20 lines per message
**  - Optionally set PARAMMSGOPT to mark a message as optional. Message will not be returned in
**.   json response if no message lines found in the CFG.
*]
 CALL PARAMMSGINIT
 PARAMMSGTAG="TC"     PARAMMSGPROP="terms"                   [Custom Terms and Conditions Messages]
 PARAMMSGMAXLINES=999
 CALL PARAMMSGTAGADD
 PARAMMSGTAG="FD"     PARAMMSGPROP="feeDisclosure"           [Fee Disclosure]
 PARAMMSGMAXLINES=999
 CALL PARAMMSGTAGADD
 PARAMMSGTAG="RI"     PARAMMSGPROP="revocationInstructions"  [Revocation Instructions]
 PARAMMSGMAXLINES=99
 CALL PARAMMSGTAGADD
 PARAMMSGTAG="SI"     PARAMMSGPROP="servicesInstructions"    [Service Instructions]
 PARAMMSGMAXLINES=99
 CALL PARAMMSGTAGADD
 PARAMMSGTAG="OI"     PARAMMSGPROP="optInInformationText"    [Opt-in Information Text]
 PARAMMSGMAXLINES=99
 CALL PARAMMSGTAGADD
 PARAMMSGTAG="OO"     PARAMMSGPROP="optOutInformationText"   [Opt-Out Information Text]
 PARAMMSGMAXLINES=99
 CALL PARAMMSGTAGADD
 [**TODO** check on this.  Is in contract?  Is in UX code?  Is in CFG?]
 PARAMMSGTAG="OIO"    PARAMMSGPROP="optInOutInfoText"        [Opt-in/Opt-out Information Text]
 PARAMMSGMAXLINES=10
 CALL PARAMMSGTAGADD
 PARAMMSGTAG="CMMS"   PARAMMSGPROP="successMessage"          [Custom Memo Mode Success Message]
 PARAMMSGMAXLINES=5
 CALL PARAMMSGTAGADD
 PARAMMSGTAG="CSM"    PARAMMSGPROP="successMessage"          [Custom Success Message]
 PARAMMSGMAXLINES=5
 CALL PARAMMSGTAGADD
 PARAMMSGTAG="CMMM"   PARAMMSGPROP="memoModeMessage"         [Custom Memo Mode Success]
 PARAMMSGMAXLINES=5
 CALL PARAMMSGTAGADD

 CALL SETUPDATA
END [SETUP]

PRINT TITLE=BNOPROGRAMNAME

 CALL INITIALIZEDATA
 CALL GETRGDATA

 CALL BNOCFGFILEREAD

 IF BNOERRORCODE=0 THEN
  CALL BNOSETPARAMVALS

 IF BNOERRORCODE=0 THEN
  CALL PARAMPOSTPROCESS

 IF BNOERRORCODE=0 AND
    PARAMTESTMODE=TRUE THEN
  BNOERRORCODE=PARAMTESTEC

  IF BNOERRORCODE=0 AND
     SYSMEMOMODE=TRUE AND
     PARAMALLOWINMEMOMODE=FALSE THEN
   BNOERRORCODE=BNOERRCODEMEMOMODE   
 
 IF BNOERRORCODE=0 AND PARAMTESTMODE=FALSE THEN
  DO
   IF @RGSTATE=STATEPRELOADDATA THEN
    DO
     BNOERRORCODE=0
    END
   ELSE IF @RGSTATE=STATEPROCESSDATA THEN
    DO
     BNOERRORCODE=0
    END  
  END  

[* Output JSON 
*]
 CALL JSONOPEN
 
 IF @RGSTATE=STATEPRELOADDATA THEN
  DO
   IF BNOERRORCODE=0 THEN
    CALL JSONSUCCESSPRELOADDATA
   ELSE IF BNOERRORCODE=BNOERRCODEMEMOMODE THEN
    CALL JSONERRORMEMOMODE 
   ELSE 
    CALL JSONERROR
  END
 ELSE IF @RGSTATE=STATEPROCESSDATA THEN
  DO
   IF BNOERRORCODE=0 THEN
    CALL JSONSUCCESSPROCESSDATA
   ELSE IF BNOERRORCODE=BNOERRCODEMEMOMODE THEN
    CALL JSONERRORMEMOMODE
   ELSE 
    CALL JSONERROR
  END 

 CALL BNOCFGDEBUGADD
 CALL BNOJSONRGDATA
 CALL BNOJSONDEBUGDATA
 IF BNODEBUGMODE=BNODEBUGMODEOFF THEN
  NEWLINE
 
 CALL JSONCLOSE
END [PRINT]

PROCEDURE SETUPDATA
[* Set the SETUP data constants
*]
 JSONBOOLEAN(TRUE)="true"
 JSONBOOLEAN(FALSE)="false"
 
[* This is the default state of debug mode.  This may be overridden if the Program Install Date (PID)
** is set in the CFG configuration file.
*] 
 IF BNOLASTMODDATE+BNODEBUGPRINTINFODAYS>SYSTEMDATE THEN
  BNODEBUGMODE=BNODEBUGMODEON
 ELSE 
  BNODEBUGMODE=BNODEBUGMODEOFF 

 SYMXINSTANCE=@SYMXINSTANCEID
 SYMXCLIENTNUM=@CLIENTNUMBER
 BNOIDLENGTH=GETDATANUMBER(GETPARAMIDLENGTH)
 BNOSLTYPELENGTH=GETDATANUMBER(GETPARAMTYPELENGTH)
 IF BNOSLTYPELENGTH=2 THEN
  MAXSLTYPES=99
 ELSE
  MAXSLTYPES=9999
 
 QQ=CTRLCHR(CHRVALQUOTE)
 CALL BNOCLEANUPINIT
END [PROCEDURE]

PROCEDURE INITIALIZEDATA
[* Initialize variables
*]

 BNOERRORCODE=0
 BNOERRORMODIFIER=""
 BNOCFGPARAMALLOWDUPS=FALSE
 JSONOBJFIRSTPROP=TRUE
 BNODLDELIMITER=""
 MSGPROPSELECTLIST=""
END [PROCEDURE]

PROCEDURE GETRGDATA
[* Read in the @RG values from the UX, segment them into their individual
** values.
*]
 RGLANGUAGE=@RGSESSION
 RGSHARESMAX=@RGUSERNUM1

 IF @RGSTATE=STATEPRELOADDATA THEN
  DO
   RGMEMBERNUMBER=@RGUSERCHR1
  END
 ELSE IF @RGSTATE=STATEPROCESSDATA THEN
  DO
   RGMEMBERNUMBER=@RGUSERCHR1
  END
END [PROCEDURE]

PROCEDURE MSGPROPSELECTADD
[* Call before JSONMSGARRAYS to selectively output soft text/message properties.
** This may be called multiple times with different MSGPROPSELECT values to select and output
** multiple soft text properties.  JSONMSGARRAYS will output all defined soft text messages
** if this procedure is not called prior to JSONMSGARRAYS.
** Example:
**
**  MSGPROPSELECT="informationMsg"
**  CALL MSGPROPSELECTADD
**  CALL JSONMSGARRAYS
**
**  PASS    MSGPROPSELECT      The json property name for soft text that should be selected
**  
**  RETURN  MSGPROPSELECTLIST  Updated list
*]

 IF MSGPROPSELECTLIST<>"" THEN
  MSGPROPSELECTLIST=MSGPROPSELECTLIST+","
 MSGPROPSELECTLIST=MSGPROPSELECTLIST+MSGPROPSELECT 
END

PROCEDURE POLLSHARES
[* Create list of eligible shares. For each eigible share found, call
** procedure to add the share to the list.
*]

[* Set SDMAX to 130 for production. Pass back any lower number >0 in the
** @RGUSERNUM1 field for testing or limiting program to lower values
*]
 SDMAX=130
 IF RGSHARESMAX>0 AND RGSHARESMAX<=130 THEN
  SDMAX=RGSHARESMAX

 WHILELIMIT=1000000
 SDCOUNT=0
 FOR TMPLOOP=0 TO SDMAX
  DO
   SDID(TMPLOOP)=""
   SDTYPE(TMPLOOP)=-1
   SDNAME(TMPLOOP)=""
   SDBALANCE(TMPLOOP)=$0.00
   SDODTSTATUS(TMPLOOP)=FALSE
   SDODTNEWSTATUS(TMPLOOP)=FALSE
   SDODTTRACKINGLOC(TMPLOOP)=0
   SDTRACKINGUPDATE(TMPLOOP)=FMUNCHANGED
   SDAUTHFEEUPDATE(TMPLOOP)=0
   SDOVERDRAFTTOLERANCE(TMPLOOP)=$0.00
  END

 FOR EACH SHARE
  DO
   SHAREINVALIDREASON=""
   IF SHARE:CLOSEDATE<>DATENULL THEN
    SHAREINVALIDREASON="Share closed"
   ELSE IF SHARE:CHARGEOFFDATE<>DATENULL THEN
    SHAREINVALIDREASON="Share Charged-off"
   ELSE IF PARAMVALIDSHARETYPES(SHARE:TYPE)=FALSE THEN
    SHAREINVALIDREASON="Invalid Share Type"
   ELSE IF SHARE:SHARECODE=2 THEN
    SHAREINVALIDREASON="Cert (Share Code 2)"
   ELSE
    DO
     CALL TESTFORSHAREWARNING
     IF SLAWARNINGFOUND=TRUE THEN
      SHAREINVALIDREASON="Share Warning"
[     ELSE
      CALL ADDSHARETOLIST]
    END
   IF SHAREINVALIDREASON<>"" THEN
    BNODEBUGMSG="Testing Share ID "+SHARE:ID+": Invalid - "+SHAREINVALIDREASON
   ELSE
    BNODEBUGMSG="Testing Share ID "+SHARE:ID+": Valid - Added"
   CALL BNODEBUGMSGADD
  END
END [PROCEDURE]

PROCEDURE TESTFORSHAREWARNING
[* Test share for targeted warning(s)
*]
 SLAWARNINGFOUND=FALSE
 FOR TMPLOOP=1 TO MAXWARNINGTYPES
  DO
   IF ANYWARNING(SHARE,TMPLOOP) AND
      PARAMWARNINGSSHARE(TMPLOOP)=TRUE THEN
    DO
     SLAWARNINGFOUND=TRUE
     TMPLOOP=MAXWARNINGTYPES
    END
  END
END [PROCEDURE]


[*
**  --------------------------------------------------------------------
**  Config File Procedures
**  --------------------------------------------------------------------
*]

PROCEDURE PARAMMSGINIT

 PARAMMSGTAGSCOUNT=0
 PARAMMSGOPT=FALSE
 PARAMMSGMAXLINES=0
 FOR PARAMMSGTAGINDEX=1 TO PARAMMSGTAGSMAX
  DO
   PARAMMSGOPTIONAL(PARAMMSGTAGINDEX)=FALSE
   PARAMMSGDEFINED(PARAMMSGTAGINDEX)=FALSE
   PARAMMSGMAX(PARAMMSGTAGINDEX)=PARAMMSGDEFAULTMAX
  END
END [PROCEDURE] 

PROCEDURE PARAMMSGTAGADD

 IF PARAMMSGTAGSCOUNT<PARAMMSGTAGSMAX THEN
  DO
   PARAMMSGTAGSCOUNT=PARAMMSGTAGSCOUNT+1
   PARAMMSGTAGS(PARAMMSGTAGSCOUNT)=PARAMMSGTAG 
   PARAMMSGPROPS(PARAMMSGTAGSCOUNT)=PARAMMSGPROP
   PARAMMSGOPTIONAL(PARAMMSGTAGSCOUNT)=PARAMMSGOPT
   IF PARAMMSGMAXLINES<>0 THEN 
    PARAMMSGMAX(PARAMMSGTAGSCOUNT)=PARAMMSGMAXLINES
   
   PARAMMSGOPT=FALSE
   PARAMMSGMAXLINES=0
  END
END [PROCEDURE]

PROCEDURE BNOINITPARAMVALS
[* Initialize parameter/cfg variables
*]
 PARAMINVALIDACCTYPESLIST=""
 PARAMVALIDSHARETYPESLIST="ALL"
 PARAMWARNINGSACCTLIST=""
 PARAMWARNINGSSHARELIST=""
 PARAMSHARETRACKING=0
 PARAMUPDATEANDF=TRUE
 PARAMSC1TRUE=""
 PARAMSC1FALSE="GOBA"
 PARAMAF1TRUE=0
 PARAMAF1FALSE=7
 PARAMOTACOUNT=0
 PARAMCOTA=FALSE
 PARAMALLOWINMEMOMODE=FALSE
 PARAMDEFAULTOTAVALUE=-$0.01

 
 PARAMERRDISPLAYCOUNT=0
 PARAMLANGSPANISH=FALSE
 PARAMDEBUGMODE=BNODEBUGMODEUNDEFINED
 PARAMTESTMODE=FALSE
 PARAMTESTEC=0
 PARAMPROGINSTALLDATE=DATENULL
END [PROCEDURE]

PROCEDURE BNOSETPARAMVALS
[* Assign parameter settings retrieved from the configuration Letter
** file to variables for use throughout the program
*]
 CALL BNOINITPARAMVALS

 CALL GETPARAMMSGS

[* Ineligible Account Type(s)
*]
 BNOPARAMFIND="IAT"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMINVALIDACCTYPESLIST=BNOPARAMVAL

[* Share Tracking Type
*]
 BNOPARAMFIND="TRK"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMSHARETRACKING=VALUE(BNOPARAMVAL)

[* Valid Share Types
*]
 BNOPARAMFIND="ST"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMVALIDSHARETYPESLIST=BNOPARAMVAL

[* Account Warnings
*]
 BNOPARAMFIND="AW"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMWARNINGSACCTLIST=BNOPARAMVAL

[* Share Warnings
*]
 BNOPARAMFIND="SW"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMWARNINGSSHARELIST=BNOPARAMVAL

[* Update Auth And Fee
*]
 BNOPARAMFIND="UD"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE AND BNOPARAMVAL<>"" THEN
  DO
   IF CHARACTERSEARCH("TRUEYES1ON",BNOPARAMVAL)>0 THEN
    PARAMUPDATEANDF=TRUE
   ELSE 
    PARAMUPDATEANDF=FALSE 
  END

[* Clear overdraft tolerance amount on opt-out
*]
 BNOPARAMFIND="COTA"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE AND BNOPARAMVAL<>"" THEN
  DO
   IF CHARACTERSEARCH("TRUEYES1ON",BNOPARAMVAL)>0 THEN
    PARAMCOTA=TRUE
   ELSE 
    PARAMCOTA=FALSE 
  END

[* Allow overdraft settings changes in memo mode?
*]
 BNOPARAMFIND="MMOSC"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE AND BNOPARAMVAL<>"" THEN
  DO
   IF CHARACTERSEARCH("TRUEYES1ON",BNOPARAMVAL)>0 THEN
    PARAMALLOWINMEMOMODE=TRUE
   ELSE 
    PARAMALLOWINMEMOMODE=FALSE 
  END

[* Source Code 1 when update A&F true & Opt-in true
*]
 BNOPARAMFIND="SCT"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMSC1TRUE=UPPERCASE(BNOPARAMVAL)

[* Source Code 1 when update A&F true & opt-in false
*]
 BNOPARAMFIND="SCF"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMSC1FALSE=UPPERCASE(BNOPARAMVAL)

[* Auth/Fee Option 1 when update A&F true & Opt-in true
*]
 BNOPARAMFIND="AFT"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMAF1TRUE=VALUE(BNOPARAMVAL)

[* Auth/Fee Option 1 when update A&F true & opt-in false
*]
 BNOPARAMFIND="AFF"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMAF1FALSE=VALUE(BNOPARAMVAL)

[* Overdraft Tolerance Amount
*]
 FOR BNOPARAMLOOP=1 TO BNOCFGPARAMCOUNT
  DO
   IF BNOCFGPARAM(BNOPARAMLOOP)="OTA" THEN
    DO
     BNOPARAMVAL=BNOCFGPARAMVAL(BNOPARAMLOOP)
     COLONPOS=CHARACTERSEARCH(BNOPARAMVAL,":")
     IF COLONPOS>1 AND
        COLONPOS<LENGTH(BNOPARAMVAL) THEN
      DO
       IF UPPERCASE(SEGMENT(BNOPARAMVAL,1,COLONPOS-1))="XXXX" THEN
        PARAMDEFAULTOTAVALUE=MONEY(VALUE(SEGMENT(BNOPARAMVAL,COLONPOS+1,LENGTH(BNOPARAMVAL))))
       ELSE IF PARAMOTACOUNT<PARAMOTAMAX THEN
        DO
         PARAMOTACOUNT=PARAMOTACOUNT+1
         PARAMOTASHARETYPE(PARAMOTACOUNT)=VALUE(SEGMENT(BNOPARAMVAL,1,COLONPOS-1))
         PARAMOTAAMOUNT(PARAMOTACOUNT)=MONEY(VALUE(SEGMENT(BNOPARAMVAL,COLONPOS+1,LENGTH(BNOPARAMVAL))))
        END
      END [IF COLONPOS>1 AND...]
    END
  END


[* Get any display error messages if configured in CFG file
*]
 CALL GETERRORDISPLAYMESSAGES
 
 BNOPARAMFIND="SLS"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  DO
   IF CHARACTERSEARCH("TRUEYES1ON",BNOPARAMVAL)>0 THEN
    PARAMLANGSPANISH=TRUE
   ELSE 
    PARAMLANGSPANISH=FALSE 
  END

 BNOPARAMFIND="PID"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMPROGINSTALLDATE=DATEVALUE(BNOPARAMVAL)

[* Test parameters
*]
 BNOPARAMFIND="DEBUGMODE"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE AND BNOPARAMVAL<>"" THEN
  DO
   IF CHARACTERSEARCH("TRUEYES1ON",BNOPARAMVAL)>0 THEN
    PARAMDEBUGMODE=BNODEBUGMODEON
   ELSE 
    PARAMDEBUGMODE=BNODEBUGMODEOFF 
  END

 BNOPARAMFIND="TESTMODE"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  DO
   IF CHARACTERSEARCH("TRUEYES1ON",BNOPARAMVAL)>0 THEN
    PARAMTESTMODE=TRUE
  END

 BNOPARAMFIND="TESTEC"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE AND
    BNOPARAMVAL<>"" THEN
  PARAMTESTEC=VALUE(BNOPARAMVAL)
END [PROCEDURE]

PROCEDURE PARAMPOSTPROCESS
[* Post-processing of the param/cfg variables
*]

[* Add defaults if the CMMS (custom memo mode success) message is not set in the CFG
*]
 PARAMMSGALLTAG="CMMS"
 PARAMMSGALLLANG=PARAMMSGTAGENGLISH
 CALL PARAMMSGALLFIND
 IF PARAMMSGALLTAGFOUND=FALSE THEN
  DO
   PARAMMSGALLVAL="Nightly processing is underway. Your overdraft settings have been processed"
   CALL PARAMMSGALLADD
   PARAMMSGALLVAL="and will be reflected the next business day."
   CALL PARAMMSGALLADD
  END
 [**TODO** need spanish translations here]
 PARAMMSGALLLANG=PARAMMSGTAGSPANISH
 CALL PARAMMSGALLFIND
 IF PARAMMSGALLTAGFOUND=FALSE THEN
  DO
   PARAMMSGALLVAL="Nightly processing is underway. Your overdraft settings have been processed"
   CALL PARAMMSGALLADD
   PARAMMSGALLVAL="and will be reflected the next business day."
   CALL PARAMMSGALLADD
  END

[* Expand lists
*]
 LELISTINPUT=PARAMINVALIDACCTYPESLIST
 IF LELISTINPUT="" THEN
  LELISTINPUT="NONE"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO 9999
  DO
   PARAMINVALIDACCTYPES(TMPLOOP)=LELIST(TMPLOOP)
  END

 LELISTINPUT=PARAMVALIDSHARETYPESLIST
 IF LELISTINPUT="" THEN
  LELISTINPUT="ALL"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO MAXSLTYPES
  DO
   PARAMVALIDSHARETYPES(TMPLOOP)=LELIST(TMPLOOP)
  END

 LELISTINPUT=PARAMWARNINGSACCTLIST
 IF LELISTINPUT="" THEN
  LELISTINPUT="NONE"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO MAXWARNINGTYPES
  DO
   PARAMWARNINGSACCT(TMPLOOP)=LELIST(TMPLOOP)
  END

 LELISTINPUT=PARAMWARNINGSSHARELIST
 IF LELISTINPUT="" THEN
  LELISTINPUT="NONE"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO MAXWARNINGTYPES
  DO
   PARAMWARNINGSSHARE(TMPLOOP)=LELIST(TMPLOOP)
  END

 IF PARAMDEBUGMODE<>BNODEBUGMODEUNDEFINED THEN
  BNODEBUGMODE=PARAMDEBUGMODE
 ELSE IF PARAMPROGINSTALLDATE<>DATENULL THEN
  DO
   IF PARAMPROGINSTALLDATE+BNODEBUGPRINTINFODAYS>SYSTEMDATE THEN
    BNODEBUGMODE=BNODEBUGMODEON
   ELSE 
    BNODEBUGMODE=BNODEBUGMODEOFF 
  END 

 CALL VALIDATEPARAMS
END [PROCEDURE]

PROCEDURE VALIDATEPARAMS
[* Validate required parameters to make sure all necessary parameter settings are present and within required ranges
*]

[* Validate tracking record (>=30 and <=99)
*]
 IF PARAMSHARETRACKING<30 OR
    PARAMSHARETRACKING>99 THEN
  DO
   BNOERRORCODE=BNOERRCODECONFIGVALIDATE
   BNOERRORMODIFIER=BNOERRMODINVALIDTRTYPE
  END

[* validate source code list entries  - if true or false
*]
 IF PARAMUPDATEANDF=TRUE THEN
  DO
   FOR TMPLOOP=1 TO LENGTH(PARAMSC1TRUE)
    DO
     TMPCHR=SEGMENT(PARAMSC1TRUE,TMPLOOP,TMPLOOP)
     IF CHARACTERSEARCH(VALIDSOURCECODELIST,TMPCHR)=0 THEN
      DO
       BNOERRORCODE=BNOERRCODECONFIGVALIDATE
       BNOERRORMODIFIER=BNOERRMODINVALIDSCSCT
      END
    END
  END

 IF PARAMUPDATEANDF=TRUE THEN
  DO
   FOR TMPLOOP=1 TO LENGTH(PARAMSC1FALSE)
    DO
     TMPCHR=SEGMENT(PARAMSC1FALSE,TMPLOOP,TMPLOOP)
     IF CHARACTERSEARCH(VALIDSOURCECODELIST,TMPCHR)=0 THEN
      DO
       BNOERRORCODE=BNOERRCODECONFIGVALIDATE
       BNOERRORMODIFIER=BNOERRMODINVALIDSCSCF
      END
    END
  END

 IF PARAMUPDATEANDF=TRUE AND
   (PARAMAF1TRUE<0 OR PARAMAF1TRUE>7) THEN
  DO
   BNOERRORCODE=BNOERRCODECONFIGVALIDATE
   BNOERRORMODIFIER=BNERRMODINVALIDAFOAFT
  END

 IF PARAMUPDATEANDF=TRUE AND
   (PARAMAF1FALSE<0 OR PARAMAF1FALSE>7) THEN
  DO
   BNOERRORCODE=BNOERRCODECONFIGVALIDATE
   BNOERRORMODIFIER=BNERRMODINVALIDAFOAFF
  END
END [PROCEDURE]

PROCEDURE GETPARAMMSGS

 PARAMMSGALLCOUNT=0
 FOR BNOPARAMLOOP=1 TO BNOCFGPARAMCOUNT
  DO
   PARAMMSGTAGINDEX=1 
   PARAMMSGTAGFOUND=FALSE
   WHILE PARAMMSGTAGINDEX<=PARAMMSGTAGSCOUNT AND PARAMMSGTAGFOUND=FALSE
    DO
     BNOPARAMTMP=BNOCFGPARAM(BNOPARAMLOOP)
     CALL PARAMEXTRACTLANG
     IF PARAMMSGTAGS(PARAMMSGTAGINDEX)=BNOPARAMTMP THEN
      DO
       PARAMMSGTAGFOUND=TRUE
       IF BNOCFGPARAMVAL(BNOPARAMLOOP)<>"" THEN
        PARAMMSGDEFINED(PARAMMSGTAGINDEX)=TRUE

       IF PARAMMSGALLCOUNT<PARAMMSGALLMAX THEN
        DO
         PARAMMSGALLLANG=PARAMMSGTAGLANG
         PARAMMSGALLTAG=BNOPARAMTMP
         PARAMMSGALLVAL=BNOCFGPARAMVAL(BNOPARAMLOOP)
         CALL PARAMMSGALLADD
        END 
      END
     PARAMMSGTAGINDEX=PARAMMSGTAGINDEX+1
    END
  END
END [PROCEDURE]

PROCEDURE PARAMMSGALLADD
[* Update the PARAMMSGALL arrays
**
**  PASS    PARAMMSGALLLANG      Language (English or Spanish)
**  PASS    PARAMMSGALLTAG       Message tag
**  PASS    PARAMMSGALLVAL       Message text/value
*]

 PARAMMSGALLCOUNT=PARAMMSGALLCOUNT+1
 PARAMMSGALLTAGSLANG(PARAMMSGALLCOUNT)=PARAMMSGALLLANG
 PARAMMSGALLTAGS(PARAMMSGALLCOUNT)=PARAMMSGALLTAG
 BNOTEXT=PARAMMSGALLVAL
 CALL BNOCLEANUPTEXT
 PARAMMSGALL(PARAMMSGALLCOUNT)=BNOTEXT
END [PROCEDURE]

PROCEDURE PARAMMSGALLFIND
[* Check to see if a tag and message already exists in the PARAMMSGALL arrays
**
**  PASS    PARAMMSGALLLANG      Language (English or Spanish)
**  PASS    PARAMMSGALLTAG       Message tag
*]

 TMPLOOP=1
 PARAMMSGALLTAGFOUND=FALSE
 WHILE TMPLOOP<=PARAMMSGALLCOUNT AND PARAMMSGALLTAGFOUND=FALSE
  DO
   IF PARAMMSGALLTAGSLANG(TMPLOOP)=PARAMMSGALLLANG AND
      PARAMMSGALLTAGS(TMPLOOP)=PARAMMSGALLTAG AND
      PARAMMSGALL(TMPLOOP)<>"" THEN
    PARAMMSGALLTAGFOUND=TRUE  
   TMPLOOP=TMPLOOP+1
  END
END [PROCEDURE]

PROCEDURE BNOCFGFILEREAD
[* Open and read through the parameter file to create an array of
** parameter names and associated values.
**
**  PASS    BCFGFILENAME      Parameter Letter file name
**  PASS    BNOCFGPARAMMAX    Maximum number of parameters
**  
**  RETURN  BNOCFGFILEFERROR  File open/read error
**  RETURN  BNOERRORCODE      Error code
**  RETURN  BNOCFGPARAM(A)    Parameter Name
**  RETURN  BNOCFGPARAMVAL(A) Parameter Value
**  RETURN  BNOCFGPARAMCOUNT  Parameters Found
**
*]
 BNOCFGPARAMALLOWDUPS=TRUE
 BNOCFGFILEFERROR=""
 BNOCFGPARAMCOUNT=0
 WHILELIMIT=1000000
 FILEOPEN("LETTER",BNOCFGFILENAME,"READ",BNOCFGFILENUMBER,BNOCFGFILEFERROR)
 IF BNOCFGFILEFERROR<>"" THEN
  DO
   BNOERRORCODE=BNOERRCODECONFIGREAD
   BNOERRORMODIFIER=BNOERRMODOPEN
   BNOERRORMODIFIER=BNOCFGFILENAME+" open error - "+BNOCFGFILEFERROR
   BNODEBUGMSG="Error opening CFG param file: "+BNOCFGFILEFERROR
   CALL BNODEBUGMSGADD
  END
 ELSE
  DO
   WHILE BNOCFGFILEFERROR="" AND BNOCFGPARAMCOUNT<BNOCFGPARAMMAX 
    DO
     FILEREADLINE(BNOCFGFILENUMBER,BNOCFGFILELINE,BNOCFGFILEFERROR)
     IF BNOCFGFILEFERROR<>"" AND
        BNOCFGFILEFERROR<>"EOF" THEN
      DO
       BNOERRORCODE=BNOERRCODECONFIGREAD
       BNOERRORMODIFIER=BNOERRMODREAD
       BNOERRORMODIFIER=BNOCFGFILENAME+" read error - "+BNOCFGFILEFERROR
       BNODEBUGMSG="Error reading CFG param file: "+BNOCFGFILEFERROR
       CALL BNODEBUGMSGADD
      END
     ELSE
      DO
       BNOPOS=CHARACTERSEARCH(BNOCFGFILELINE,":")
       IF SEGMENT(BNOCFGFILELINE,1,1)<>"*" AND BNOPOS>1 THEN
        DO
         BNOTEXT=SEGMENT(BNOCFGFILELINE,1,BNOPOS-1)
         CALL BNONLTS
         BNOPARAMTMP=BNOTEXT

         BNOTEXT=SEGMENT(BNOCFGFILELINE,BNOPOS+1,LENGTH(BNOCFGFILELINE))
         CALL BNONLS
         BNOPARAMVALTMP=BNOTEXT

         BNOPARAMFOUND=FALSE
         IF BNOCFGPARAMALLOWDUPS=FALSE THEN 
          DO
           FOR BNOTMPLOOP=1 TO BNOCFGPARAMCOUNT
            DO
             IF BNOCFGPARAM(BNOTMPLOOP)=BNOPARAMTMP THEN
              BNOPARAMFOUND=TRUE
            END
           IF BNOPARAMFOUND=TRUE THEN
            DO
             BNOERRORCODE=BNOERRCODECONFIGVALIDATE
             BNOERRORMODIFIER=BNOERRMODDUPLICATEPARAM
             BNOERRORMODIFIER="Duplicate Param file entry("+BNOPARAMTMP+")"
             BNODEBUGMSG="Duplicate Param file entry: "+BNOPARAMTMP
             CALL BNODEBUGMSGADD
            END
          END

         IF BNOPARAMFOUND=FALSE THEN
          DO
           BNOCFGPARAMCOUNT=BNOCFGPARAMCOUNT+1
           BNOCFGPARAM(BNOCFGPARAMCOUNT)=BNOPARAMTMP
           BNOCFGPARAMVAL(BNOCFGPARAMCOUNT)=BNOPARAMVALTMP
          END
        END  [IF SEGMENT(BNOCFGFILELINE,1,1)<>"*"]
      END  [IF BNOCFGFILEFERROR=""]
    END  [WHILE BNOCFGFILEFERROR=""]
  END

 FILECLOSE(BNOCFGFILENUMBER,BNOCFGFILEFERROR)
END [PROCEDURE]

PROCEDURE BNOCFGDEBUGADD
[* Add CFG lines to debug
*]

 IF BNODEBUGMODE=BNODEBUGMODEON AND
    BNODEBUGINCLUDEPARAMS=TRUE THEN
  DO
   FOR TMPLOOP=1 TO BNOCFGPARAMCOUNT
    DO
     BNOTEXT=BNOCFGPARAMVAL(TMPLOOP)
     CALL BNOCLEANUPTEXT
     BNODEBUGMSG="PARAM:"+BNOCFGPARAM(TMPLOOP)+"-"+
                  BNOTEXT
     CALL BNODEBUGMSGADD
    END
  END
END [PROCEDURE]

PROCEDURE BNOGETPARAMVAL
[* Find requested parameter setting and return value.
**
**  PASS    BNOPARAMFIND   Targeted parameter setting
**  
**  RETURN  BNOPARAMFOUND  T/F found flag
**  RETURN  BNOPARAMVAL    Parameter value found
*] 
 BNOPARAMFOUND=FALSE
 FOR BNOPARAMLOOP=1 TO BNOCFGPARAMCOUNT
  DO
   IF BNOCFGPARAM(BNOPARAMLOOP)=BNOPARAMFIND THEN
    DO
     BNOPARAMVAL=BNOCFGPARAMVAL(BNOPARAMLOOP)
     BNOPARAMFOUND=TRUE
     BNOPARAMLOOP=BNOCFGPARAMCOUNT
    END
  END
END [PROCEDURE]

PROCEDURE GETERRORDISPLAYMESSAGES
[* Find the error display lines
*] 
 
 FOR BNOPARAMLOOP=1 TO BNOCFGPARAMCOUNT
  DO
   IF SEGMENT(BNOCFGPARAM(BNOPARAMLOOP),1,3)="EDM" THEN
    DO
     BNOPARAMTMP=BNOCFGPARAM(BNOPARAMLOOP)
     CALL PARAMEXTRACTLANG
     TMPERRCODE=VALUE(SEGMENT(BNOPARAMTMP,4,6))
     IF CHARACTERSEARCH(BNOERRDISPLAYLIST,FORMAT("999",TMPERRCODE))>0 THEN
      DO
       BNOTEXT=BNOCFGPARAMVAL(BNOPARAMLOOP)
       CALL BNONTS
       CALL BNOCLEANUPTEXT
       TMPDISPLAYLINE=BNOTEXT
       CALL PARAMERRDISPLAYADD
      END
    END
  END
END [PROCEDURE]

PROCEDURE PARAMEXTRACTLANG
[* Extract language suffix and set PARAMMSGTAGLANG.  Return updated BNOPARAMTMP variable.
*]

 PARAMMSGTAGLANG=PARAMMSGTAGENGLISH
 TAGSFXPOS=CHARACTERSEARCH(BNOPARAMTMP,PARAMMSGTAGENGLISHSFX)
 IF TAGSFXPOS<>0 AND
    TAGSFXPOS=LENGTH(BNOPARAMTMP)-2 THEN
  BNOPARAMTMP=SEGMENT(BNOPARAMTMP,1,LENGTH(BNOPARAMTMP)-3)
 TAGSFXPOS=CHARACTERSEARCH(BNOPARAMTMP,PARAMMSGTAGSPANISHSFX)
 IF TAGSFXPOS<>0 AND
    TAGSFXPOS=LENGTH(BNOPARAMTMP)-2 THEN
  DO
   BNOPARAMTMP=SEGMENT(BNOPARAMTMP,1,LENGTH(BNOPARAMTMP)-3)
   PARAMMSGTAGLANG=PARAMMSGTAGSPANISH
  END 
END [PROCEDURE]

PROCEDURE PARAMERRDISPLAYADD

 IF PARAMERRDISPLAYCOUNT<PARAMERRDISPLAYMAX THEN
  DO
   PARAMERRDISPLAYCOUNT=PARAMERRDISPLAYCOUNT+1
   PARAMERRDISPLAYERRCODES(PARAMERRDISPLAYCOUNT)=TMPERRCODE
   PARAMERRDISPLAYLANG(PARAMERRDISPLAYCOUNT)=PARAMMSGTAGLANG
   BNOTEXT=TMPDISPLAYLINE
   CALL BNONTS
   PARAMERRDISPLAYLINES(PARAMERRDISPLAYCOUNT)=BNOTEXT
  END
END [PROCEDURE]

PROCEDURE BNOERRDISPLAYLISTADD
[* Add to the list of errors that support error display messages.  Used to 
** register those error codes that support display messages.
*]

 IF BNOERRDISPLAYLIST<>"" THEN
  BNOERRDISPLAYLIST=BNOERRDISPLAYLIST+","
 BNOERRDISPLAYLIST=BNOERRDISPLAYLIST+FORMAT("999",BNOERRDISPLAYCODE)
END [PROCEDURE]

PROCEDURE GETBNOERRDISPLAYMSG

 PARAMERRDISPLAYINDEX=1
 BNOERRDISPLAYMSGCOUNT=0
 WHILE PARAMERRDISPLAYINDEX<=PARAMERRDISPLAYCOUNT AND
       BNOERRDISPLAYMSGCOUNT<BNOERRDISPLAYMSGSMAX
  DO
   IF PARAMERRDISPLAYERRCODES(PARAMERRDISPLAYINDEX)=BNOERRCODE AND
      PARAMERRDISPLAYLANG(PARAMERRDISPLAYINDEX)=PARAMMSGTAGLANG THEN
    DO
     BNOERRDISPLAYMSGCOUNT=BNOERRDISPLAYMSGCOUNT+1
     BNOERRDISPLAYMSG(BNOERRDISPLAYMSGCOUNT)=PARAMERRDISPLAYLINES(PARAMERRDISPLAYINDEX)
    END  
   PARAMERRDISPLAYINDEX=PARAMERRDISPLAYINDEX+1
  END

 IF BNOERRDISPLAYMSGCOUNT=1 AND
    BNOERRDISPLAYMSG(1)="" THEN
  BNOERRDISPLAYMSGCOUNT=0  
END [PROCEDURE]

[*
**  --------------------------------------------------------------------
**  JSON Procedures
**  --------------------------------------------------------------------
*]

PROCEDURE JSONERRORMEMOMODE
[* Output the JSON for error due to system being in memo mode
*]

 JSONPROPNAME="results"
 CALL JSONPROPFIRST
 CALL JSONOBJ
 NEWLINE
 
 JSONOBJFIRSTPROP=TRUE
 CALL JSONGENERALSPECS

 JSONPROPNAME="memoMode"
 CALL JSONPROP
 PRINT JSONBOOLEAN(TRUE)
 NEWLINE

 PARAMMSGTAGLANG=PARAMMSGTAGENGLISH
 IF PARAMLANGSPANISH=TRUE THEN
  PARAMMSGTAGLANG=RGLANGUAGE 
 MSGPROPSELECT="memoModeMessage"
 CALL MSGPROPSELECTADD
 CALL JSONMSGARRAYS

 CALL JSONOBJEND [results property]
END [PROCEDURE]

PROCEDURE JSONERROR
[* Output the JSON for an error response
*]

 CALL BNOERRGETMESSAGE

 JSONPROPNAME="results"
 CALL JSONPROPFIRST
 CALL JSONOBJ
 NEWLINE
 
 JSONOBJFIRSTPROP=TRUE
 CALL JSONGENERALSPECS

 JSONPROPNAME="errorCode"
 CALL JSONPROP
 PRINT FORMAT("999",BNOERRCODE)
 NEWLINE

 JSONPROPNAME="errorMessage"
 CALL JSONPROP
 PRINT QQ+BNOERRMESSAGE
 IF BNOERRMODIFIER<>"" THEN
  PRINT ": "+BNOERRMODIFIER
 PRINT QQ
 NEWLINE

 PARAMMSGTAGLANG=PARAMMSGTAGENGLISH
 IF PARAMLANGSPANISH=TRUE THEN
  PARAMMSGTAGLANG=RGLANGUAGE 
 CALL GETBNOERRDISPLAYMSG

[* Fall back to English message if no Spanish message defined for the error display message
*]
 IF BNOERRDISPLAYMSGCOUNT=0 AND
    PARAMMSGTAGLANG=PARAMMSGTAGSPANISH THEN
  DO
   PARAMMSGTAGLANG=PARAMMSGTAGENGLISH
   CALL GETBNOERRDISPLAYMSG
  END  
 
 IF BNOERRDISPLAYMSGCOUNT>0 THEN
  DO
   JSONPROPNAME="errorDisplayMessage"
   CALL JSONPROP

   CALL JSONARRAY
   FOR TMPLOOP=1 TO BNOERRDISPLAYMSGCOUNT
    DO
     BNOTEXT=BNOERRDISPLAYMSG(TMPLOOP)
     CALL BNONTS
     PRINT QQ+BNOTEXT+QQ
     IF TMPLOOP<BNOERRDISPLAYMSGCOUNT THEN
      PRINT ","
     NEWLINE
    END
   CALL JSONARRAYEND
  END

 CALL JSONOBJEND [results property]
END [PROCEDURE]

PROCEDURE JSONSUCCESSPRELOADDATA
[* Output the JSON for successful responses in the PRELOADDATA state
*]

 JSONPROPNAME="results"
 CALL JSONPROPFIRST
 CALL JSONOBJ
 NEWLINE

 JSONOBJFIRSTPROP=TRUE
 CALL JSONGENERALSPECS

 PARAMMSGTAGLANG=PARAMMSGTAGENGLISH
 IF PARAMLANGSPANISH=TRUE THEN
  PARAMMSGTAGLANG=RGLANGUAGE 
 CALL JSONMSGARRAYS

 CALL JSONOBJEND [END results property]
END [PROCEDURE]

PROCEDURE JSONSUCCESSPROCESSDATA
[* Output the JSON for successful responses in the PROCESSDATA state
*]

 JSONPROPNAME="results"
 CALL JSONPROPFIRST
 CALL JSONOBJ
 NEWLINE

 JSONOBJFIRSTPROP=TRUE
 CALL JSONGENERALSPECS

 JSONPROPNAME="success"
 CALL JSONPROP
 PRINT JSONBOOLEAN(TRUE)
 NEWLINE

 CALL JSONOBJEND [END results property]
END [PROCEDURE]

PROCEDURE JSONGENERALSPECS
[* Output the generalSpecifications JSON object
*]

 JSONPROPNAME="generalSpecifications"
 CALL JSONPROP
 CALL JSONOBJ
 NEWLINE

 JSONOBJFIRSTPROP=TRUE
 CALL JSONPROGRAMINFO
 CALL JSONSYSTEMINFO

 CALL JSONOBJEND
END [PROCEDURE]

PROCEDURE JSONPROGRAMINFO
[* Output the programInfo JSON object
*]

 JSONPROPNAME="programInfo"
 CALL JSONPROP
 CALL JSONOBJ
 NEWLINE

 JSONPROPNAME="name"
 CALL JSONPROPFIRST
 PRINT QQ+BNOPROGRAMNAME+QQ
 NEWLINE
 JSONPROPNAME="version"
 CALL JSONPROP
 PRINT QQ+BNOPROGRAMVERSION+QQ
 NEWLINE
 JSONPROPNAME="lastModDate"
 CALL JSONPROP
 PRINT QQ+FORMAT("99/99/99 ",BNOLASTMODDATE)+BNOLASTMODTIME+QQ
 NEWLINE
 IF BNOPROGRAMNOTE1<>"" THEN
  DO
   JSONPROPNAME="note1"
   CALL JSONPROP
   PRINT QQ+BNOPROGRAMNOTE1+QQ
   NEWLINE
  END 
 IF BNOPROGRAMNOTE2<>"" THEN
  DO
   JSONPROPNAME="note2"
   CALL JSONPROP
   PRINT QQ+BNOPROGRAMNOTE2+QQ
   NEWLINE
  END 

 CALL JSONOBJEND
END [PROCEDURE]

PROCEDURE JSONSYSTEMINFO
[* Output the systemInfo JSON object
*]

 JSONPROPNAME="systemInfo"
 CALL JSONPROP
 CALL JSONOBJ
 NEWLINE

 JSONPROPNAME="systemDate"
 CALL JSONPROPFIRST
 PRINT QQ+FORMAT("99/99/9999",SYSTEMDATE)+QQ
 NEWLINE

 JSONPROPNAME="slidLength"
 CALL JSONPROP
 PRINT BNOIDLENGTH
 NEWLINE

 JSONPROPNAME="memoMode"
 CALL JSONPROP
 PRINT JSONBOOLEAN(SYSMEMOMODE)
 NEWLINE

 CALL JSONOBJEND
END [PROCEDURE]

PROCEDURE JSONMSGARRAYS
 
 PARAMMSGTAGINDEX=1 
 WHILE PARAMMSGTAGINDEX<=PARAMMSGTAGSCOUNT
  DO
   MSGTAGSELECTED=FALSE
   IF PARAMMSGOPTIONAL(PARAMMSGTAGINDEX)=FALSE OR
     (PARAMMSGOPTIONAL(PARAMMSGTAGINDEX)=TRUE AND
      PARAMMSGDEFINED(PARAMMSGTAGINDEX)=TRUE) THEN
    MSGTAGSELECTED=TRUE

   IF MSGTAGSELECTED=TRUE AND
      PARAMMSGPROPS(PARAMMSGTAGINDEX)="" THEN
    MSGTAGSELECTED=FALSE

   IF MSGTAGSELECTED=TRUE THEN
    DO
     IF MSGPROPSELECTLIST<>"" AND
        CHARACTERSEARCH(MSGPROPSELECTLIST,PARAMMSGPROPS(PARAMMSGTAGINDEX))=0 THEN
      MSGTAGSELECTED=FALSE  
    END

   IF MSGTAGSELECTED=TRUE THEN 
    DO
     JSONPROPNAME=PARAMMSGPROPS(PARAMMSGTAGINDEX)
     CALL JSONPROP
     CALL JSONARRAY
     NEWLINE
  
     LINECOUNT=0
     FOR PARAMMSGALLINDEX=1 TO PARAMMSGALLCOUNT
      DO
       IF PARAMMSGALLTAGSLANG(PARAMMSGALLINDEX)=PARAMMSGTAGLANG AND
          PARAMMSGALLTAGS(PARAMMSGALLINDEX)=PARAMMSGTAGS(PARAMMSGTAGINDEX) AND
          LINECOUNT<PARAMMSGMAX(PARAMMSGTAGINDEX) THEN
        DO
         LINECOUNT=LINECOUNT+1
         IF LINECOUNT<>1 THEN
          PRINT ","
         PRINT QQ+PARAMMSGALL(PARAMMSGALLINDEX)+QQ
         NEWLINE 
        END
      END
     CALL JSONARRAYEND
    END  
   
   PARAMMSGTAGINDEX=PARAMMSGTAGINDEX+1
  END

 MSGPROPSELECTLIST="" 
END [PROCEDURE]

[*
**  --------------------------------------------------------------------
**  JSON Procedures - Common
**  --------------------------------------------------------------------
*]
PROCEDURE JSONOPEN
[* Output JSON open char
*]
 PRINT "{"
 NEWLINE
END [PROCEDURE]

PROCEDURE JSONCLOSE
[* Output JSON close char
*]
 PRINT "}"
 NEWLINE
END [PROCEDURE]

PROCEDURE JSONOBJ
[* Output JSON object open char
*]
 PRINT "{"
END [PROCEDURE]

PROCEDURE JSONOBJEND
[* Output JSON object close char
*]
 PRINT "}"
 NEWLINE
END [PROCEDURE]

PROCEDURE JSONARRAY
[* Output JSON array open char
*]
 PRINT "["
END [PROCEDURE]

PROCEDURE JSONARRAYEND
[* Output JSON array close char
*]
 PRINT "]"
 NEWLINE
END [PROCEDURE]

PROCEDURE JSONPROPFIRST
 JSONOBJFIRSTPROP=TRUE
 CALL JSONPROP
END

PROCEDURE JSONPROP
[* Output JSON property name
*]
 IF JSONOBJFIRSTPROP=FALSE THEN
  PRINT ","
 PRINT QQ+JSONPROPNAME+QQ+":"
 JSONOBJFIRSTPROP=FALSE
END [PROCEDURE]

[*
**  --------------------------------------------------------------------
**  Debug/Error Processing Procedures
**  --------------------------------------------------------------------
*]

PROCEDURE BNOERRINIT
[* Initialize BNOERR variables
*]

 BNOERRCOUNT=0
 BNOERRMESSAGE=""
 BNOERRDISPLAYMSGCOUNT=0
END [PROCEDURE]

PROCEDURE BNOERRADD
[* Adds an error code to the valid list of error codes
**
**  PASS    BNOERRCODE       Numeric error code
**  PASS    BNOERRMESSAGE    Error description
*]

 IF BNOERRCOUNT<BNOERRMAX THEN
  DO
   BNOERRCOUNT=BNOERRCOUNT+1
   BNOERRCODES(BNOERRCOUNT)=BNOERRCODE
   BNOERRMESSAGES(BNOERRCOUNT)=BNOERRMESSAGE
  END
END [PROCEDURE]

PROCEDURE BNOERRUPDATE
[* Updates an error code error message.  Used to override the error code
** message that was assigned in the SETUP division of the PowerOn.
**
**  PASS    BNOERRCODE       Numeric error code
**  PASS    BNOERRMESSAGE    Error description
*]

 BNOERRTMPCOUNT=1
 BNOERRFOUND=FALSE
 WHILE BNOERRTMPCOUNT<=BNOERRCOUNT AND 
       BNOERRFOUND=FALSE
  DO
   IF BNOERRCODES(BNOERRTMPCOUNT)=BNOERRCODE THEN
    DO
     BNOERRFOUND=TRUE
     BNOERRMESSAGES(BNOERRTMPCOUNT)=BNOERRMESSAGE
    END
   BNOERRTMPCOUNT=BNOERRTMPCOUNT+1
  END
 BNOERRMESSAGE=""
END [PROCEDURE]

PROCEDURE BNOERRGETMESSAGE
[* Gets the error message associated with the BNOERRORCODE
**
**  PASS    BNOERRORCODE     Numeric error code
**  PASS    BNOERRORMODIFIER Msg modifier
**
**  RETURN  BNOERRCODE       Error code
**  RETURN  BNOERRMESSAGE    Error description
**  RETURN  BNOERRMODIFIER   Msg modifier
*]

 BNOERRMESSAGE=BNOERRUNDEFINED
 BNOERRMODIFIER=""
 BNOERRCODE=BNOERRORCODE
 BNOERRTMPCOUNT=1
 WHILE BNOERRTMPCOUNT<=BNOERRCOUNT AND 
       BNOERRMESSAGE=BNOERRUNDEFINED
  DO
   IF BNOERRCODES(BNOERRTMPCOUNT)=BNOERRORCODE THEN
    DO
     BNOERRMESSAGE=BNOERRMESSAGES(BNOERRTMPCOUNT)
     IF BNOERRORMODIFIER<>"" THEN
      BNOERRMODIFIER=BNOERRORMODIFIER
    END 
   BNOERRTMPCOUNT=BNOERRTMPCOUNT+1
  END
END [PROCEDURE]

PROCEDURE BNODEBUGMSGADD
[* Add a message line to the debug message array
**
** PASS    BNODEBUGMSGMAX     Current array index max lines allowed
** PASS    BNODEBUGMSG        Debug message to add to array
**
** RETURN  BNODEBUGCOUNT      Count of debug message lines
** RETURN  BNODEBUGMSGLIST(A) Debug lines of data to print
*]
 IF BNODEBUGCOUNT<BNODEBUGMSGMAX THEN
  DO
   BNODEBUGCOUNT=BNODEBUGCOUNT+1
   BNODEBUGMSGLIST(BNODEBUGCOUNT)=BNODEBUGMSG
   BNODEBUGMSG=""
  END
END [PROCEDURE]

PROCEDURE BNOJSONRGDATA
[* Print @RGUSER[CHR,NUM] data passed from the UX in proper JSON format
**
**  PASS    DEBUGMODE        Boolean: Print debug data, T/F
*]

 IF BNODEBUGMODE=BNODEBUGMODEON THEN
  DO
   JSONPROPNAME="rgData"
   CALL JSONPROP
   CALL JSONARRAY
   NEWLINE
   PRINT QQ+"CHR1:'"+@RGUSERCHR1+"' "+
            "CHR2:'"+@RGUSERCHR2+"'"+QQ+","
   NEWLINE
   PRINT QQ+"CHR3:'"+@RGUSERCHR3+"' "+
            "CHR4:'"+@RGUSERCHR4+"'"+QQ+","
                     
   NEWLINE
   PRINT QQ+"CHR5:'"+@RGUSERCHR5+"' "+
            "NUM1:"+FORMAT("#########9 ",@RGUSERNUM1)+
            "NUM2:"+FORMAT("#########9 ",@RGUSERNUM2)+
            "NUM3:"+FORMAT("#########9 ",@RGUSERNUM3)+
            "NUM4:"+FORMAT("#########9 ",@RGUSERNUM4)+
            "NUM5:"+FORMAT("#########9",@RGUSERNUM5)+QQ
   NEWLINE
   CALL JSONARRAYEND
  END
END [PROCEDURE]

PROCEDURE BNOJSONDEBUGDATA
[* Print debug output in proper JSON format. Requires DEBUGMODE to be
** on (or true).
**
**  PASS  DEBUGMODE           Boolean: Print debug data, T/F
**  PASS  BNODEBUGMSGLIST(A)  Array of debug messages to print
**  PASS  BNODEBUGCOUNT       Number of debug lines to print
*]
 IF BNODEBUGMODE=BNODEBUGMODEON THEN
  DO
   JSONPROPNAME="debugData"
   CALL JSONPROP
   CALL JSONARRAY
   NEWLINE
   PRINT QQ+"Debug note: Debug lines truncated to 126 characters"+QQ
   NEWLINE
   FOR BNODEBUGLOOP=1 TO BNODEBUGCOUNT
    DO
     PRINT ","+QQ+Segment(BNODEBUGMSGLIST(BNODEBUGLOOP),1,126)+QQ
     NEWLINE
    END
   CALL JSONARRAYEND
  END
END [PROCEDURE]

[*
**  --------------------------------------------------------------------
**  Utility Procedures
**  --------------------------------------------------------------------
*]
PROCEDURE BNONLTS
[* Remove leading and trailing spaces
**  PASS       BNOTEXT
**  RETURN     BNOTEXT
*]
 CALL BNONTS
 CALL BNONLS
END [PROCEDURE]

PROCEDURE BNONLS
[* Remove leading spaces
**  PASS       BNOTEXT
**  RETURN     BNOTEXT
*]
 IF LENGTH(BNOTEXT)=0 THEN
  BNOTEXT=""
 ELSE
  DO
   WHILE (LENGTH(BNOTEXT)>0 AND
          SEGMENT(BNOTEXT,1,1)=" ")
    DO
     BNOTEXT=SEGMENT(BNOTEXT,2,LENGTH(BNOTEXT))
    END
  END
END [PROCEDURE]

PROCEDURE BNONTS
[* Remove trailing spaces
**  PASS       BNOTEXT
**  RETURN     BNOTEXT
*]
 IF BNOTEXT<>"" THEN
  BNOTEXT=SEGMENT(BNOTEXT,1,LENGTH(BNOTEXT))
END [PROCEDURE]

PROCEDURE BNONLZ
[* Removes leading zeros. Does not remove leading spaces.
** '00123' results in '123'.
** ' 0123' results in ' 0123'
** '00000' results in ''.
** As a byproduct, trailing spaces are also removed.
**
**  PASS       BNOTEXT
**  RETURN     BNOTEXT
*]
 IF BNOTEXT<>"" THEN
  DO
   WHILE (SEGMENT(BNOTEXT,1,1)="0")
    DO
     IF LENGTH(BNOTEXT)=1 THEN
      BNOTEXT=""
     ELSE
      BNOTEXT=SEGMENT(BNOTEXT,2,LENGTH(BNOTEXT))
    END
  END
END [PROCEDURE]

PROCEDURE BNOAMTTEXT
[* Formats an amount string with dollars/cents and decimal and no leading spaces
**  PASS       BNOAMT
**  RETURN     BNOTEXT
*]

 BNOTEXT=FORMAT("#######9.99",BNOAMT)
 CALL BNONLS
 IF BNOAMT<$0.00 THEN
  BNOTEXT="-"+BNOTEXT
END [PROCEDURE]

PROCEDURE BNOAMTTEXTDISPLAY
[* Formats an amounts string for display
**  PASS       BNOAMT
**  RETURN     BNOTEXT
*]

 BNOTEXT=FORMAT("##,###,##9.99",BNOAMT)
 CALL BNONLS
 BNOTEXT="$"+BNOTEXT
 IF BNOAMT<$0.00 THEN
  BNOTEXT="-"+BNOTEXT
END [PROCEDURE]

PROCEDURE BNORATETEXT
[* Formats an rate string with 3 decimal places and no leading spaces
**  PASS       BNORATE
**  RETURN     BNOTEXT
*]
 
 BNOTEXT=FORMAT("##9.999",BNORATE)
 CALL BNONLS
END [PROCEDURE]

PROCEDURE BNORATETEXTDISPLAY
[* Formats an rate string for display
**  PASS       BNORATE
**  RETURN     BNOTEXT
*]

 CALL BNORATETEXT
 BNOTEXT=BNOTEXT+"%"
END [PROCEDURE]

PROCEDURE BNONUMTEXT
[* Formats a number string with leading neg sign(-) for negative numbers.  No commas
** or spaces.
**  PASS       BNONUM
**  RETURN     BNOTEXT
*]

 BNOTEXT=FORMAT("##########",BNONUM)
 CALL BNONLS
 IF BNONUM<0 THEN
  BNOTEXT="-"+BNOTEXT
END [PROCEDURE]

PROCEDURE BNONUMTEXTDISPLAY
[* Formats a number string for display
**  PASS       BNONUM
**  RETURN     BNOTEXT
*]

 BNOTEXT=FORMAT("#,###,###,##9",BNONUM)
 CALL BNONLS
 IF BNONUM<0 THEN
  BNOTEXT="-"+BNOTEXT
END [PROCEDURE]

PROCEDURE BNOCLEANUPINIT

 LELISTINPUT=BNOCLEANVALIDCHRLIST
 CALL LISTEXPAND
 FOR BNOCLEANLOOP=0 TO BNOCLEANVALIDCHRMAX
  DO
   BNOCLEANVALIDCHRS(BNOCLEANLOOP)=LELIST(BNOCLEANLOOP)
  END
END [PROCEDURE]

PROCEDURE BNOCLEANUPTEXT
[* Check character string and remove out any characters or hidden characters which have an ASCII value
** which is not established in the BNOCLEANVALIDCHRLIST string in the SETUP division . This is to avoid
** display issues with displaying the terms or conditions. Additionally, if a back-slash or double 
** quote is encountered, add a preceding backslash.
**
**  PASS       BNOTEXT   String to test
**  RETURN     BNOTEXT   Updated string
*]
 
 TMPCHR=""
 FOR BNOCLEANLOOP=1 TO LENGTH(BNOTEXT)
  DO
   CHRVAL=CHRVALUE(SEGMENT(BNOTEXT,BNOCLEANLOOP,BNOCLEANLOOP))
   IF  BNOCLEANVALIDCHRS(CHRVAL)=TRUE THEN
    DO
[* Check for back-slash or double-quote. If found, precede with a back-slash
*]
     IF CHRVAL=CHRVALBACKSLASH OR CHRVAL=CHRVALQUOTE THEN
      TMPCHR=TMPCHR+CTRLCHR(CHRVALBACKSLASH)+SEGMENT(BNOTEXT,BNOCLEANLOOP,BNOCLEANLOOP)
     ELSE
      TMPCHR=TMPCHR+SEGMENT(BNOTEXT,BNOCLEANLOOP,BNOCLEANLOOP)
    END
  END
 BNOTEXT=TMPCHR
END [PROCEDURE]

PROCEDURE BNOPARSEDATALINE
[* Parse through a line of delimited data and store individual fields into an array
**
**  PASS    BNODATALINE       Line of data to be parsed
**  PASS    BNODLDELIMITER    Field delimiter (defaults to "|" of not set)
**  RETURN  BNODLFIELD        Array of data elements from the parsed BNODATALINE
**  RETURN  BNODLFIELDCOUNT   Number of elements in the BNODLFIELD array
*]

 IF BNODLDELIMITER="" THEN
  BNODLDELIMITER="|"

 BNODLFIELDCOUNT=0
 FOR BNODLINDEX=0 TO BNODLFIELDMAX
  DO
   BNODLFIELD(BNODLINDEX)=""
  END
 WHILE BNODATALINE<>""
  DO
   BNODLPOS=CHARACTERSEARCH(BNODATALINE,BNODLDELIMITER)
   BNODLFIELDCOUNT=BNODLFIELDCOUNT+1
   IF BNODLPOS=0 THEN
    DO
     BNODLFIELD(BNODLFIELDCOUNT)=BNODATALINE
     BNODATALINE=""
    END
   ELSE
    DO
     BNODLFIELD(BNODLFIELDCOUNT)=SEGMENT(BNODATALINE,1,BNODLPOS-1)
     BNODATALINE=SEGMENT(BNODATALINE,BNODLPOS+1,LENGTH(BNODATALINE))
    END
  END
END [PROCEDURE]

#INCLUDE "RB.LISTEXPAND"
