[*
**  PowerOn Name:             BANNO.NEWSUBCREATE.V1.POW
**  Datafile Name:            BANNO.NEWSUBCREATE.V1.CFG
**  Letterfile Name:          BANNO.NEWSUBCREATE.TERMS.00-19
**  Letterfile Name:          BANNO.NEWSUBCREATE.FEEDISC.00-19
**  Fee Display PowerOn Name: BANNO.NEWSUBCREATE.FEES.V1.POW (template)
**
**  Copyright 2020-2022 Jack Henry and Associates
**
**  Ver. 1.0.0  08/19/2020: Added debug mode switch. When on, config file
**              resides in LETTTERSPECS else in DATAFILES dir.
**  Ver. 1.0.1  09/01/2020: TKainz - Corrected JSON output when Display Rates
**              flag was set to 'off'.
**  Ver. 1.0.2  12/17/2020: TKainz:
**              1. Updated JSON output for Memo Mode
**              2. Updated JSON output when a share group has been
**                 printed
**              3. Modified to remove share group(s) from those
**                 available if funding is required and member does
**                 not have sufficient funds available
**              4. Updated maturity date calculation for clubs
**              5. Updated error handling note record output
**              6. Corrected misspelling of 'sufficient'
**  Ver. 1.0.3  12/21/2020 CSimms:
**              1. Updated Share Div Rate fetch.
**  Ver. 1.0.4  01/13/2021 JuCarson:
**              1. Updated to pull correct SymX client and Service number.
**  Ver. 1.0.5  01/19/2021 TKainz:
**              1. Updated Next ID calculation process to handle
**                 share ID 0000
**  Ver. 1.0.6  01/28/2021 JuCarson:
**              1. Updated to populate min funding options before using in logic.
**  Ver. 1.0.7  01/28/2021 JKeenan
**              1. Updated Error handling to catch error for City + State + Zip
**                 over 40 characters.
**  Ver. 1.0.8  02/10/2021 TKainz:
**              1. Corrected JSON output for div types with a 0.000 rate calculation
**                 which were bypassing current rate calcs and not outputting rate
**                 JSON
**  Ver. 1.0.9  05/12/2021 JKeenan
**              1. Corrected JSON when no shares have and available balance
**              2. Enhanced share type selection to account for available balance for funding
**              3. Enhanced Program info to JSON Output
**              4. Corrected JSON for targeted account warning type
**  Ver. 1.0.10 06/23/2021 JuCarson
**              1. Added Branch to file maintenance section.
**  Ver. 1.1.0  10/20/2022 TKainz
**              1. Add ability for existing name records at the share and/or loan
**                 level to be added (copied) to the new Share. In test mode, only test
**                 accounts will have access to this function.
**              2. Add error-code descriptions to be passed to the UX for display to
**                 the member.
**              3. Add ability to include comment lines in the Group terms and conditions
**                 Letter files.
**              4. Corrected JSON keeping new names added from being displayed by the UX.
**  Ver. 1.2.0  01/04/23 RRobison - New Feature
**              1. Added code that limits the maximum number of shares of each type that can be created.
**              2. Added new account fee support via BANNO.NEWSUBCREATE.FEES.V1.POW.
**  Ver. 1.2.1  04/12/23 JuCarson
**              1. Corrected rate calcs for balance tables starting with a balance limit of $0.00.
**              2. Corrected rate calc issue where 10th balance range in table was not being read.
**  Ver. 1.2.2  05/01/23 JuCarson
**              1. Corrected rate calc for rate selection of 0 (fixed) to get rate from first balance
**                 range slot in dividend type definitions. 
**
**  This Banno service PowerOn allows the user to open a new
**  share on the main account, add a joint, fund.
**
**  For more information check
**  https://github.com/Banno/banno-powerons
**
**  Banno is not responsible for any modifications to this file
**  made by unauthorized personnel.
**
**  DO NOT MODIFY THIS FILE UNLESS YOU KNOW WHAT YOU'RE DOING!
*]

SYMCONNECT
STATELESS

TARGET=ACCOUNT

DEFINE
 #INCLUDE "RD.GETDATA.DEF"
 #INCLUDE "RB.LISTEXPAND.DEF"

 [DATAFILE DEF]
 CONFIGFILENAME            = "BANNO.NEWSUBCREATE.V1.CFG"
 READCONFIGERROR           = CHARACTER

 [FEE VARIABLES]
 SACFEESPECFILENAME        = "BANNO.NEWSUBCREATE.FEES.V1.POW"
 SACFEESPECFILEERROR       = CHARACTER
 SACFEESHARETYPE           = NUMBER
 SACFEEAMT                 = MONEY ARRAY(10)
 SACFEEDESC                = CHARACTER ARRAY(10)
 SACFEEUSERGLCODE          = NUMBER ARRAY(10)
 SACFEECOUNT               = NUMBER
 SACFEEAMTTOTAL            = MONEY
 SACFEEMAX                 = 10
 SACFEESHAREINDEX          = NUMBER
 SACFEESHAREACCTID         = CHARACTER(15) ARRAY(99)
 SACFEESHAREDESC           = CHARACTER(40) ARRAY(99)
 SACFEESHAREAVAILBAL       = MONEY ARRAY(99)
 SACFEESHARECOUNT          = NUMBER
 SACFEESHARECOUNTMAX       = 99

 ADDFEEAMT                 = MONEY
 ADDFEEDESC                = CHARACTER
 ADDFEEUSERGLCODE          = NUMBER

 [PASSED INFO DEF]
 PASSEDINFOREADERROR       = CHARACTER
 POS                       = NUMBER
 NUM                       = NUMBER

 [NAME VARIABLES]
 SACNAMEALLOWFLAG          = CHARACTER
 SACNAMEMAXNEW             = NUMBER
 SACNAMELEVEL              = CHARACTER
 SACNAMETRACKING           = NUMBER
 SACNAMETYPESAFE           = CHARACTER
 SACNAMETYPEUNSAFE         = CHARACTER
 NAMETYPEDESC              = CHARACTER ARRAY(54)
 NAMETYPEUSED              = NUMBER ARRAY(54)
 NAMETYPESAFE              = NUMBER ARRAY(54)
 PRIMARYSSN                = CHARACTER

 NEWNAMETYPE               = NUMBER ARRAY(2)
 NEWNAMEFIRST              = CHARACTER ARRAY(2)
 NEWNAMEMIDDLE             = CHARACTER ARRAY(2)
 NEWNAMELAST               = CHARACTER ARRAY(2)
 NEWNAMESUFFIX             = CHARACTER ARRAY(2)
 NEWNAMESTREET             = CHARACTER ARRAY(2)
 NEWNAMEEXTRA              = CHARACTER ARRAY(2)
 NEWNAMECITY               = CHARACTER ARRAY(2)
 NEWNAMESTATE              = CHARACTER ARRAY(2)
 NEWNAMEZIP                = CHARACTER ARRAY(2)
 NEWNAMEDOB                = DATE ARRAY(2)
 NEWNAMESSN                = CHARACTER ARRAY(2)
 NEWNAMEPHONE              = CHARACTER ARRAY(2)
 NEWNAMEPHONETYPE          = NUMBER ARRAY(2)
 NEWNAMEEMAIL              = CHARACTER ARRAY(2)
 NEWNAMECOUNT              = NUMBER
 ADDNAMEDONE               = NUMBER
 NEWHOMENUMBER             = CHARACTER
 NEWMOBILENUMBER           = CHARACTER
 NEWWORKNUMBER             = CHARACTER
 NEWNAMECREATEERROR        = CHARACTER ARRAY(2)

 [FUNDING VARIABLES]
 SACFUNDREQUIREFLAG        = CHARACTER
 SACFUNDCALCAMT            = MONEY
 SACFUNDMINAMT             = MONEY
 SHAREMINIMUMBALANCE       = MONEY
 SHAREMINIMUMDEPOSIT       = MONEY
 TRANSFERFROMID            = CHARACTER
 TRANSFERAMOUNT            = MONEY
 SEQ1                      = NUMBER
 SEQ2                      = NUMBER
 CAC                       = CHARACTER
 CN                        = CHARACTER
 TRANERRORTEXT             = CHARACTER
 FEETRANERRORTEXT          = CHARACTER
 FEEFROMID                 = CHARACTER
 MINFUNDAMT                = MONEY

 SACDONE                   = NUMBER
 SACEXCLUDEACCTTYPELIST    = CHARACTER
 SACEXCLUDEWARNINGLIST     = CHARACTER
 SACFILENUM                = NUMBER
 SACFILEPOS                = NUMBER
 SACI                      = NUMBER
 SACLINE                   = CHARACTER
 SACLINEPREV               = CHARACTER

 [RATE VARIABLES]
 SACDISPLAYRATEFLAG        = CHARACTER
 SACSETFILLINRATESFLAG     = CHARACTER

 SACTYPEDIVTYPE            = NUMBER
 SACTYPEDIVRATE            = RATE
 DIVDEFRATESELECT          = NUMBER
 DIVDEFFILLINMETHOD        = NUMBER
 DIVDEFINDEXOPTION         = NUMBER
 DIVDEFRATE                = RATE
 DIVDEFBALCUTOFF           = MONEY
 DIVDEFPREVBALCUTOFF       = MONEY
 DONE                      = NUMBER
 RATEDONE                  = NUMBER
 GETRATEERROR              = CHARACTER
 AVAILBALMIN               = MONEY

 SACSHAREGROUP             = NUMBER
 SACSHAREGROUPNAMES        = CHARACTER ARRAY(19)
 SACSHAREGROUPEXISTS       = NUMBER ARRAY(19)
 SACSHAREGROUPSMAX         = NUMBER

 [SHARE TYPES PER GROUP IS LIMITED TO 100]
 SACSHARETYPES             = CHARACTER ARRAY(19,100)
 SACSHAREFUNDMINAMT        = MONEY ARRAY(19,100)
 SACSHARETYPEEXISTS        = NUMBER ARRAY(100)
 SACSHARETYPEEXISTSMAX     = 100
 SACSHARETYPESMAX          = 100

 [GENERIC VARIABLES]
 TRUE                      = 1
 FALSE                     = 0
 I                         = NUMBER
 J                         = NUMBER
 DR                        = NUMBER
 DATENULL                  = '--/--/----'
 FMERRORFLAG               = NUMBER
 LEN                       = NUMBER
 NOSUCHFILEERROR           = "No such file or directory"
 TMPINDEX                  = NUMBER

 [QUALIFY VARIABLES]
 INELIGIBLEREASON          = CHARACTER
 WARNINGEXISTS             = NUMBER
 EXCLUDEWARNINGSMAX        = 999

 [OPENSUB VARIABLES FROM BANNO]
 OPENCATEGORY              = CHARACTER
 OPENTYPE                  = CHARACTER

 [TERMS AND FEE LETTERFILE VARIABLES]
 LFFAILEDFLAG                = NUMBER
 LFNUM                       = NUMBER
 LFERROR                     = CHARACTER
 LFLINE                      = CHARACTER

 [FEE DISCLOSURE VARIABLES]
 SACFEEDISCLINE              = CHARACTER ARRAY(99)
 SACFEEDISCLINECOUNT         = NUMBER
 SACFEEDISCLINEMAX           = 99

 [SHARE VARIABLES]
 SHAREIDAVAILABLE            = NUMBER
 TMPCHR                      = CHARACTER
 TMPLOOP                     = NUMBER
 IDVALUEMAX                  = NUMBER
 TESTLOOP                    = NUMBER ARRAY(10000)
 TMPSID                      = CHARACTER
 IDLENGTH                    = NUMBER
 SHAREIDFOUND                = NUMBER
 SHARETYPEFOUND              = NUMBER
 SHAREERRORMESSAGE           = CHARACTER
 IRSERRORMESSAGE             = CHARACTER
 NAMEERRORTEXT               = CHARACTER
 SHARENAMEERRORTEXT          = CHARACTER
 TRACKINGERRORTEXT           = CHARACTER
 SHARETRACKINGERRORTEXT      = CHARACTER
 TEMPTYPE                    = CHARACTER

 EXISTINGIDS                 = CHARACTER(4) ARRAY(9999,3)   [9999,0 = id]
 IDRANGE                     = CHARACTER(4) ARRAY(9999)
 SFSEARCHLIST                = CHARACTER
 NEXTIDFLAG                  = NUMBER
 IDSET                       = NUMBER
 NEXTID                      = CHARACTER

 SFCURPOS                    = NUMBER
 SFHIGHID                    = NUMBER
 SFLOWID                     = NUMBER
 SFNUMFOUND                  = NUMBER
 SFSEARCHPOS                 = NUMBER
 SFDELIMCHAR                 = CHARACTER

 NEWSHAREDIVDEFDEFINED       = NUMBER
 NEWSHAREDIVDEFRATESELECT    = NUMBER
 NEWSHAREDIVDEFFILLINMETHOD  = NUMBER
 NEWSHAREDIVDEFINDEXOPTION   = NUMBER

 NEWSHAREDIVDEFBALCUTOFF     = MONEY
 NEWSHAREDIVDEFPREVBALCUTOFF = MONEY
 NEWSHAREDIVDEFRATE          = RATE

 NEWSHAREDIVTYPE             = NUMBER
 NEWSHAREDIVRATE             = RATE

 NEWSHAREID                  = CHARACTER
 NEWSHAREMATURITYDATE        = DATE
 MATUREDATEDONE              = NUMBER
 NEWSHARERATE                = RATE
 NEWSHARETYPE                = CHARACTER
 TYPEFOUND                   = NUMBER
 NEWSHAREIRSCODE             = NUMBER
 NEWSHAREIRSSSN              = CHARACTER

 [read incoming @ variables]
 IMPORT=CHARACTER ARRAY(5)

 [TRANSFER VARIABLES]
 SERVICEOUT                  = NUMBER ARRAY(99)
 SYMXINSTANCE                = NUMBER
 SYMXCLIENTNUM               = NUMBER
 TEMPMSG                     = CHARACTER
 PIPE                        = "|"
 TILDE                       = "~"
 AMPERSAND                   = "&"
 LESSTHAN                    = "<"
 GREATERTHAN                 = ">"

 [JSON CHARACTERS]
 Q                         = CHARACTER
 ERRORCODE                 = NUMBER
 ERRORDETAIL               = CHARACTER
 VALIDCHRINPUT1            = CHARACTER
 VALIDCHARS                = NUMBER ARRAY(999)
 MAXCHRVALUE               = 255
 TMPTEXT                   = CHARACTER
 TMPTEXTLOOP               = NUMBER
 CHRVAL                    = NUMBER
 LFLINECOUNT               = NUMBER
 TMPSHARECODE              = NUMBER
 SHARETERMFREQCHR          = CHARACTER ARRAY(1)
 TMPTERMPERIODCHR          = CHARACTER
 TMPSHARENAME              = CHARACTER
 TMPSHAREAVAIL             = MONEY
 TMPSHAREID                = CHARACTER
 XFERSHARECOUNT            = NUMBER
 NAMECOUNT                 = NUMBER
 GETSHARETRANSFERRUN       = NUMBER
  TRANSFERRUNINITIAL       = 0
  TRANSFERRUNFINAL         = 1
 TMPNAMEERROR              = CHARACTER
 TMPSLID                   = CHARACTER

 DISPLAYEXISTINGNAMETYPES  = "1,4,6,8,13,14,19,24,25"
 SYSTEMMEMOMODE            = NUMBER
 NOTELOC                   = NUMBER
 NOTEERROR                 = CHARACTER
 BACKSLASH                 = CHARACTER

 RATEDATARATE              = RATE ARRAY(10)
 RATEDATAMINBAL            = MONEY ARRAY(10)
 RATEDATAMAXBAL            = MONEY ARRAY(10)
 RATEDATALOOP              = NUMBER
 RATEDATAMAX               = 10
 RATEDATAUSED              = NUMBER

 DEBUGMODE              = NUMBER
  DEBUGMODEON           = 1
  DEBUGMODEOFF          = 0
 DATAFILETYPE           = CHARACTER

 ERROR1                 = CHARACTER
 ERROR2                 = CHARACTER
 SHAREGROUPPRINTED      = NUMBER
 SHARETYPEPRINTED       = NUMBER
 FOUND                  = NUMBER
 MEMBERMAXAVAILABLE     = MONEY

 COLONPOS               = NUMBER
 SEMICOLONPOS           = NUMBER
 IDRANGECHR             = CHARACTER
 MAXSHARESCHR           = CHARACTER
 MAXSHARES              = NUMBER
 SHARECOUNT             = NUMBER

 TMPTYPE                = NUMBER
 TMPMONEY               = MONEY
 TMPMINBAL              = MONEY
 TMPMINDEPOSIT          = MONEY
 RATEPRINTED            = NUMBER

 PROGRAMUPDATENOTE1     = CHARACTER
 PROGRAMUPDATENOTE2     = CHARACTER
 PROGRAMVERSION         = CHARACTER
 LASTMODDATE            = DATE
 LASTMODTIME            = CHARACTER
 INDENT                 = CHARACTER ARRAY(9)
 INDENTMAX              = 9

[* Added for v. 1.1.0
*]
 BNODEBUGLOOP              = NUMBER
 BNODEBUGCOUNT             = NUMBER
 BNODEBUGMSGLIST           = CHARACTER ARRAY(999)
 BNODEBUGMSGMAX            = 999
 BNODEBUGMSG               = CHARACTER
 BNODEBUGMODE              = NUMBER
 BNODEBUGMODEOFF           = 0
 BNODEBUGMODEON            = 1
 BNOINDENTMAX              = 9
 BNOINDENT                 = CHARACTER ARRAY(9)
 BNOLOCALLOOP              = NUMBER

 ADDNAMEADDRESSTYPE        = NUMBER
 ADDNAMEBIRTHDATE          = DATE
 ADDNAMECARRIERROUTE       = CHARACTER
 ADDNAMECITY               = CHARACTER(40)
 ADDNAMECOUNTRY            = CHARACTER
 ADDNAMECOUNTRYCODE        = CHARACTER
 ADDNAMEEXADDR             = CHARACTER(40)
 ADDNAMEFIRST              = CHARACTER(40)
 ADDNAMEFOREIGNTIN         = CHARACTER
 ADDNAMEHOMEPHONE          = CHARACTER(12)
 ADDNAMELAST               = CHARACTER(40)
 ADDNAMELASTADDRVERIFDATE  = DATE
 ADDNAMELOCATOR            = NUMBER
 ADDNAMELONGNAME           = CHARACTER(40)
 ADDNAMEMBRADDRLINK        = CHARACTER(40)
 ADDNAMEMBRNUMLINK         = CHARACTER(40)
 ADDNAMEMIDDLE             = CHARACTER
 ADDNAMENAMEFORMAT         = NUMBER
 ADDNAMEPHONETYPE          = NUMBER
 ADDNAMERESTRICT           = NUMBER
 ADDNAMESEX                = CHARACTER
 ADDNAMESHORTNAME          = CHARACTER(16)
 ADDNAMESOURCE             = CHARACTER
 ADDNAMESSN                = CHARACTER(11)
 ADDNAMESSNCERTIFICATION   = NUMBER
 ADDNAMESSNOVERRIDE        = NUMBER
 ADDNAMESSNTYPE            = NUMBER
 ADDNAMESTATE              = CHARACTER(10)
 ADDNAMESTREET             = CHARACTER(40)
 ADDNAMESUBTYPE            = NUMBER
 ADDNAMESUFFIX             = CHARACTER
 ADDNAMETITLE              = CHARACTER
 ADDNAMETYPE               = NUMBER
 ADDNAMEUSPERSONFLAG       = NUMBER
 ADDNAMEZIPCODE            = CHARACTER(10)
 BNODATAFIELDCOUNT         = NUMBER
 BNODATALINE               = CHARACTER
 BNODATALINEFIELD          = CHARACTER ARRAY(19)
 BNODATALINEFIELDMAX       = NUMBER
 BNODATALINEINPUT          = CHARACTER
 BNOPOS                    = NUMBER
 COPYERRORTEXT             = CHARACTER
 COPYINDEX                 = NUMBER
 COPYNAMELISTLOOP          = NUMBER
 COPYNAMESCHR              = CHARACTER
 DUPLICATENAMEFOUND        = NUMBER
 DUPNAMECOUNT              = NUMBER
 EMAILHEADERPRINTED        = NUMBER
 EMAILNAMECOUNT            = NUMBER
 EMAILSENDERROR            = CHARACTER
 LINKERRORTEXT             = CHARACTER
 NAMECOPYLOOP              = NUMBER
 NAMEFOUND                 = NUMBER
 NAMEMERGEACTIVE           = NUMBER
 NAMESTOCOPYLOC            = NUMBER ARRAY(19)
 NAMESTOCOPYNAME           = CHARACTER ARRAY(19)
 NAMESTOCOPYERROR          = CHARACTER ARRAY(19)
 NAMESTOCOPYNAMETYPE       = NUMBER ARRAY(19)
 NAMESTOCOPYCOUNT          = NUMBER
 NAMESTOCOPYLOOP           = NUMBER
 NAMETOCOPYLOC             = NUMBER
 NAMESCOPIEDCOUNT          = NUMBER
 NAMESCOPIEDNAMETYPE       = NUMBER ARRAY(99)
 NAMESCOPIEDNAME           = CHARACTER ARRAY(99)
 NAMESCOPIEDMAX            = 99
 NEWNAMELOC                = NUMBER
 PARSEARRAY                = CHARACTER ARRAY(999)
 PARSEARRAYMAX             = NUMBER
 PRIMARYSHORTNAME          = CHARACTER
 SACCUSTAFFEMAILADDRESS    = CHARACTER
 SACCUSTAFFEMAILSUBJECT    = CHARACTER
 SACNAMECOPYLOANFLAG       = CHARACTER
 SACNAMECOPYLOANTYPES      = CHARACTER
 SACNAMECOPYSHAREFLAG      = CHARACTER
 SACNAMECOPYSHARETYPES     = CHARACTER
 SACTESTMODEACCOUNTLIST    = CHARACTER
 SACTESTMODEFLAG           = CHARACTER
 SLTYPELENGTH              = NUMBER
 SLTYPESMAX                = NUMBER
 TESTACCOUNT               = NUMBER
 TESTACCTLIST              = CHARACTER ARRAY(10)
 TESTACCTLISTCOUNT         = NUMBER
 TESTACCTLISTMAX           = 10
 TESTERRORCODE             = NUMBER
 TESTMODE                  = NUMBER
 TESTNAMECITY              = CHARACTER
 TESTNAMEEXTRAADDRESS      = CHARACTER
 TESTNAMEID                = CHARACTER
 TESTNAMEIDTYPE            = NUMBER
 TESTNAMELOCATOR           = NUMBER
 TESTNAMESHORTNAME         = CHARACTER
 TESTNAMESSN               = CHARACTER
 TESTNAMESTATE             = CHARACTER
 TESTNAMESTREET            = CHARACTER
 TESTNAMEZIPCODE           = CHARACTER
 TMPLOC                    = NUMBER
 TMPNUM                    = NUMBER
 TRUEFALSECHR              = CHARACTER ARRAY(1)
 VALIDLOANNAMETYPES        = NUMBER ARRAY(99)
 VALIDSHARENAMETYPES       = NUMBER ARRAY(99)

 BNODELIMITER              = NUMBER
 BNODELIMNONE              = 0
 BNODELIMQUOTE             = 34
 BNODELIMCR                = 13
 BNODELIMLF                = 10
 BNODELIMCOMMA             = 44
 BNODELIMTAB               = 09
 BNODELIMVB                = 124
 BNODELIMCARET             = 94
 BNODELIMPIPE              = 124
 BNODELIMSEMICOLON         = 59

 ERRORCODEDESCR            = CHARACTER ARRAY(1,19)
 ECDEFAULT                 = 0
 ECCUSTOM                  = 1

 NAMETYPESMAX              = 53

 COPYNAMELIST              = CHARACTER ARRAY(36,20)
 COPYNAMELISTERROR         = CHARACTER ARRAY(20)
 CNLERRORCHR               = CHARACTER
 COPYNAMELISTCOUNT         = NUMBER
 COPYNAMECOUNTMAX          = NUMBER
 CNLSSN                    = 0
 CNLLAST                   = 1
 CNLFIRST                  = 2
 CNLSTREET                 = 3
 CNLEXTRAADDRESS           = 4
 CNLCITY                   = 5
 CNLSTATE                  = 6
 CNLZIPCODE                = 7
 CNLLOC                    = 8
 CNLMBRADDRNUMLINK         = 9
 CNLMEMBERNUMLINK          = 10
 CNLTYPE                   = 11
 CNLSOURCE                 = 12
 CNLBIRTHDATE              = 13
 CNLLOCATOR                = 14
 CNLSHORTNAME              = 15
 CNLLONGNAME               = 16
 CNLADDRESSTYPE            = 17
 CNLSUBTYPE                = 18
 CNLNAMEFORMAT             = 19
 CNLSSNTYPE                = 20
 CNLSSNOVERRIDE            = 21
 CNLSSNCERTIFICATION       = 22
 CNLFOREIGNTIN             = 23
 CNLUSPERSONFLAG           = 24
 CNLTITLE                  = 25
 CNLMIDDLE                 = 26
 CNLSUFFIX                 = 27
 CNLPHONETYPE              = 28
 CNLHOMEPHONE              = 29
 CNLCARRIERROUTE           = 30
 CNLCOUNTRYCODE            = 31
 CNLCOUNTRY                = 32
 CNLRESTRICT               = 33
 CNLLASTADDRVERIFDATE      = 34
 CNLSEX                    = 35
 CNLDUPLICATED             = 36

 MAXERRORCODE              = 514
 BNOPRINTDEBUGINFODAYS     = NUMBER
 CONFIGPROGRAMVER          = CHARACTER
 CONFIGPROGRAMDATE         = DATE
 CONFIGPROGRAMMINDATE      = DATE
 CONFIGPROGRAMMISMATCH     = NUMBER
END

SETUP
 PROGRAMVERSION="1.2.2"
 LASTMODDATE='05/01/23'
 LASTMODTIME="11:00 ET"
 PROGRAMUPDATENOTE1="Corrected issue with fixed"
 PROGRAMUPDATENOTE2="dividend calculations."
 CONFIGPROGRAMMINDATE='10/20/22'

 BNODEBUGMODE=BNODEBUGMODEOFF
 DATAFILETYPE="DATA"
 TRUEFALSECHR(FALSE)="false"
 TRUEFALSECHR(TRUE)="true"
 SACSHAREGROUPSMAX=19

 NAMEMERGEACTIVE=GETDATANUMBER(GETPARAMNAMEMERGEENABLE)

 FOR BNOLOCALLOOP=1 TO BNOINDENTMAX
  DO
   BNOINDENT(BNOLOCALLOOP)=REPEATCHR(" ",BNOLOCALLOOP)
  END

 Q=CTRLCHR(34)
 BACKSLASH=CTRLCHR(92)
 
 BNOPRINTDEBUGINFODAYS=90
 IF LASTMODDATE+BNOPRINTDEBUGINFODAYS>SYSTEMDATE THEN
  BNODEBUGMODE=BNODEBUGMODEON

 PRIMARYSSN = NAME:SSN

 IDLENGTH=GETDATANUMBER(GETPARAMIDLENGTH)
 IF IDLENGTH=2 THEN
  IDVALUEMAX=99
 ELSE
  IDVALUEMAX=9999

 SLTYPELENGTH=GETDATANUMBER(GETPARAMTYPELENGTH)
 IF SLTYPELENGTH=2 THEN
  SLTYPESMAX=99
 ELSE
  SLTYPESMAX=9999

 NAMETYPEDESC(0)  = "Primary"
 NAMETYPEDESC(1)  = "Joint"
 NAMETYPEDESC(2)  = "Mailing"
 NAMETYPEDESC(3)  = "Alt mail"
 NAMETYPEDESC(4)  = "Beneficiary"
 NAMETYPEDESC(5)  = "Custodian"
 NAMETYPEDESC(6)  = "Trustee"
 NAMETYPEDESC(7)  = "Resp Indiv"
 NAMETYPEDESC(8)  = "Power of Atty"
 NAMETYPEDESC(9)  = "Auth Sig"
 NAMETYPEDESC(10) = "Div Payee"
 NAMETYPEDESC(11) = "Mat Payee"
 NAMETYPEDESC(12) = "Ed IRA Ben"
 NAMETYPEDESC(13) = "Next of Kin"
 NAMETYPEDESC(14) = "Rep Payee"
 NAMETYPEDESC(15) = "Grantor"
 NAMETYPEDESC(16) = "Guarantor"
 NAMETYPEDESC(17) = "Ln Co-Maker"
 NAMETYPEDESC(18) = "Ln Co-Borrower"
 NAMETYPEDESC(19) = "Trustor"
 NAMETYPEDESC(20) = "Co-Borrower"
 NAMETYPEDESC(21) = "Co-Signer"
 NAMETYPEDESC(22) = "CTR Owner"
 NAMETYPEDESC(23) = "CTR Transactor"
 NAMETYPEDESC(24) = "DBA"
 NAMETYPEDESC(25) = "Attorney Trust"
 NAMETYPEDESC(26) = "Safe Dep Box Co-own"
 NAMETYPEDESC(27) = "Safe Dep Box Deputy"
 NAMETYPEDESC(28) = "CTR Courier Service"
 NAMETYPEDESC(29) = "Property Address"
 NAMETYPEDESC(30) = "Successor in Interest"
 NAMETYPEDESC(31) = "Information Only"
 NAMETYPEDESC(50) = "CU Acct"
 NAMETYPEDESC(51) = "CU Joint"
 NAMETYPEDESC(52) = "CU Mailing"
 NAMETYPEDESC(53) = "CU Alt"
 VALIDCHRINPUT1="32-126,128-175,181-184,189,190,198,199,208-216,221,222,224-253"
 SHARETERMFREQCHR(0)="month"
 SHARETERMFREQCHR(1)="day"
 SYMXINSTANCE  = @SYMXINSTANCEID
 SYMXCLIENTNUM = @CLIENTNUMBER
 FOR TMPLOOP=1 TO INDENTMAX
  DO
   INDENT(TMPLOOP)=REPEATCHR(" ",TMPLOOP*2)
  END

 CALL SETUPERRORCODES
END [SETUP]

PRINT TITLE="BANNO.NEWSUBCREATE.V1.POW"

 SYSTEMMEMOMODE=SYSMEMOMODE
 CALL READCONFIGFILESETTINGS [GET PARAMETERS INCL GROUPS AND SHARE TYPES MEMBER CAN CREATE]

 [Check if system is in memomode]
 IF SYSTEMMEMOMODE=TRUE THEN
  DO
   PRINT "{"
   NEWLINE
   PRINT "  "+Q+"memoMode"+Q+": true,"
   NEWLINE
   ERRORCODE=500
   CALL ERRORHANDLER
  END

 ELSE [SYSTEM IS NOT IN MEMO MODE]
  DO

   GETSHARETRANSFERRUN=TRANSFERRUNINITIAL
   CALL GETSHARETRANSFERS [CREATE A LIST OF ELIGIBLE FUNDING SHARES]
   CALL SETTESTACCTSTATUS
   IF READCONFIGERROR<>"" OR
      TESTERRORCODE=501 OR
      TESTERRORCODE=500 THEN
    DO
     IF TESTERRORCODE=501 THEN
      READCONFIGERROR="forced errorcode 501"
     PRINT "  {"
     NEWLINE
     CALL PRINTPROGRAMINFO
     IF TESTERRORCODE=500 THEN
      ERRORCODE=500
     ELSE
      ERRORCODE=501
     CALL ERRORHANDLER
     BNODEBUGMSG="CONFIG ERROR CODE:"+FORMAT("999",ERRORCODE)
     CALL BNODEBUGMSGADD
    END
   ELSE
    DO
     IF @RGSTATE="PRELOADDATA" THEN
      DO
       [QUALIFY MEMBER]
       CALL QUALIFYMEMBER
       IF INELIGIBLEREASON="" THEN       [MEMBER IS QUALIFIED, GIVE BACK SHARE OPTIONS]
        DO
         CALL CHECKSHAREIDS

         IF TESTERRORCODE=504 THEN
          SHARETYPEFOUND=FALSE

         IF SHARETYPEFOUND=TRUE THEN
          DO
           PRINT "{"
           NEWLINE
           CALL PRINTPROGRAMINFO
           NEWLINE
           PRINT "  "+Q+"memoMode"+Q+": false,"
           NEWLINE
           PRINT "   "+Q+"canOpenSubShare"+Q+": true,"
           NEWLINE
           PRINT "  "+Q+"results"+Q+":{ "
           NEWLINE
           CALL SHAREOUTPUT

           [CLOSE ALL GROUPS]
           PRINT "    ]"
           NEWLINE

           CALL JSONCLOSE
          END
         ELSE IF SHARETYPEFOUND=FALSE THEN   [there are no share types to give]
          DO
           PRINT "{"
           NEWLINE
           CALL PRINTPROGRAMINFO
           ERRORCODE=504
           CALL ERRORHANDLER
          END
         NEWLINE
        END  [IF INELIGIBLEREASON="" THEN ...]
      END  [PRELOAD STATE]

     IF @RGSTATE="GETTERMSFUNDING" THEN
      DO
       OPENCATEGORY=@RGUSERCHR1
       OPENTYPE=@RGUSERCHR2

       IF TESTERRORCODE=506 OR TESTERRORCODE=512 THEN
        ERRORCODE=TESTERRORCODE

       IF ERRORCODE=0 THEN
        CALL CHECKMAXSHARES

       IF ERRORCODE=0 THEN
        DO
         GETSHARETRANSFERRUN=TRANSFERRUNINITIAL
         CALL GETSHARETRANSFERS
         IF VALUE(SACFUNDREQUIREFLAG)>0 AND
            XFERSHARECOUNT=0 THEN
          ERRORCODE=506   
        END

       IF ERRORCODE=0 THEN
        DO
         SACFEEDISCLINECOUNT=0
         SACFEESHARETYPE=VALUE(OPENTYPE)
         CALL GETSACFEEINFO   
         IF SACFEESPECFILEERROR<>"" AND
            SACFEESPECFILEERROR<>NOSUCHFILEERROR THEN
          ERRORCODE=513
         
         IF ERRORCODE=0 AND
            SACFEEAMT(1)<>$0.00 AND
            SACFEESHARECOUNT=0 THEN
          ERRORCODE=506  

         IF ERRORCODE=0 AND 
            OPENCATEGORY<>"" AND
            SACFEECOUNT>0 THEN
          CALL LOADSUBACCTFEEDISDC
        END

       IF ERRORCODE<>0 THEN
        DO [SEND JSON ERROR]
         NEWLINE
         PRINT "{"
         NEWLINE
         CALL PRINTPROGRAMINFO
         CALL ERRORHANDLER
         NEWLINE
        END
       ELSE
        DO
         [GET TERMS]
         IF OPENCATEGORY<>"" THEN
          DO
           CALL LOADSUBACCTTERMS
          END

         [IS FUNDING REQUIRED]
         CALL GETMINIMUMDEPOSIT [RETURN SACFUNDCALCAMT]
         IF ERRORCODE=0 THEN
          DO
           PRINT Q+"fundingOptions"+Q+":["
           IF XFERSHARECOUNT>0 THEN
            PRINT Q+"electronic"+Q
           IF SACFUNDREQUIREFLAG="0" AND
              SACFUNDCALCAMT=$0.00 THEN
            DO
             IF XFERSHARECOUNT>0 THEN
              PRINT ","
             PRINT Q+"later"+Q
            END
           PRINT "],"
           NEWLINE

           [GET FUNDING INFO]
           IF OPENTYPE<>"" AND
            OPENCATEGORY<>"" THEN
            DO
             MINFUNDAMT=SACFUNDCALCAMT
             CALL PRINTMINFUNDAMT
            END

           [GET SHARE TRANSFER FROM OPTIONS]
           GETSHARETRANSFERRUN=TRANSFERRUNFINAL
           CALL GETSHARETRANSFERS

           CALL JSONFEEINFO
           PRINT "  }"
           NEWLINE
          END
        END
      END  [GETTERMSFUNDING STATE]

     IF @RGSTATE="NAMEPRELOAD" THEN
      DO
       PRINT "{"
       NEWLINE
       CALL PRINTPROGRAMINFO
       PRINT "  "+Q+"memoMode"+Q+": false,"
       NEWLINE
       PRINT "   "+Q+"canOpenSubShare"+Q+": true,"
       NEWLINE

[* RESULTS START
*]
       PRINT "  "+Q+"results"+Q+": {"
       NEWLINE

       BNODEBUGMSG="NAME PRELOAD: SACNAMECOPYSHAREFLAG: "+SACNAMECOPYSHAREFLAG+"  "+
                   "SACNAMECOPYLOANFLAG: "+SACNAMECOPYLOANFLAG+"  "+
                    FORMAT("SACNAMEMAXNEW: 99",SACNAMEMAXNEW)
       CALL BNODEBUGMSGADD

       IF VALUE(SACNAMECOPYSHAREFLAG)=TRUE OR
          VALUE(SACNAMECOPYLOANFLAG)=TRUE THEN
        CALL BUILDCOPYNAMELIST

       BNODEBUGMSG=FORMAT("COPYNAMELISTCOUNT: 99",COPYNAMELISTCOUNT)
       CALL BNODEBUGMSGADD

[* if new names are not allowed or if they are allowed but the max new names
** are set to 0 or and there are no eligible copy names then force set new names
** allowed flag to 0 to bypass UX add names screens
*]
       PRINT "    "+Q+"canAddNames"+Q+": "

       IF VALUE(SACNAMEALLOWFLAG)=0 OR
         (VALUE(SACNAMEALLOWFLAG)=1 AND
          SACNAMEMAXNEW=0 AND
          COPYNAMELISTCOUNT=0) THEN
        DO
         PRINT "false"
         NEWLINE
        END
       ELSE
        DO
         NAMECOUNT=0
         PRINT "true,"
         NEWLINE
         PRINT "    "+Q+"maxNames"+Q+": "[+Q]
         PRINT SACNAMEMAXNEW
         PRINT [Q+]","
         NEWLINE
         [Provide existing names at the ACCOUNT LEVEL]
         CALL PROVIDENAMESINFO
         PRINT ","
         NEWLINE
         PRINT Q+"eligibleCopyNames"+Q+": ["
         NEWLINE
[* Send list of copy eligible names to the UX
*]
         IF COPYNAMELISTCOUNT>0 THEN
          DO
           FOR TMPLOOP=1 TO COPYNAMELISTCOUNT
            DO
             PRINT "{"
             NEWLINE
             PRINT "   "+Q+"name"+Q+": "+Q+COPYNAMELIST(CNLLONGNAME,TMPLOOP)+Q+","
             NEWLINE
             PRINT "   "+Q+"type"+Q+": "+Q+NAMETYPEDESC(VALUE(COPYNAMELIST(CNLTYPE,TMPLOOP)))+Q+","
             NEWLINE
             PRINT "   "+Q+"street"+Q+": "+Q+COPYNAMELIST(CNLSTREET,TMPLOOP)+Q+","
             NEWLINE
             PRINT "   "+Q+"local"+Q+": "+Q+COPYNAMELIST(CNLCITY,TMPLOOP)+" "+
                                             COPYNAMELIST(CNLSTATE,TMPLOOP)+" "+
                                             COPYNAMELIST(CNLZIPCODE,TMPLOOP)+Q+","
             NEWLINE
             PRINT "   "+Q+"nameLoc"+Q+": "+Q+COPYNAMELIST(CNLLOCATOR,TMPLOOP)+Q
             NEWLINE
             PRINT "}"
             IF TMPLOOP<COPYNAMELISTCOUNT THEN
              PRINT ","
             NEWLINE
            END
          END
         PRINT "]"
         NEWLINE

        END [SACNAMEALLOWFLAG="1"]
       PRINT "  }"
       NEWLINE
      END  [NAMEPRELOAD STATE]
     IF @RGSTATE="CREATESHARE" THEN
      DO
       CALL GETPASSEDINFO                      [getting the information from Banno call]
       NEWSHAREIRSSSN=NAME:SSN
       IF PASSEDINFOREADERROR="" THEN
        DO
         TRANERRORTEXT=""
         CALL FEECHECK
         IF TRANERRORTEXT="" THEN
          CALL FUNDSCHECK                       [CHECK FUNDS]
         IF TRANERRORTEXT="" THEN
          DO
           CALL GETNEXTID                      [calulate which share ID to use for new share]
           IF NEWSHAREID<>"" THEN
            DO
             CALL GETNEWSHARERATE              [calculate the rate based on the div type & gets IRS type]
             IF RATEDONE=TRUE THEN
              DO
               CALL GETNEWMATURITYDATE         [calculate the maturity date if a CD or club]
               IF MATUREDATEDONE=TRUE THEN
                DO
                 CALL CREATESHARE
                 IF SHAREERRORMESSAGE="" THEN
                  DO
                   CALL ADDNAME              [if any new names, create them]

[* If UX returns a list of names to be copied over, build a list of eligible names for referencing,
** create new name records then check new name records against other names on the account to
** see if other names have same ssn but different addresses to then be reported to the CU via email
*]
                   IF NAMESTOCOPYCOUNT>0 THEN
                    DO
                     EMAILNAMECOUNT=0
                     CALL BUILDCOPYNAMELIST
                     CALL PROCESSCOPYNAMES
                     CALL DUPLICATENAMECHECK
                    END
                   FEETRANERRORTEXT=""
                   CALL PERFORMTRANSFER      [if transfer info, do transfer]
                   IF TRANERRORTEXT="" THEN
                    CALL PERFORMFEE   

                   PRINT "{"
                   NEWLINE
                   CALL PRINTPROGRAMINFO
                   PRINT "  "+Q+"memoMode"+Q+": false,"
                   NEWLINE
                   PRINT "  "+Q+"canOpenSubShare"+Q+": true,"
                   NEWLINE

                   PRINT "    "+Q+"results"+Q+": {"
                   NEWLINE
                   PRINT "      "+Q+"funding"+Q+": {"
                   NEWLINE
                   IF TRANSFERAMOUNT>$0.00 THEN
                    DO
                     PRINT "        "+Q+"type"+Q+": "+Q+"electronic"+Q+","
                     NEWLINE
                     TMPCHR=FORMAT("#########9.99",TRANSFERAMOUNT)
                     CALL NLS
                     PRINT "        "+Q+"amount"+Q+": "+Q+TMPCHR+Q+","
                     NEWLINE
                     PRINT "        "+Q+"successfulTransfer"+Q+": "
                     IF TRANERRORTEXT="" THEN
                      PRINT "true"
                     ELSE
                      PRINT "false"
                     NEWLINE
                    END
                   ELSE
                    DO
                     PRINT "        "+Q+"type"+Q+": "+Q+"later"+Q
                     NEWLINE
                    END
                   PRINT "      },"
                   NEWLINE
                   IF SACFEECOUNT>0 AND
                      SACFEEAMT(1)<>$0.00 THEN
                    DO
                     PRINT "      "+Q+"fee"+Q+": {"
                     NEWLINE
                     TMPCHR=FORMAT("#########9.99",SACFEEAMT(1))
                     CALL NLS
                     PRINT "        "+Q+"amount"+Q+": "+Q+TMPCHR+Q+","
                     NEWLINE
                     PRINT "        "+Q+"successfulFee"+Q+": "
                     IF FEETRANERRORTEXT="" THEN
                      PRINT "true"
                     ELSE
                      PRINT "false"
                     NEWLINE
                     PRINT "      },"
                     NEWLINE
                    END

                   PRINT "      "+Q+"newShareId"+Q+": "+Q+NEWSHAREID+Q+","
                   NEWLINE
                   PRINT "      "+Q+"names"+Q+": ["
                   IF NEWNAMECOUNT>0 THEN
                    DO
                     FOR J=1 TO NEWNAMECOUNT
                      DO
                       PRINT "        {"+Q+"nameType"+Q+": "+Q+NAMETYPEDESC(NEWNAMETYPE(J))+Q+", "
                       NEWLINE
                       PRINT "        "+Q+"name"+Q+": "+Q+NEWNAMEFIRST(J)+" "+NEWNAMELAST(J)+Q+", "
                       NEWLINE
                       PRINT "        "+Q+"created"+Q+": "
                       IF NEWNAMECREATEERROR(J)="" then
                        PRINT "true"
                       ELSE
                        PRINT "false"
                       NEWLINE
                       PRINT "}"
                       IF J<NEWNAMECOUNT OR
                         (J=NEWNAMECOUNT AND NAMESTOCOPYCOUNT>0) THEN
                        PRINT ","
                       NEWLINE
                      END [FOR J=1 TO NEWNAMECOUNT]
                    END [IF NEWNAMECOUNT>0]
                   IF NAMESTOCOPYCOUNT>0 THEN
                    DO
                     FOR J=1 TO NAMESTOCOPYCOUNT
                      DO
                       PRINT "        {"+Q+"nameType"+Q+": "+Q+NAMETYPEDESC(NAMESTOCOPYNAMETYPE(J))+Q+", "
                       NEWLINE
                       PRINT "        "+Q+"name"+Q+": "+Q+NAMESTOCOPYNAME(J)+Q+", "
                       NEWLINE
                       PRINT "        "+Q+"created"+Q+": "
                       IF NAMESTOCOPYERROR(J)="" then
                        PRINT "true"
                       ELSE
                        PRINT "false"
                       NEWLINE
                       PRINT "}"
                       IF J<NAMESTOCOPYCOUNT THEN
                        PRINT ","
                       NEWLINE
                      END
                    END
                   PRINT "      ]"
                   NEWLINE
                   PRINT "    }"
                   NEWLINE
                  END                          [end create share]
                END                            [end maturity date]
              END                              [end interest rate]
            END                                [end get ID]
          END                                  [end check funds]
        END                                    [end of passed info]
      END                                      [end CREATESHARE STATE]
    END [READCONFIGGOOD]
  END  [NOT IN MEMOMODE]

 CALL BNOPRINTDEBUG
 PRINT BNOINDENT(0)+"}"
 NEWLINE

END [PRINT]

PROCEDURE READCONFIGFILESETTINGS
[* Read the configuration settings from the CFG data file.
*]
 FILEOPEN(DATAFILETYPE,CONFIGFILENAME,"READ",SACFILENUM,READCONFIGERROR)
 WHILELIMIT=100000
 SACDONE=FALSE
 WHILE READCONFIGERROR="" AND SACDONE=FALSE
  DO
   FILEREADLINE(SACFILENUM,SACLINE,READCONFIGERROR)
   IF READCONFIGERROR="" THEN
    DO
     IF CHARACTERSEARCH(UPPERCASE(SACLINE),"END OF FILE")>0 THEN
      SACDONE=TRUE
     ELSE IF CHARACTERSEARCH(SACLINE,"#!")>0 THEN
      DO
       SACLINEPREV=SACLINE
       FILEREADLINE(SACFILENUM,SACLINE,READCONFIGERROR)
       IF READCONFIGERROR="" THEN
        DO                      [  If next line does NOT have #! in it. ]
         IF CHARACTERSEARCH(SACLINE,"#!")=0 THEN
          DO
           IF CHARACTERSEARCH(SACLINEPREV,"WARNINGS")>0 THEN
            SACEXCLUDEWARNINGLIST=SACLINE
           ELSE IF CHARACTERSEARCH(SACLINEPREV,"ACCTTYPES")>0 THEN
            SACEXCLUDEACCTTYPELIST=SACLINE
           ELSE IF CHARACTERSEARCH(SACLINEPREV,"MAXNEWNAMES")>0 THEN
            SACNAMEMAXNEW=VALUE(SACLINE)
           ELSE IF CHARACTERSEARCH(SACLINEPREV,"DISPLAYRATESFLAG")>0 THEN
            SACDISPLAYRATEFLAG=SACLINE
           ELSE IF CHARACTERSEARCH(SACLINEPREV,"SETFILLINRATESFLAG")>0 THEN
            SACSETFILLINRATESFLAG=SACLINE
           ELSE IF CHARACTERSEARCH(SACLINEPREV,"REQUIREFUNDINGFLAG")>0 THEN
            SACFUNDREQUIREFLAG=SACLINE
           ELSE IF CHARACTERSEARCH(SACLINEPREV,"MINFUNDINGAMT")>0 THEN
            SACFUNDMINAMT=MONEY(VALUE(SACLINE))
           ELSE IF CHARACTERSEARCH(SACLINEPREV,"ALLOWNAMESFLAG")>0 THEN
            SACNAMEALLOWFLAG=SACLINE
           ELSE IF CHARACTERSEARCH(SACLINEPREV,"NAMELEVEL")>0 THEN
            SACNAMELEVEL=SACLINE
           ELSE IF CHARACTERSEARCH(SACLINEPREV,"NAMETRACKINGTYPE")>0 THEN
            SACNAMETRACKING=VALUE(SACLINE)
           ELSE IF CHARACTERSEARCH(SACLINEPREV,"NAMETYPESAFE")>0 THEN
            DO
             SACNAMETYPESAFE=SACLINE
             IF SACNAMETYPESAFE="" THEN
              SACNAMETYPESAFE="NONE"
             LELISTINPUT=SACNAMETYPESAFE
             CALL LISTEXPAND
             FOR TMPLOOP=1 TO 99
              DO
               IF LELIST(TMPLOOP)=TRUE THEN
                DO
                 NAMETYPEUSED(TMPLOOP)=TRUE
                 NAMETYPESAFE(TMPLOOP)=TRUE
                END
              END
            END
           ELSE IF CHARACTERSEARCH(SACLINEPREV,"NAMETYPEUNSAFE")>0 THEN
            DO
             SACNAMETYPEUNSAFE=SACLINE
             IF SACNAMETYPEUNSAFE="" THEN
              SACNAMETYPEUNSAFE="NONE"
             LELISTINPUT=SACNAMETYPEUNSAFE
             CALL LISTEXPAND
             FOR TMPLOOP=1 TO 99
              DO
               IF LELIST(TMPLOOP)=TRUE THEN
                DO
                 NAMETYPEUSED(TMPLOOP)=TRUE
                END
              END
            END
[*TEK - v 1.1.0: Add param settings for CU staff email address, subject line,
** test mode on/off flag, test mode account list, test mode forced error code,
** name copy share and loan flags, name copy share/loan eligible name types.
*]
           ELSE IF CHARACTERSEARCH(SACLINEPREV,"CUSTAFFEMAILADDRESS")>0 THEN
            SACCUSTAFFEMAILADDRESS=SACLINE
           ELSE IF CHARACTERSEARCH(SACLINEPREV,"CUSTAFFEMAILSUBJECT")>0 THEN
            SACCUSTAFFEMAILSUBJECT=SACLINE
           ELSE IF CHARACTERSEARCH(SACLINEPREV,"TESTMODEFLAG")>0 THEN
            SACTESTMODEFLAG=SACLINE
           ELSE IF CHARACTERSEARCH(SACLINEPREV,"TESTMODEACCOUNTLIST")>0 THEN
            SACTESTMODEACCOUNTLIST=SACLINE
           ELSE IF CHARACTERSEARCH(SACLINEPREV,"TESTERRORCODE")>0 THEN
            DO
             TESTERRORCODE=VALUE(SACLINE)
             BNODEBUGMSG=FORMAT("Testing Error Code: 999",TESTERRORCODE)
             CALL BNODEBUGMSGADD
            END
           ELSE IF CHARACTERSEARCH(SACLINEPREV,"ERRORCODECHR")>0 THEN
            DO
             TMPNUM=VALUE(SACLINEPREV)
             IF TMPNUM>=500 AND
                TMPNUM<=MAXERRORCODE THEN
              DO
               TMPNUM=TMPNUM-500
               ERRORCODEDESCR(ECCUSTOM,TMPNUM)=SACLINE
              END
            END
           ELSE IF CHARACTERSEARCH(SACLINEPREV,"NAMECOPYSHAREFLAG")>0 THEN
            DO
             SACNAMECOPYSHAREFLAG=SACLINE
            END
           ELSE IF CHARACTERSEARCH(SACLINEPREV,"NAMECOPYSHARETYPES")>0 THEN
            DO
             SACNAMECOPYSHARETYPES=SACLINE
             IF VALUE(SACNAMECOPYSHAREFLAG)=TRUE THEN
              DO
               LELISTINPUT=SACNAMECOPYSHARETYPES
               CALL LISTEXPAND
               FOR TMPLOOP=0 TO NAMETYPESMAX
                DO
                 VALIDSHARENAMETYPES(TMPLOOP)=LELIST(TMPLOOP)
                END
              END
            END
           ELSE IF CHARACTERSEARCH(SACLINEPREV,"NAMECOPYLOANFLAG")>0 THEN
            DO
             SACNAMECOPYLOANFLAG=SACLINE
            END
           ELSE IF CHARACTERSEARCH(SACLINEPREV,"NAMECOPYLOANTYPES")>0 THEN
            DO
             SACNAMECOPYLOANTYPES=SACLINE
             IF VALUE(SACNAMECOPYLOANFLAG)=TRUE THEN
              DO
               LELISTINPUT=SACNAMECOPYLOANTYPES
               CALL LISTEXPAND
               FOR TMPLOOP=0 TO NAMETYPESMAX
                DO
                 VALIDLOANNAMETYPES(TMPLOOP)=LELIST(TMPLOOP)
                END
              END
            END
           ELSE IF CHARACTERSEARCH(SACLINEPREV,"CONFIGPROGRAMVER")>0 THEN
            DO
             CONFIGPROGRAMVER=SACLINE
             POS=CHARACTERSEARCH(CONFIGPROGRAMVER," ")
             IF POS>05 THEN
              CONFIGPROGRAMDATE=DATEVALUE(SEGMENT(CONFIGPROGRAMVER,POS+1,LENGTH(CONFIGPROGRAMVER)))
            END
           ELSE IF CHARACTERSEARCH(SACLINEPREV,"SHARE TYPES")>0 THEN
            DO
             SACSHAREGROUP=VALUE(SEGMENT(SACLINEPREV, 12,
                               CHARACTERSEARCH(SACLINEPREV,":")-1))
             SACSHAREGROUPNAMES(SACSHAREGROUP)=
              SEGMENT(SACLINEPREV,CHARACTERSEARCH(SACLINEPREV,":")+1,
               LENGTH(SACLINEPREV))
             IF SACSHAREGROUP > -1 AND
                SACSHAREGROUP <= SACSHAREGROUPSMAX THEN
              DO
               SACI=0
               WHILELIMIT=20000
               WHILE CHARACTERSEARCH(SACLINE,"#!")=0
                DO
                 IF SACI<=SACSHARETYPESMAX AND SACLINE<>"" THEN
                  DO
                   SACSHARETYPES(SACSHAREGROUP,SACI)=SACLINE
                   SACI=SACI+1
                  END
                 FILEGETPOS(SACFILENUM,SACFILEPOS,READCONFIGERROR)
                 FILEREADLINE(SACFILENUM,SACLINE,READCONFIGERROR)
                 IF CHARACTERSEARCH(SACLINE,"#!")>0 THEN
                  FILESETPOS(SACFILENUM,SACFILEPOS,READCONFIGERROR)
                END
              END
            END
          END
        END
      END
    END
  END
 FILECLOSE(SACFILENUM,READCONFIGERROR)

 IF READCONFIGERROR="" THEN
  DO
   CONFIGPROGRAMMISMATCH=FALSE
   IF CONFIGPROGRAMDATE=DATENULL OR
      CONFIGPROGRAMDATE<CONFIGPROGRAMMINDATE THEN
    DO
     CONFIGPROGRAMMISMATCH=TRUE
     READCONFIGERROR="Config program mismatch"
    END

   BNODEBUGMSG="CONFIGPROGRAMVER :"+CONFIGPROGRAMVER+
               FORMAT(" CONFIGPROGRAMDATE: 99/99/99",CONFIGPROGRAMDATE)+
               FORMAT(" CONFIGPROGRAMMINDATE: 99/99/99",CONFIGPROGRAMMINDATE)
   CALL BNODEBUGMSGADD
   BNODEBUGMSG="READCONFIGERROR="+READCONFIGERROR
   CALL BNODEBUGMSGADD
   BNODEBUGMSG="After CFG File read ("+DATAFILETYPE+")  "+
               "SACNAMECOPYSHAREFLAG: "+SACNAMECOPYSHAREFLAG+"  "+
               "SACNAMECOPYLOANFLAG: "+SACNAMECOPYLOANFLAG+"  "+
               FORMAT("SACNAMEMAXNEW: 99",SACNAMEMAXNEW)+"  "+
               FORMAT("COPYNAMELISTCOUNT: 99",COPYNAMELISTCOUNT)
   CALL BNODEBUGMSGADD
  END
END [PROCEDURE READ CONFIG FILE]

PROCEDURE QUALIFYMEMBER
[* Check for exclusionary account level warnings or
** account types to exclude and display error/info
** message as applicable
*]
 INELIGIBLEREASON=""

 [CHECK FOR WARNINGS]
 IF SACEXCLUDEWARNINGLIST="" THEN
  SACEXCLUDEWARNINGLIST="none"
 LELISTINPUT=SACEXCLUDEWARNINGLIST
 CALL LISTEXPAND

 WARNINGEXISTS=FALSE
 FOR I=1 TO EXCLUDEWARNINGSMAX
  DO

   IF TESTERRORCODE=502 THEN
    DO
     I=EXCLUDEWARNINGSMAX
     LELIST(I)=TRUE
    END

   IF (ANYWARNING(ACCOUNT,I) AND
       LELIST(I)=TRUE) OR
       TESTERRORCODE=502 THEN
    DO
     IF INELIGIBLEREASON="" THEN
      DO
       INELIGIBLEREASON="ACCOUNT WARNING"
       PRINT "{"
       NEWLINE
       PRINT "  "+Q+"canOpenSubShare"+Q+": false,"
       NEWLINE
       CALL PRINTPROGRAMINFO
       ERRORCODE=502
       CALL ERRORHANDLER
       I=EXCLUDEWARNINGSMAX
      END
    END
  END

 [CHECK THE ACCOUNT TYPE]
 IF INELIGIBLEREASON="" THEN
  DO
   LELISTINPUT=SACEXCLUDEACCTTYPELIST
   IF LELISTINPUT="" THEN
    LELISTINPUT="none"
   CALL LISTEXPAND
   IF LELIST(ACCOUNT:TYPE)=TRUE OR
      TESTERRORCODE=503 THEN
    DO
     PRINT "{"
     NEWLINE
     CALL PRINTPROGRAMINFO
     PRINT "  "+Q+"canOpenSubShare"+Q+": false,"
     NEWLINE
     INELIGIBLEREASON="EXCLUDED ACCT TYPE"
     ERRORCODE=503
     CALL ERRORHANDLER
    END
  END
END [QUALIFY MEMBER PROC]

PROCEDURE LOADSUBACCTTERMS
[* Load the appropriate TOC data based upon the share group type
** chosen by the member (0-9).  Procedure reads a line and writes a line
** from the appropriately named Letter file
*]
 LFFAILEDFLAG=FALSE
 TMPCHR="BANNO.NEWSUBACCT.TERMS."+FORMAT("99",VALUE(OPENCATEGORY))
 FILEOPEN("LETTER",TMPCHR,"READ",LFNUM,LFERROR)

 IF TESTERRORCODE=505 THEN
  LFERROR="Forced error 505 for testing"

 IF LFERROR<>"" THEN
  DO
   PRINT "{"
   NEWLINE
   CALL PRINTPROGRAMINFO
   ERRORCODE=505
   CALL ERRORHANDLER
  END
 ELSE
  DO
   WHILELIMIT=20000
   LFLINECOUNT=0
   PRINT "{"
   NEWLINE
   CALL PRINTPROGRAMINFO
   PRINT "  "+Q+"memoMode"+Q+": false,"
   NEWLINE
   PRINT "  "+Q+"canOpenSubShare"+Q+": true,"
   NEWLINE
   WHILE LFERROR=""
    DO
     FILEREADLINE(LFNUM,LFLINE,LFERROR)
     TMPCHR=LFLINE
     CALL CLEANUPTEXT
[*TEK - v 1.1.0: Added to allow use of comment lines in the TOC Letter files
*]
     IF SEGMENT(LFLINE,1,1)<>"*" THEN
      DO
       IF LFLINECOUNT=0 THEN
        DO
         PRINT "  "+Q+"results"+Q+": {"
         NEWLINE
         PRINT "    "+Q+"categoryTerms"+Q+":["
         NEWLINE
        END
       ELSE
        DO
         PRINT ","
         NEWLINE
        END
       PRINT Q+TMPCHR+Q
       LFLINECOUNT=LFLINECOUNT+1
      END
    END
   PRINT "],"
   NEWLINE
   FILECLOSE(LFNUM,LFERROR)
  END
END [PROCEDURE TERMS]

PROCEDURE LOADSUBACCTFEEDISDC
[* Load the appropriate fee disclosure letterfile data based upon the share group type
** chosen by the member (0-9).  
*]
 LFFAILEDFLAG=FALSE
 TMPCHR="BANNO.NEWSUBACCT.FEEDISC."+FORMAT("99",VALUE(OPENCATEGORY))
 FILEOPEN("LETTER",TMPCHR,"READ",LFNUM,LFERROR)

 IF TESTERRORCODE=514 THEN
  LFERROR="Forced error 514 for testing"
 
 IF LFERROR<>"" THEN
  DO
   ERRORCODE=514
   CALL ERRORHANDLER
  END
 ELSE
  DO
   WHILELIMIT=20000
   WHILE LFERROR=""
    DO
     FILEREADLINE(LFNUM,LFLINE,LFERROR)
     TMPCHR=LFLINE
     CALL CLEANUPTEXT
     IF SEGMENT(LFLINE,1,1)<>"*" AND
        SACFEEDISCLINECOUNT<SACFEEDISCLINEMAX THEN
      DO
       SACFEEDISCLINECOUNT=SACFEEDISCLINECOUNT+1
       SACFEEDISCLINE(SACFEEDISCLINECOUNT)=TMPCHR
      END
    END
   FILECLOSE(LFNUM,LFERROR)
  END
END [PROCEDURE FEE DISCLOSURE]

PROCEDURE GETMINIMUMDEPOSIT
[* Using the share type, get the minimum balance, minimum deposit and,
** if applicable, the minimum opening deposit amount set in the parameter
** settings. The minimum funding requirement is the greater of the three.
*]
 IF VALUE(OPENTYPE)>=0 THEN
  DO
   SHAREMINIMUMBALANCE=GETDATAMONEY(GETDEFAULTSHARE,VALUE(OPENTYPE),31) [Min. balance]
   SHAREMINIMUMDEPOSIT=GETDATAMONEY(GETDEFAULTSHARE,VALUE(OPENTYPE),35) [Min. deposit]

   IF SACFUNDCALCAMT<SHAREMINIMUMBALANCE THEN
    SACFUNDCALCAMT=SHAREMINIMUMBALANCE

   IF SACFUNDCALCAMT<SHAREMINIMUMDEPOSIT THEN
    SACFUNDCALCAMT=SHAREMINIMUMDEPOSIT

   IF SACFUNDCALCAMT<SACFUNDMINAMT THEN
    SACFUNDCALCAMT=SACFUNDMINAMT
  END
END [PROCEDURE GET MINIMUM DEPOSIT]

PROCEDURE PRINTMINFUNDAMT
 TMPCHR=FORMAT("######9.99",MINFUNDAMT)
 CALL NLS
 PRINT Q+"minimumFundingAmount"+Q+": "+Q
 PRINT TMPCHR
 PRINT Q
END [PROCEDURE PRINT MIN FUND AMT]


PROCEDURE PROVIDENAMESINFO
[* Provide name configurations
*]
 [GET THE NAME OPTIONS FOR NEW NAME]

 PRINT "    "+Q+"nameTypes"+Q+": ["
 NEWLINE
 FOR I=1 TO 54  [ HIGHEST NAME TYPE - not including prime(0) ]
  DO
   IF NAMETYPEUSED(I)=TRUE AND
      NAMETYPEDESC(I)<>"" THEN
    DO
     NAMECOUNT=NAMECOUNT+1
     IF NAMECOUNT>1 THEN
      DO
       PRINT ","
       NEWLINE
      END
     PRINT "      "+"{"+Q+"label"+Q+": "+Q+NAMETYPEDESC(I)+Q+", "+Q+"code"+Q+": "+Q+FORMAT("99",I)+Q+"}"
    END
  END
 PRINT "],"
 NEWLINE
 PRINT "    "+Q+"existingNames"+Q+": ["


 [LIST OF EXISTING ACCOUNT LEVEL NAMES]
 NAMECOUNT=0
 LELISTINPUT=DISPLAYEXISTINGNAMETYPES
 CALL LISTEXPAND

 FOR EACH NAME WITH ((NAME:EXPIRATIONDATE=DATENULL OR
                      NAME:EXPIRATIONDATE>SYSTEMDATE) AND
                      LELIST(NAME:TYPE)=TRUE AND
                      NAME:SSN<>PRIMARYSSN)
  DO
   NAMECOUNT=NAMECOUNT+1
   IF NAMECOUNT>1 THEN
    DO
     PRINT ","
     NEWLINE
    END
   PRINT "     {"
   NEWLINE
   PRINT "       "+Q+"name"+Q+": "+Q+NAME:LONGNAME+Q+","
   NEWLINE
   PRINT "       "+Q+"type"+Q+": "+Q+NAMETYPEDESC(NAME:TYPE)+Q
   NEWLINE
   PRINT "      }"
  END
 NEWLINE
 PRINT "    ]"
 NEWLINE
END [PROCEDURE]

PROCEDURE CHECKSHAREIDS
[* Loop through the share groups and then through the share types. For
** each share type, get the valid ID range.  Convert the ID range to a
** boolean array.  Loop through the array and for each valid ID, go to
** the account to see if the ID is available.  If no IDs are available
** for the specific share type then delete that option from the list of
** available options for the member to select from.  Finally, loop
** through the groups and if there are no valid share types for that
** group then remove the group itself.
*]
 FOR I=0 TO SACSHAREGROUPSMAX [Hard-coded to 10 in DEF]
  DO
   IF SACSHAREGROUPNAMES(I)<>"" THEN
    DO
     FOR J=0 TO SACSHARETYPESMAX [Hard-coded to 100 in DEF]
      DO
       IF SACSHARETYPES(I,J)<>"" THEN
        DO

[* Determine the min requirement for share opening deposit
** if member does not have enough funds avail for min
** share opening deposit, then clear share type, else run
** next section to test for valid IDs
*]

         TMPTYPE=VALUE(SEGMENT(SACSHARETYPES(I,J),1,4))
         TMPMONEY=$0.00
         TMPMINBAL=GETDATAMONEY(GETDEFAULTSHARE,TMPTYPE,31) [Min. balance]
         TMPMINDEPOSIT=GETDATAMONEY(GETDEFAULTSHARE,TMPTYPE,35) [Min. deposit]

         IF VALUE(SACFUNDREQUIREFLAG)>0 THEN
          DO
           TMPMONEY=SACFUNDMINAMT
           IF TMPMINBAL>TMPMONEY THEN
            TMPMONEY=TMPMINBAL
           IF TMPMINDEPOSIT>TMPMONEY THEN
            TMPMONEY=TMPMINDEPOSIT
          END
         ELSE
          DO
           TMPMONEY=TMPMINBAL
           IF TMPMINDEPOSIT>TMPMONEY THEN
            TMPMONEY=TMPMINDEPOSIT
          END
         SACSHAREFUNDMINAMT(I,J)=TMPMONEY 

         IF MEMBERMAXAVAILABLE<TMPMONEY THEN
          DO
           SACSHARETYPES(I,J)=""
          END
         ELSE
          DO
           SHAREIDAVAILABLE=FALSE

           COLONPOS=CHARACTERSEARCH(SACSHARETYPES(I,J),":")
           TMPCHR=SEGMENT(SACSHARETYPES(I,J),COLONPOS+1,LENGTH(SACSHARETYPES(I,J)))
           COLONPOS=CHARACTERSEARCH(TMPCHR,":")
           IF COLONPOS=0 THEN
            IDRANGECHR=TMPCHR
           ELSE
            IDRANGECHR=SEGMENT(TMPCHR,1,COLONPOS-1)

           LELISTINPUT=IDRANGECHR
           CALL LISTEXPAND
           FOR TMPLOOP=0 TO IDVALUEMAX
            DO
             TESTLOOP(TMPLOOP)=LELIST(TMPLOOP)
             IF TESTLOOP(TMPLOOP)=TRUE THEN
              DO
               TMPSID=SEGMENT(FORMAT("9999",TMPLOOP),4-(IDLENGTH-1),4)
               SHAREIDFOUND=FALSE
               FOR ACCOUNT ACCOUNT:NUMBER
                DO
                 FOR EACH SHARE WITH(SHARE:ID=TMPSID)
                  DO
                   SHAREIDFOUND=TRUE
                  END
                END
               IF SHAREIDFOUND=FALSE THEN
                DO
                 SHAREIDAVAILABLE=TRUE
                 TMPLOOP=IDVALUEMAX
                END
              END
            END
           IF SHAREIDAVAILABLE=FALSE THEN
            DO
             SACSHARETYPES(I,J)=""
            END
          END
        END  [IF SACSHARETYPES(I,J)<>"" THEN...]
      END  [OF J]
    END
  END

 FOR I=0 TO SACSHAREGROUPSMAX
  DO
   IF SACSHAREGROUPNAMES(I)<>"" THEN
    DO
     SHARETYPEFOUND=FALSE
     FOR J=0 TO SACSHARETYPESMAX
      DO
       IF SACSHARETYPES(I,J)<>"" THEN
        DO
         SHARETYPEFOUND=TRUE
         J=SACSHARETYPESMAX
        END
      END
     IF SHARETYPEFOUND=FALSE THEN
      DO
       SACSHAREGROUPNAMES(I)=""
      END
    END
  END

 SHARETYPEFOUND=FALSE
 FOR I=0 TO SACSHAREGROUPSMAX
  DO
   IF SACSHAREGROUPNAMES(I)<>"" THEN
    DO
     SHARETYPEFOUND=TRUE
     I=SACSHAREGROUPSMAX
    END
  END

END [PROCEDURE CHECK SHARE IDS]

PROCEDURE CHECKMAXSHARES

 MAXSHARES=0
 FOR I=0 TO SACSHAREGROUPSMAX
  DO
   IF SACSHAREGROUPNAMES(I)<>"" THEN
    DO
     FOR J=0 TO SACSHARETYPESMAX
      DO
       IF SACSHARETYPES(I,J)<>"" THEN
        DO
         TMPTYPE=VALUE(SEGMENT(SACSHARETYPES(I,J),1,4))
         IF TMPTYPE=VALUE(OPENTYPE) THEN 
          DO
           TMPCHR=SEGMENT(SACSHARETYPES(I,J),6,LENGTH(SACSHARETYPES(I,J)))
           COLONPOS=CHARACTERSEARCH(TMPCHR,":")
           IF COLONPOS=0 THEN
            MAXSHARES=0
           ELSE
            DO
             MAXSHARESCHR=SEGMENT(TMPCHR,COLONPOS+1,LENGTH(TMPCHR))
             MAXSHARES=VALUE(MAXSHARESCHR)
            END
          END  
        END
      END
    END
  END

 IF MAXSHARES<>0 THEN
  DO
   SHARECOUNT=0
   FOR EACH SHARE WITH (SHARE:CLOSEDATE='--/--/--' AND
                        SHARE:CHARGEOFFDATE='--/--/--' AND
                        SHARE:TYPE=VALUE(OPENTYPE))
    DO
     SHARECOUNT=SHARECOUNT+1
    END
   UNTIL SHARECOUNT=MAXSHARES 
  
   IF SHARECOUNT>=MAXSHARES THEN
    ERRORCODE=512
  END       
END

PROCEDURE SHAREOUTPUT
 [THIS SENDS SHARE INFORMATION IN JSON TO BANNO]

 WHILELIMIT=100000
 FOR I=0 TO SACSHARETYPEEXISTSMAX
  DO
   SACSHARETYPEEXISTS(I)=FALSE
  END

 [in defaults, is this share type available]
 FOR I=0 TO SACSHAREGROUPSMAX
  DO
   FOR J=0 TO SACSHARETYPESMAX
    DO
     IF SACSHARETYPES(I,J)<>"" THEN
      DO
       SACSHARETYPES(I,J)=SEGMENT(SACSHARETYPES(I,J),1,4)
       TEMPTYPE=SACSHARETYPES(I,J)
       IF SEGMENT(GETDATACHAR(GETDEFAULTSHARE,VALUE(TEMPTYPE),55),1,10)<>"Share Type" THEN
        DO
         SACSHARETYPEEXISTS(J)=TRUE
        END
       ELSE
        SACSHARETYPES(I,J)=""
      END
     IF SACSHARETYPES(I,J)<>"" THEN
      SACSHAREGROUPEXISTS(I)=TRUE
    END  [FOR J - TYPES]
  END  [FOR I - GROUPS]

   [GROUP START]
   PRINT "    "+Q+"categories"+Q+": ["

 FOR I=0 TO SACSHAREGROUPSMAX
  DO
   IF SACSHAREGROUPEXISTS(I)=TRUE THEN
    DO

     IF SHAREGROUPPRINTED=TRUE THEN
      DO
       IF I>0 THEN
        PRINT ","
       NEWLINE
      END
     SHAREGROUPPRINTED=TRUE
     SHARETYPEPRINTED=FALSE
     PRINT "      {"
     NEWLINE
     PRINT "        "+Q+"name"+Q+": "+Q+SACSHAREGROUPNAMES(I)+Q+","
     NEWLINE
     PRINT "        "+Q+"groupNumber"+Q+": "+Q
     PRINT I
     PRINT Q+","
     NEWLINE
     PRINT "        "+Q+"accountTypes"+Q+":["

     FOR J=0 TO SACSHARETYPESMAX
      DO

       IF SACSHARETYPEEXISTS(J)=TRUE AND
          SACSHARETYPES(I,J)<>"" THEN
        DO
         IF J>0 THEN
          DO
           IF SACSHARETYPEEXISTS(J-1)=TRUE THEN
            DO
             IF SHARETYPEPRINTED=TRUE THEN
              DO
               PRINT ","
              END
            END
          END

         NEWLINE
         PRINT "          {"                            [new share type]
         NEWLINE
         SHARETYPEPRINTED=TRUE
         [SHARE TYPE NUMBER]
         PRINT "            "+Q+"shareType"+Q+": "+Q
         PRINT FORMAT("9999",VALUE(SACSHARETYPES(I,J)))
         PRINT Q+","
         NEWLINE

         [SHARE DESCRIPTION]
         PRINT "            "+Q+"name"+Q+": "+Q+GETDATACHAR(GETDEFAULTSHARE,VALUE(SACSHARETYPES(I,J)),55)+Q+","
         NEWLINE

         [SHARE TERM - FOR SHARECODES 2 OR 3]
         TMPSHARECODE=GETDATANUMBER(GETDEFAULTSHARE,VALUE(SACSHARETYPES(I,J)),11)
         TMPCHR=FORMAT("###9",GETDATANUMBER(GETDEFAULTSHARE,VALUE(SACSHARETYPES(I,J)),53))
         CALL NLTS
         TMPTERMPERIODCHR=TMPCHR

         IF TMPSHARECODE=2 OR
            TMPSHARECODE=3 THEN
          DO
           PRINT "            "+Q+"term"+Q+": "+Q
           PRINT TMPTERMPERIODCHR
           PRINT " "
           PRINT SHARETERMFREQCHR(GETDATANUMBER(GETDEFAULTSHARE,VALUE(SACSHARETYPES(I,J)),52)) [Freq- 0,1]
           IF VALUE(TMPTERMPERIODCHR)>1 THEN
            PRINT "s"
           PRINT Q+","
           NEWLINE
          END

         [MINIMUM BALANCE]
         SHAREMINIMUMBALANCE=GETDATAMONEY(GETDEFAULTSHARE,VALUE(SACSHARETYPES(I,J)),31)
         PRINT"            "+Q+"minBalance"+Q+": "+Q
         TMPCHR=FORMAT("######9.99",SHAREMINIMUMBALANCE)
         CALL NLS
         PRINT TMPCHR
         PRINT Q+","
         NEWLINE

         MINFUNDAMT=SACSHAREFUNDMINAMT(I,J)
         CALL PRINTMINFUNDAMT
         IF SACDISPLAYRATEFLAG="1" THEN
          PRINT ","
         NEWLINE

         [RATES]
         IF SACDISPLAYRATEFLAG="1" THEN
          DO
           CALL GETSHARERATE
           NEWLINE
          END
        [END A SHARE TYPE]
         PRINT "          }"
        END

      END [FOR J SHARE TYPES]

      [END OF ALL SHARE TYPES IN THAT GROUP]
      PRINT "        ]"
      NEWLINE

      [CLOSE GROUP]
      PRINT "      }"
    END
  END [FOR I - GROUPS]
 NEWLINE
END [PROCEDURE]

PROCEDURE GETSHARERATE
 DIVDEFBALCUTOFF=$0.00
 DIVDEFPREVBALCUTOFF=$0.00
 RATEPRINTED=FALSE

 [GET RATE AND DIV TYPE FROM DEFAULT MANAGER]
 SACTYPEDIVTYPE=GETDATANUMBER(GETDEFAULTSHARE,VALUE(SACSHARETYPES(I,J)),19)
 SACTYPEDIVRATE=GETDATARATE(GETDEFAULTSHARE,VALUE(SACSHARETYPES(I,J)),20)

 [ IS DIVTYPE NOT DEFINED ]
 IF GETDATANUMBER(GETPARAMDIVDEFDEFINEDCODE,SACTYPEDIVTYPE)<>1 THEN
  DO
   PRINT "INVALID DIV TYPE"                         [JSON - TEK?]
   NEWLINE
  END

 [GET INFO FROM DIVIDEND TYPE PARAMETERS]
 IF GETDATANUMBER(GETPARAMDIVDEFDEFINEDCODE,SACTYPEDIVTYPE)=1 THEN        [DEFINED]
  DO
   [GET RATE SELECT TYPE]
   DIVDEFRATESELECT=GETDATANUMBER(GETPARAMDIVDEFRATESELECT,SACTYPEDIVTYPE)

   [GET FILLIN METHOD]
   DIVDEFFILLINMETHOD=GETDATANUMBER(GETPARAMDIVDEFFILLINRATESELECT,SACTYPEDIVTYPE)

   [GET INDEX OPTION]
   DIVDEFINDEXOPTION=GETDATANUMBER (GETPARAMDIVDEFDIVINDEXOPT,SACTYPEDIVTYPE)

   FOR RATEDATALOOP=0 TO RATEDATAMAX
    DO
     RATEDATARATE(RATEDATALOOP)=0.000%
     RATEDATAMINBAL(RATEDATALOOP)=$0.00
     RATEDATAMAXBAL(RATEDATALOOP)=$0.00
    END
   RATEDATAUSED=0


   IF DIVDEFINDEXOPTION=0 AND
      ((DIVDEFRATESELECT=1 AND
       DIVDEFFILLINMETHOD=1) OR
      (DIVDEFRATESELECT=0 OR
       DIVDEFRATESELECT=2 OR
       DIVDEFRATESELECT=3 OR
       DIVDEFRATESELECT=4 OR
       DIVDEFRATESELECT=5 OR
       DIVDEFRATESELECT=6 OR
       DIVDEFRATESELECT=7 OR
       DIVDEFRATESELECT=8 OR
       DIVDEFRATESELECT=9)) THEN
    DO
     DR=1
     DONE=FALSE

     WHILE DR<10 AND DONE=FALSE
      DO
       DIVDEFRATE=GETDATARATE(GETPARAMDIVDEFRATE,SACTYPEDIVTYPE,DR)           [GET RATE]
       DIVDEFBALCUTOFF=GETDATAMONEY(GETPARAMDIVDEFBALCUTOFF,SACTYPEDIVTYPE,DR)[GET BAL CUTOFF]

       IF DR=1 AND
          DIVDEFRATE=0.000% AND
          DIVDEFBALCUTOFF>$0.00 THEN
        DO
         IF DR<=RATEDATAMAX THEN
          DO
           RATEDATARATE(DR)=0.000%
           RATEDATAMINBAL(DR)=$0.00
           RATEDATAMAXBAL(DR)=DIVDEFBALCUTOFF-$0.01
           IF DR>=RATEDATAUSED THEN
            RATEDATAUSED=DR
          END
         DIVDEFPREVBALCUTOFF=DIVDEFBALCUTOFF
        END

       IF DIVDEFRATE>0.000% AND
          DIVDEFBALCUTOFF>$0.00 THEN
        DO
         IF DR<=RATEDATAMAX THEN
          DO
           RATEDATARATE(DR)=DIVDEFRATE
           RATEDATAMINBAL(DR)=DIVDEFPREVBALCUTOFF
           RATEDATAMAXBAL(DR)=DIVDEFBALCUTOFF-$0.01
           IF DR>=RATEDATAUSED THEN
            RATEDATAUSED=DR
          END
         DIVDEFPREVBALCUTOFF=DIVDEFBALCUTOFF
        END

       IF DIVDEFRATE>0.000% AND
          DIVDEFBALCUTOFF=$0.00 THEN
        DO
         IF DR<=RATEDATAMAX THEN
          DO
           RATEDATARATE(DR)=DIVDEFRATE
           RATEDATAMINBAL(DR)=DIVDEFPREVBALCUTOFF
           RATEDATAMAXBAL(DR)=-$0.01
           IF DR>=RATEDATAUSED THEN
            RATEDATAUSED=DR
          END

         DONE=TRUE
        END
       DR=DR+1
      END

     FOR RATEDATALOOP=1 TO RATEDATAUSED
      DO
       IF RATEDATALOOP=1 THEN
        DO
         RATEPRINTED=TRUE
         PRINT "            "+Q+"interestRates"+Q+":[ "
         NEWLINE
        END

       PRINT "         {"
       NEWLINE
       PRINT "           "+Q+"rate"+Q+": "+Q
       TMPCHR=FORMAT("###9.999",RATEDATARATE(RATEDATALOOP))
       CALL NLS
       PRINT TMPCHR
       PRINT Q+","
       NEWLINE
       PRINT "           "+Q+"minBalance"+Q+": "+Q
       TMPCHR=FORMAT("######9.99",RATEDATAMINBAL(RATEDATALOOP))
       CALL NLS
       PRINT TMPCHR
       PRINT Q+","
       NEWLINE
       PRINT "           "+Q+"maxBalance"+Q+": "+Q
       IF RATEDATAMAXBAL(RATEDATALOOP)>=$0.00 THEN
        DO
         TMPCHR=FORMAT("######9.99",RATEDATAMAXBAL(RATEDATALOOP))
         CALL NLS
         PRINT TMPCHR
        END
       PRINT Q
       NEWLINE
       PRINT "         }"
       IF RATEDATALOOP<RATEDATAUSED THEN
        DO
         PRINT ","
         NEWLINE
        END
       ELSE
        DO
         NEWLINE
         PRINT "]"
        END
      END
    END [IF DIVDEFINDEXOPTION=0 AND...]

   [FILL IN FROM SHARE DEFAULTS]
   IF (DIVDEFRATESELECT=1 AND
       DIVDEFFILLINMETHOD=0) OR
       RATEPRINTED=FALSE THEN
    DO
     RATEPRINTED=TRUE
     PRINT "            "+Q+"interestRates"+Q+": [{"+Q+"rate"+Q+":"+Q
     TMPCHR=FORMAT("###9.999",SACTYPEDIVRATE)
     CALL NLS
     PRINT TMPCHR
     PRINT Q+"}]"
     NEWLINE
    END
  END

END [PROCEDURE GET RATE]

PROCEDURE GETSHARETRANSFERS
[* This procedure can be run with or without output. Setting the
** GETSHARETRANSFERRUN to TRANSFERRUNFINAL will print the necessary
** JSON output, else, the procedure will simply count the valid
** transfer shares found
*]
 XFERSHARECOUNT=0
 MEMBERMAXAVAILABLE=$0.00
 FOR EACH SHARE WITH (SHARE:CLOSEDATE='--/--/--' AND
                      SHARE:CHARGEOFFDATE='--/--/--' AND
                      SHARE:AVAILABLEBALANCE>$0.00)
  DO
   CALL BUILDSERVICEARRAY
   CALL CHECKSHARETRANSFEROUT
   IF TEMPMSG<>"" THEN
    DO
     XFERSHARECOUNT=XFERSHARECOUNT+1

     IF SHARE:AVAILABLEBALANCE>MEMBERMAXAVAILABLE THEN
      MEMBERMAXAVAILABLE=SHARE:AVAILABLEBALANCE

     IF GETSHARETRANSFERRUN=TRANSFERRUNFINAL THEN
      DO
       IF XFERSHARECOUNT=1 THEN
        DO
         PRINT ","
         NEWLINE
         PRINT "    "+Q+"electronicFundingAccounts"+Q+": ["
         NEWLINE
        END
       ELSE IF XFERSHARECOUNT>1 THEN
        DO
         PRINT ","
         NEWLINE
        END
       PRINT "    {"
       NEWLINE
       TMPCHR=TMPSHARENAME
       CALL NLTS
       CALL CLEANUPTEXT

       PRINT "      "+Q+"name"+Q+":"+Q+TMPCHR+Q+","
       NEWLINE
       PRINT "      "+Q+"availableBalance"+Q+": "+Q
       TMPCHR=FORMAT("######9.99",TMPSHAREAVAIL)
       CALL NLS
       PRINT TMPCHR
       PRINT Q+","
       NEWLINE
       PRINT "      "+Q+"memberAccountNumber"+Q+":"+Q+TMPSHAREID+Q
       
       NEWLINE
       PRINT "    }"
      END
    END
  END

 IF GETSHARETRANSFERRUN=TRANSFERRUNFINAL THEN
  DO
   IF XFERSHARECOUNT>0 THEN
    DO
     NEWLINE
     PRINT "    ]"
    END
   NEWLINE
   
  END
END [PROCEDURE GET SHARE XFRS]

PROCEDURE BUILDSERVICEARRAY
 FOR I=1 TO 99
  DO
   SERVICEOUT(I)=FALSE
  END

 LELISTINPUT=GETDATACHARACTER(GETPARAMSYMXCHCLSERVICESXOUT,SYMXINSTANCE,SYMXCLIENTNUM)
 CALL LISTEXPAND
 FOR I=1 TO 99
  DO
   SERVICEOUT(I)=LELIST(I)
  END
END [PROCEDURE BUILD SERVICE ARRAY]

PROCEDURE CHECKSHARETRANSFEROUT
 TEMPMSG=""

 IF (SERVICEOUT(SHARE:SERVICE:1)=TRUE OR
     SERVICEOUT(SHARE:SERVICE:2)=TRUE OR
     SERVICEOUT(SHARE:SERVICE:3)=TRUE OR
     SERVICEOUT(SHARE:SERVICE:4)=TRUE OR
     SERVICEOUT(SHARE:SERVICE:5)=TRUE OR
     SERVICEOUT(SHARE:SERVICE:6)=TRUE OR
     SERVICEOUT(SHARE:SERVICE:7)=TRUE OR
     SERVICEOUT(SHARE:SERVICE:8)=TRUE) THEN
  DO
   TEMPMSG=ACCOUNT:NUMBER

   [PAD SHARE ID TO 4]
   TMPCHR=SHARE:ID
   WHILE LENGTH(TMPCHR)<4
    DO
     TMPCHR=" "+TMPCHR
    END
   IF LENGTH(TMPCHR)=4 THEN
    DO
     TEMPMSG=TEMPMSG+"S"+TMPCHR
     TMPSHAREID=TEMPMSG
    END

   [ADD avail balance]
   TEMPMSG=TEMPMSG+"|"+FORMAT("$###########9.99+",SHARE:AVAILABLEBALANCE)+"|"
   TMPSHAREAVAIL=SHARE:AVAILABLEBALANCE
   [ENSURING THE LENGTH OF THE DESCRIPTION PADS OUT TO 30 & NO INVALID SPECIAL CHARS]
   TMPCHR=""
   IF SHARE:NICKNAME<>"" AND
      CHARACTERSEARCH(SHARE:NICKNAME,PIPE)=0 AND
      CHARACTERSEARCH(SHARE:NICKNAME,TILDE)=0 AND
      CHARACTERSEARCH(SHARE:NICKNAME,AMPERSAND)=0 AND
      CHARACTERSEARCH(SHARE:NICKNAME,GREATERTHAN)=0 AND
      CHARACTERSEARCH(SHARE:NICKNAME,LESSTHAN)=0 THEN

    DO
     TMPCHR=SHARE:NICKNAME
     WHILE LENGTH(TMPCHR)<30
      DO
       TMPCHR=" "+TMPCHR
      END
     IF LENGTH(TMPCHR)=30 THEN
      DO
       TEMPMSG=TEMPMSG+TMPCHR
       TMPSHARENAME=TMPCHR
      END
    END

   ELSE IF SHARE:NICKNAME="" AND
           CHARACTERSEARCH(SEGMENT(SHARE:DESCRIPTION,1,30),PIPE)=0 AND
           CHARACTERSEARCH(SEGMENT(SHARE:DESCRIPTION,1,30),TILDE)=0  AND
           CHARACTERSEARCH(SEGMENT(SHARE:DESCRIPTION,1,30),AMPERSAND)=0 AND
           CHARACTERSEARCH(SEGMENT(SHARE:DESCRIPTION,1,30),GREATERTHAN)=0 AND
           CHARACTERSEARCH(SEGMENT(SHARE:DESCRIPTION,1,30),LESSTHAN)=0  THEN
    DO
     TMPCHR=SEGMENT(SHARE:DESCRIPTION,1,30)
     WHILE LENGTH(TMPCHR)<30
      DO
       TMPCHR=" "+TMPCHR
      END
     IF LENGTH(TMPCHR)=30 THEN
      DO
       TEMPMSG=TEMPMSG+TMPCHR
       TMPSHARENAME=TMPCHR
      END
    END
  END
END   [PROCEDURE CALL CHECKSHARETRANSFERINOUT]

PROCEDURE GETPASSEDINFO
 IMPORT(1)=@RGUSERCHR1           [TRANSFER INFO & NAME COPY LIST]
 IMPORT(2)=@RGUSERCHR2           [NEW NAME INFO 1]
 IMPORT(3)=@RGUSERCHR3           [NEW NAME INFO 1 CONT]
 IMPORT(4)=@RGUSERCHR4           [NEW NAME INFO 2]
 IMPORT(5)=@RGUSERCHR5           [NEW NAME INFO 2 CONT]

 COPYNAMESCHR=""

 [must have a share type]
 IF IMPORT(1)="" OR
    TESTERRORCODE=507 THEN
  DO
   PASSEDINFOREADERROR="MISSING INFORMATION"
   PRINT "{"
   NEWLINE
   CALL PRINTPROGRAMINFO
   ERRORCODE=507
   CALL ERRORHANDLER
  END

 [determine number of names]
 NEWNAMECOUNT=0
 IF IMPORT(4)<>"" THEN
  NEWNAMECOUNT=2
 ELSE IF IMPORT(2)<>"" THEN
  NEWNAMECOUNT=1

 FOR J=1 TO 5
  DO
[*TEK - v 1.1.0: added check for caret delimiter. If present, character string
** after caret represents semi-colon delimited list of name locators of name records
** to be copied under the new share
*]
   IF J=1 THEN [get data from the @RGUSERCHR1 field]
    DO
     POS=CHARACTERSEARCH(IMPORT(J),"^") [The data after the caret are the names to copy]
     IF POS>0 THEN
      DO
       IF LENGTH(IMPORT(J))>POS THEN
        DO
         COPYNAMESCHR=SEGMENT(IMPORT(J),POS+1,LENGTH(IMPORT(J)))
         BNODATALINEINPUT=COPYNAMESCHR
         BNODELIMITER=BNODELIMSEMICOLON
         CALL PARSEDATALINE
         IF BNODATAFIELDCOUNT>0 THEN
          DO
           NAMESTOCOPYCOUNT=BNODATAFIELDCOUNT
           FOR TMPLOOP=1 TO NAMESTOCOPYCOUNT
            DO
             NAMESTOCOPYLOC(TMPLOOP)=VALUE(BNODATALINEFIELD(TMPLOOP))
            END
          END
        END
       IMPORT(J)=SEGMENT(IMPORT(J),1,POS-1)
      END
    END [IF J=1]

   IF J=1 THEN
    DO
     NEWSHARETYPE=""
     TRANSFERFROMID=""
     TRANSFERAMOUNT=$0.00
     FEEFROMID=""
 
     BNODATALINEINPUT=IMPORT(J)
     BNODELIMITER=BNODELIMSEMICOLON
     CALL PARSEDATALINE
     IF BNODATAFIELDCOUNT>=1 THEN
      NEWSHARETYPE=BNODATALINEFIELD(1)
     IF BNODATAFIELDCOUNT>=2 THEN
      DO
       TRANSFERFROMID=BNODATALINEFIELD(2)
       TRANSFERFROMID=FORMAT("9999",VALUE(TRANSFERFROMID))
      END
     IF BNODATAFIELDCOUNT>=3 THEN
      TRANSFERAMOUNT=MONEY(VALUE(BNODATALINEFIELD(3)))
     IF BNODATAFIELDCOUNT>=4 THEN
      DO
       FEEFROMID=BNODATALINEFIELD(4)
       FEEFROMID=FORMAT("9999",VALUE(FEEFROMID))
       FEEFROMID=SEGMENT(FEEFROMID,4-(IDLENGTH-1),4)
      END
    END

   IF (J=2 OR
       J=4) AND
       NEWNAMECOUNT>0 THEN
    DO
     IF J=2 THEN NUM=1
     IF J=4 THEN NUM=2
     POS=0
     POS=CHARACTERSEARCH(IMPORT(J),";")
     NEWNAMETYPE(NUM)=VALUE(SEGMENT(IMPORT(J),1,POS-1))
     IMPORT(J)=SEGMENT(IMPORT(J),POS+1,LENGTH(IMPORT(J)))

     POS=CHARACTERSEARCH(IMPORT(J),";")
     NEWNAMEFIRST(NUM)=UPPERCASE(SEGMENT(IMPORT(J),1,POS-1))
     IMPORT(J)=SEGMENT(IMPORT(J),POS+1,LENGTH(IMPORT(J)))

     POS=CHARACTERSEARCH(IMPORT(J),";")
     NEWNAMEMIDDLE(NUM)=UPPERCASE(SEGMENT(IMPORT(J),1,POS-1))
     IMPORT(J)=SEGMENT(IMPORT(J),POS+1,LENGTH(IMPORT(J)))

     POS=CHARACTERSEARCH(IMPORT(J),";")
     NEWNAMELAST(NUM)=UPPERCASE(SEGMENT(IMPORT(J),1,POS-1))
     IMPORT(J)=SEGMENT(IMPORT(J),POS+1,LENGTH(IMPORT(J)))

     POS=CHARACTERSEARCH(IMPORT(J),";")
     NEWNAMESUFFIX(NUM)=UPPERCASE(SEGMENT(IMPORT(J),1,POS-1))
     IMPORT(J)=SEGMENT(IMPORT(J),POS+1,LENGTH(IMPORT(J)))

     POS=CHARACTERSEARCH(IMPORT(J),";")
     NEWNAMESSN(NUM)=SEGMENT(IMPORT(J),1,POS-1)
     IMPORT(J)=SEGMENT(IMPORT(J),POS+1,LENGTH(IMPORT(J)))

     NEWNAMEEMAIL(NUM)=UPPERCASE(IMPORT(J))
    END

   IF (J=3 OR
       J=5) AND
       NEWNAMECOUNT>0 THEN
    DO
     IF J=3 THEN NUM=1
     IF J=5 THEN NUM=2
     POS=0
     POS=CHARACTERSEARCH(IMPORT(J),";")
     NEWNAMESTREET(NUM)=UPPERCASE(SEGMENT(IMPORT(J),1,POS-1))
     IMPORT(J)=SEGMENT(IMPORT(J),POS+1,LENGTH(IMPORT(J)))

     POS=CHARACTERSEARCH(IMPORT(J),";")
     NEWNAMEEXTRA(NUM)=UPPERCASE(SEGMENT(IMPORT(J),1,POS-1))
     IMPORT(J)=SEGMENT(IMPORT(J),POS+1,LENGTH(IMPORT(J)))

     POS=CHARACTERSEARCH(IMPORT(J),";")
     NEWNAMECITY(NUM)=UPPERCASE(SEGMENT(IMPORT(J),1,POS-1))
     IMPORT(J)=SEGMENT(IMPORT(J),POS+1,LENGTH(IMPORT(J)))

     POS=CHARACTERSEARCH(IMPORT(J),";")
     NEWNAMESTATE(NUM)=UPPERCASE(SEGMENT(IMPORT(J),1,POS-1))
     IMPORT(J)=SEGMENT(IMPORT(J),POS+1,LENGTH(IMPORT(J)))

     POS=CHARACTERSEARCH(IMPORT(J),";")
     NEWNAMEZIP(NUM)=SEGMENT(IMPORT(J),1,POS-1)
     IMPORT(J)=SEGMENT(IMPORT(J),POS+1,LENGTH(IMPORT(J)))

     POS=CHARACTERSEARCH(IMPORT(J),";")
     NEWNAMEDOB(NUM)=DATEVALUE(SEGMENT(IMPORT(J),1,POS-1))
     IMPORT(J)=SEGMENT(IMPORT(J),POS+1,LENGTH(IMPORT(J)))

     POS=CHARACTERSEARCH(IMPORT(J),";")
     NEWNAMEPHONETYPE(NUM)=VALUE(SEGMENT(IMPORT(J),1,POS-1))
     IMPORT(J)=SEGMENT(IMPORT(J),POS+1,LENGTH(IMPORT(J)))

     NEWNAMEPHONE(NUM)=IMPORT(J)

     IF PASSEDINFOREADERROR="" THEN
      DO
       [city + state + zip code must 40 characters or less]
       LEN=LENGTH(NEWNAMECITY(NUM)+NEWNAMESTATE(NUM)+NEWNAMEZIP(NUM))
       IF LEN>40 THEN
        DO

         PASSEDINFOREADERROR="MISSING INFORMATION"
         PRINT "{"
         NEWLINE
         CALL PRINTPROGRAMINFO
         ERRORCODE=507
         CALL ERRORHANDLER
         CALL JSONCLOSE

        END
      END
    END
  END [END OF J]
END [PROCEDURE GET PASSED INFO]


PROCEDURE GETNEXTID
[* Get the next ID available for the selected share type which falls
** in the allowable share ID range.
**   RETURN: NEXTID - The ID to use for the selected share type or
**                    blank if none available.
*]

 NEXTID=""
 NEWSHAREID=""
 CALL LOADEXISTINGSHAREIDS

[Load ID range into array for selected type]
 TYPEFOUND=FALSE
 FOR I=0 TO SACSHAREGROUPSMAX
  DO
   FOR J=0 TO SACSHARETYPESMAX
    DO
     IF SACSHARETYPES(I,J)<>"" THEN
      DO
       IF SEGMENT(SACSHARETYPES(I,J),1,4)<>"" AND
          SEGMENT(SACSHARETYPES(I,J),1,4)=NEWSHARETYPE THEN
        DO
         TYPEFOUND=TRUE

         TMPCHR=SEGMENT(SACSHARETYPES(I,J),6,LENGTH(SACSHARETYPES(I,J)))
         COLONPOS=CHARACTERSEARCH(TMPCHR,":")
         IF COLONPOS=0 THEN
          SFSEARCHLIST=TMPCHR
         ELSE
          SFSEARCHLIST=SEGMENT(TMPCHR,1,COLONPOS-1)

         IF SFSEARCHLIST="" THEN [Use next available ID]
          NEXTIDFLAG=TRUE
         ELSE
          CALL LOADFILETOARRAY
        END
      END
    END
  END

 IF TYPEFOUND=TRUE THEN                 [Find next available ID]
  DO
   IDSET=FALSE
   NEXTID=""
   I=0
   WHILELIMIT=100000
   WHILE I<=IDVALUEMAX AND
         IDSET=FALSE
    DO                                  [Get NEXTID Based on NEXTIDFLAG]
     IF NEXTIDFLAG=TRUE THEN            [TRUE = IGNORE RANGES DEFINED IN CUINFO]
      DO
       IF EXISTINGIDS(I,0)="" THEN
        DO
         IDSET=TRUE
         NEXTID=FORMAT(REPEATCHR("9",IDLENGTH),I)
         EXISTINGIDS(I,0)=NEXTID
        END
      END
     ELSE IF NEXTIDFLAG=FALSE THEN      [FALSE = use ranges defined in CUINFO]
      DO                                [ID is available, use it]
       IF IDRANGE(I)<>"" AND EXISTINGIDS(I,0)="" THEN
        DO
         IDSET=TRUE
         EXISTINGIDS(I,0)=IDRANGE(I)
         NEXTID=IDRANGE(I)
        END
      END
     I=I+1
    END
  END

 NEWSHAREID=NEXTID
 IF NEWSHAREID="" OR
    TESTERRORCODE=508 THEN
  DO
   NEWSHAREID=""
   PRINT "{"
   NEWLINE
   ERRORCODE=508
   CALL ERRORHANDLER
   NEWLINE
  END
END [PROCEDURE GET NEXT ID]

PROCEDURE LOADEXISTINGSHAREIDS
[* Create an array of existing share IDs]

 WHILELIMIT=100000

 FOR I=0 TO IDVALUEMAX
  DO
   EXISTINGIDS(I,0)=""
  END

 FOR EACH SHARE
  DO
   IF VALUE(SHARE:ID)<IDVALUEMAX THEN
    EXISTINGIDS(VALUE(SHARE:ID),0)=SHARE:ID
  END

END [PROCEDURE LOAD EXISTING SHARE IDS]

PROCEDURE GETNEWSHARERATE   [CMS FIXED AND TESTED]

 IF SACSETFILLINRATESFLAG="0" THEN
  DO
   RATEDONE=TRUE
  END
 IF SACSETFILLINRATESFLAG="1" THEN
  DO
   NEWSHARERATE=0.000%                   [ASSIGNED IN THIS PROCESS]

   NEWSHAREDIVDEFDEFINED=0
   NEWSHAREDIVDEFFILLINMETHOD=0
   NEWSHAREDIVDEFINDEXOPTION=0
   NEWSHAREDIVDEFRATESELECT=0

   [INFO FROM SHARE DEFAULTS]
   NEWSHAREDIVTYPE=GETDATANUMBER(GETDEFAULTSHARE,VALUE(NEWSHARETYPE),19)
   NEWSHAREDIVRATE=GETDATARATE(GETDEFAULTSHARE,VALUE(NEWSHARETYPE),20)
   NEWSHAREIRSCODE=GETDATANUMBER(GETDEFAULTSHARE,VALUE(NEWSHARETYPE),12)

   [INFO FROM SHARE DIV DEFINITIONS]
   NEWSHAREDIVDEFDEFINED=GETDATANUMBER(GETPARAMDIVDEFDEFINEDCODE,NEWSHAREDIVTYPE)
   NEWSHAREDIVDEFRATESELECT=GETDATANUMBER(GETPARAMDIVDEFRATESELECT,NEWSHAREDIVTYPE)
   NEWSHAREDIVDEFFILLINMETHOD=GETDATANUMBER(GETPARAMDIVDEFFILLINRATESELECT,NEWSHAREDIVTYPE)
   NEWSHAREDIVDEFINDEXOPTION=GETDATANUMBER(GETPARAMDIVDEFDIVINDEXOPT,NEWSHAREDIVTYPE)

   IF NEWSHAREDIVDEFDEFINED=0 THEN
    DO
     GETRATEERROR="INVALID DIV TYPE"     [ DIVTYPE IS NOT DEFINED ]
     NEWLINE
    END
   IF NEWSHAREDIVDEFDEFINED=1 THEN
    DO
     IF NEWSHAREDIVDEFRATESELECT>1 THEN   [NOT A FILL IN OR FIXED RATE]
      DO
       RATEDONE=TRUE
      END
     ELSE IF NEWSHAREDIVDEFRATESELECT=0 THEN   [FIXED FILL IN FROM DIV DEFINITIONS]
      DO
       NEWSHARERATE=GETDATARATE(GETPARAMDIVDEFRATE,NEWSHAREDIVTYPE,1)           [GET RATE FROM FIRST SLOT]
       RATEDONE=TRUE
      END
     ELSE IF NEWSHAREDIVDEFRATESELECT=1 AND   [FILL IN FROM SHARE DEFAULTS]
             NEWSHAREDIVDEFFILLINMETHOD=0 THEN
      DO
       NEWSHARERATE=NEWSHAREDIVRATE
       RATEDONE=TRUE
      END

     ELSE IF NEWSHAREDIVDEFRATESELECT=1 AND              [FILL IN FROM DIV DEFINITIONS]
             NEWSHAREDIVDEFFILLINMETHOD=1 AND
             NEWSHAREDIVDEFINDEXOPTION=0 THEN
      DO
       DR=1
       RATEDONE=FALSE
       NEWSHAREDIVDEFRATE          = 0.000%
       NEWSHAREDIVDEFBALCUTOFF     = $0.00
       NEWSHAREDIVDEFPREVBALCUTOFF = $0.00

       WHILE DR<=10 AND RATEDONE=FALSE
        DO
         NEWSHAREDIVDEFRATE=GETDATARATE(GETPARAMDIVDEFRATE,NEWSHAREDIVTYPE,DR)           [GET RATE]
         NEWSHAREDIVDEFBALCUTOFF=GETDATAMONEY(GETPARAMDIVDEFBALCUTOFF,NEWSHAREDIVTYPE,DR)[GET BAL CUTOFF]

         IF DR=1 THEN                                            [1st time ]
          DO
           IF NEWSHAREDIVDEFBALCUTOFF=$0.00 THEN                 [first cutoff is $0.00]
            DO
             NEWSHARERATE=NEWSHAREDIVDEFRATE
             RATEDONE=TRUE
            END
           ELSE IF TRANSFERAMOUNT<NEWSHAREDIVDEFBALCUTOFF THEN    [else orig.bal less than first cutoff]
            DO
             NEWSHARERATE=NEWSHAREDIVDEFRATE
             RATEDONE=TRUE
            END
           ELSE IF TRANSFERAMOUNT>=NEWSHAREDIVDEFBALCUTOFF THEN   [else establish low range]                                   
            DO
             NEWSHAREDIVDEFPREVBALCUTOFF=NEWSHAREDIVDEFBALCUTOFF
            END
          END

         IF DR>1 AND
            NEWSHAREDIVDEFRATE<>0.000% AND
            NEWSHAREDIVDEFBALCUTOFF>$0.00 THEN
          DO
           IF TRANSFERAMOUNT>=NEWSHAREDIVDEFPREVBALCUTOFF AND  [is xfr amount between last and now]
              TRANSFERAMOUNT<NEWSHAREDIVDEFBALCUTOFF THEN
            DO
             NEWSHARERATE=NEWSHAREDIVDEFRATE
             RATEDONE=TRUE               [r u sure]
            END
           ELSE
            NEWSHAREDIVDEFPREVBALCUTOFF=NEWSHAREDIVDEFBALCUTOFF
          END

         IF DR>1 AND                                      [is xfr amt above last rate]
            NEWSHAREDIVDEFRATE<>0.000% AND
            NEWSHAREDIVDEFBALCUTOFF=$0.00 THEN
          DO
           NEWSHARERATE=NEWSHAREDIVDEFRATE
           RATEDONE=TRUE
          END
         DR=DR+1
        END     [end of while]
      END  [FILL IN BASED ON BALANCE RANGE]
    END  [DEFINED RATE]
  END [SAC DISPLAY CHECK]
 IF RATEDONE=FALSE OR
    TESTERRORCODE=509 THEN
  DO
   RATEDONE=FALSE
   PRINT "{"
   NEWLINE
   CALL PRINTPROGRAMINFO
   ERRORCODE=509
   CALL ERRORHANDLER
   NEWLINE
  END
END [GET NEW SHARE RATE PROCEDURE]

PROCEDURE GETNEWMATURITYDATE
[*Determine the new maturity date
*]
 IF GETDATANUMBER(GETDEFAULTSHARE,VALUE(NEWSHARETYPE),11)<>2 OR              [NOT CLUB OR CD]
    GETDATANUMBER(GETDEFAULTSHARE,VALUE(NEWSHARETYPE),11)<>3 THEN
  DO
   MATUREDATEDONE=TRUE
  END

 IF GETDATANUMBER(GETDEFAULTSHARE,VALUE(NEWSHARETYPE),11)=2 THEN             [CERTIFICATE]
  DO
   NEWSHAREMATURITYDATE='--/--/--'
   IF GETDATANUMBER(GETDEFAULTSHARE,VALUE(NEWSHARETYPE),52)=1 THEN           [X DAYS]
    DO
     NEWSHAREMATURITYDATE=SYSTEMDATE+GETDATANUMBER(GETDEFAULTSHARE,VALUE(NEWSHARETYPE),53)
     MATUREDATEDONE=TRUE
    END
   ELSE IF GETDATANUMBER(GETDEFAULTSHARE,VALUE(NEWSHARETYPE),52)=0 THEN           [X MONTHS]
    DO
     NEWSHAREMATURITYDATE=DATEOFFSET(SYSTEMDATE,+GETDATANUMBER(GETDEFAULTSHARE,VALUE(NEWSHARETYPE),53),0)
     MATUREDATEDONE=TRUE
    END
  END

 IF GETDATANUMBER(GETDEFAULTSHARE,VALUE(NEWSHARETYPE),11)=3 THEN               [CLUB]
  DO
   NEWSHAREMATURITYDATE='--/--/--'
   IF GETDATADATE(GETDEFAULTSHARE,VALUE(NEWSHARETYPE),51)<>DATENULL AND
      GETDATADATE(GETDEFAULTSHARE,VALUE(NEWSHARETYPE),51)>SYSTEMDATE THEN
    DO
     NEWSHAREMATURITYDATE=GETDATADATE(GETDEFAULTSHARE,VALUE(NEWSHARETYPE),51)
     MATUREDATEDONE=TRUE
    END
   ELSE
    DO
     IF GETDATANUMBER(GETDEFAULTSHARE,VALUE(NEWSHARETYPE),52)=1 THEN           [X DAYS]
      DO
       NEWSHAREMATURITYDATE=SYSTEMDATE+GETDATANUMBER(GETDEFAULTSHARE,VALUE(NEWSHARETYPE),53)
       MATUREDATEDONE=TRUE
      END
     ELSE IF GETDATANUMBER(GETDEFAULTSHARE,VALUE(NEWSHARETYPE),52)=0 THEN           [X MONTHS]
      DO
       NEWSHAREMATURITYDATE=DATEOFFSET(SYSTEMDATE,+GETDATANUMBER(GETDEFAULTSHARE,VALUE(NEWSHARETYPE),53),0)
       MATUREDATEDONE=TRUE
      END
    END
  END
 IF MATUREDATEDONE=FALSE OR
    TESTERRORCODE=510 THEN
  DO
   MATUREDATEDONE=FALSE
   PRINT "{"
   NEWLINE
   CALL PRINTPROGRAMINFO
   ERRORCODE=510
   CALL ERRORHANDLER
   NEWLINE
  END
END  [GET NEW MATURITY DATE]

PROCEDURE CREATESHARE
[* Create new share
*]
 IF TESTERRORCODE=511 THEN
  SHAREERRORMESSAGE="Test Share Creation Error"
 ELSE IF ERRORCODE=0 THEN
  DO
   FMPERFORM CREATE SHARE NEWSHAREID (0,VALUE(NEWSHARETYPE),SHAREERRORMESSAGE)
    DO
     SET ORIGINALBALANCE TO TRANSFERAMOUNT
     SET MATURITYDATE TO NEWSHAREMATURITYDATE
     SET DIVRATE TO NEWSHARERATE
     SET BRANCH TO ACCOUNT:BRANCH
    END
  END

 IF SHAREERRORMESSAGE="" AND                    [CREATE IRS RECORD IF MISSING]
    NEWSHAREIRSCODE>0 THEN
  DO
   IF NEWSHAREIRSCODE>0 THEN
    DO
     IF NOT ANY IRS WITH (IRS:IRSCODE=NEWSHAREIRSCODE) THEN
      DO
       FMPERFORM CREATE IRS LOC -1 (0,0,IRSERRORMESSAGE)
        DO
         SET SSN TO NEWSHAREIRSSSN
         SET IRSCODE TO NEWSHAREIRSCODE
        END
      END
    END
  END

IF IRSERRORMESSAGE<>"" THEN
 PRINT IRSERRORMESSAGE

 IF SHAREERRORMESSAGE<>"" THEN
  DO
   PRINT "{"
   NEWLINE
   CALL PRINTPROGRAMINFO
   ERRORCODE=511
   CALL ERRORHANDLER
   NEWLINE
   FMERRORFLAG=TRUE
  END
END [PROCEDURE CREATE SHARE]

PROCEDURE ADDNAME
[* Add a new name record to the new share
*]
 TMPNAMEERROR=""
 IF NEWNAMECOUNT=0 THEN
  DO
   ADDNAMEDONE=TRUE
  END
 ELSE IF NEWNAMECOUNT>0 THEN
  DO
   FOR J=1 TO NEWNAMECOUNT
    DO
     CALL PHONENUMBERHANDLING
     IF NAMETYPESAFE(NEWNAMETYPE(J))=TRUE AND          [CREATE NAME AT ACCT LEVEL]
        VALUE(SACNAMELEVEL)=0 THEN
      DO
       FMPERFORM CREATE NAME LOC AFTERLAST
                       (0,NEWNAMETYPE(J),NAMEERRORTEXT)
        DO
         SET BIRTHDATE TO NEWNAMEDOB(J)
         SET CITY TO NEWNAMECITY(J)
         SET EMAIL TO NEWNAMEEMAIL(J)
         SET EXTRAADDRESS TO NEWNAMEEXTRA(J)
         SET FIRST TO NEWNAMEFIRST(J)
         SET LAST TO NEWNAMELAST(J)
         SET MIDDLE TO NEWNAMEMIDDLE(J)
         SET SSN TO NEWNAMESSN(J)
         SET STATE TO NEWNAMESTATE(J)
         SET STREET TO NEWNAMESTREET(J)
         SET SUFFIX TO NEWNAMESUFFIX(J)
         SET ZIPCODE TO NEWNAMEZIP(J)
         SET MOBILEPHONE TO NEWMOBILENUMBER
         SET HOMEPHONE TO NEWHOMENUMBER
         SET WORKPHONE TO NEWWORKNUMBER
        END
       NEWNAMECREATEERROR(J)=NAMEERRORTEXT
      END

     ELSE IF NAMETYPESAFE(NEWNAMETYPE(J))=TRUE AND        [CREATE NAME AT SHARE LEVEL]
             VALUE(SACNAMELEVEL)=1 THEN
      DO
       FMPERFORM CREATE SHARE NEWSHAREID NAME LOC AFTERLAST
                        (0,NEWNAMETYPE(J),SHARENAMEERRORTEXT)
        DO
         SET BIRTHDATE TO NEWNAMEDOB(J)
         SET CITY TO NEWNAMECITY(J)
         SET EMAIL TO NEWNAMEEMAIL(J)
         SET EXTRAADDRESS TO NEWNAMEEXTRA(J)
         SET FIRST TO NEWNAMEFIRST(J)
         SET LAST TO NEWNAMELAST(J)
         SET MIDDLE TO NEWNAMEMIDDLE(J)
         SET SSN TO NEWNAMESSN(J)
         SET STATE TO NEWNAMESTATE(J)
         SET STREET TO NEWNAMESTREET(J)
         SET SUFFIX TO NEWNAMESUFFIX(J)
         SET ZIPCODE TO NEWNAMEZIP(J)
         SET MOBILEPHONE TO NEWMOBILENUMBER
         SET HOMEPHONE TO NEWHOMENUMBER
         SET WORKPHONE TO NEWWORKNUMBER
        END
       NEWNAMECREATEERROR(J)=SHARENAMEERRORTEXT
      END

     ELSE IF NAMETYPESAFE(NEWNAMETYPE(J))=FALSE AND              [CREATE ACCT TRACKING]
             VALUE(SACNAMELEVEL)=0 THEN
      DO
       FMPERFORM CREATE TRACKING LOC AFTERLAST
                        (0,SACNAMETRACKING,TRACKINGERRORTEXT)
        DO
         SET USERCHAR1 TO FORMAT("99",NEWNAMETYPE(J))      [NAME TYPE]
         SET USERCHAR2 TO NEWNAMEFIRST(J)                  [FIRST]
         SET USERCHAR3 TO NEWNAMEMIDDLE(J)                 [MIDDLE]
         SET USERCHAR4 TO NEWNAMELAST(J)                   [LAST]
         SET USERCHAR5 TO NEWNAMESUFFIX(J)                 [SUFFIX]

         SET USERCHAR6 TO NEWNAMESTREET(J)                 [STREET]
         SET USERCHAR7 TO NEWNAMEEXTRA(J)                  [EXTRA]
         SET USERCHAR8 TO NEWNAMECITY(J)                   [CITY]
         SET USERCHAR9 TO NEWNAMESTATE(J)                  [STATE]
         SET USERCHAR10 TO NEWNAMEZIP(J)                   [ZIP]

         SET USERCHAR11 TO FORMAT("99/99/9999",NEWNAMEDOB(J))          [BIRTHDATE]
         SET USERCHAR12 TO FORMAT("999-99-9999",VALUE(NEWNAMESSN(J)))  [SSN]
         SET USERCHAR13 TO NEWMOBILENUMBER                             [MOBILE]
         SET USERCHAR14 TO NEWHOMENUMBER                               [HOME]
         SET USERCHAR15 TO NEWWORKNUMBER                               [WORK]
         SET USERCHAR16 TO NEWNAMEEMAIL(J)                             [EMAIL]
        END  [fm perform]
       NEWNAMECREATEERROR(J)=TRACKINGERRORTEXT
      END

     ELSE IF NAMETYPESAFE(NEWNAMETYPE(J))=FALSE AND              [CREATE SHARE TRACKING]
             VALUE(SACNAMELEVEL)=1 THEN
      DO
       FMPERFORM CREATE SHARE NEWSHAREID TRACKING LOC AFTERLAST
                       (0,SACNAMETRACKING,SHARETRACKINGERRORTEXT)
        DO
         SET USERCHAR1 TO FORMAT("99",NEWNAMETYPE(J))      [NAME TYPE]
         SET USERCHAR2 TO NEWNAMEFIRST(J)                  [FIRST]
         SET USERCHAR3 TO NEWNAMEMIDDLE(J)                 [MIDDLE]
         SET USERCHAR4 TO NEWNAMELAST(J)                   [LAST]
         SET USERCHAR5 TO NEWNAMESUFFIX(J)                 [SUFFIX]

         SET USERCHAR6 TO NEWNAMESTREET(J)                 [STREET]
         SET USERCHAR7 TO NEWNAMEEXTRA(J)                  [EXTRA]
         SET USERCHAR8 TO NEWNAMECITY(J)                   [CITY]
         SET USERCHAR9 TO NEWNAMESTATE(J)                  [STATE]
         SET USERCHAR10 TO NEWNAMEZIP(J)                   [ZIP]

         SET USERCHAR11 TO FORMAT("99/99/9999",NEWNAMEDOB(J))          [BIRTHDATE]
         SET USERCHAR12 TO FORMAT("999-99-9999",VALUE(NEWNAMESSN(J)))  [SSN]
         SET USERCHAR13 TO NEWMOBILENUMBER                             [MOBILE]
         SET USERCHAR14 TO NEWHOMENUMBER                               [HOME]
         SET USERCHAR15 TO NEWWORKNUMBER                               [WORK]
         SET USERCHAR16 TO NEWNAMEEMAIL(J)                             [EMAIL]
        END  [fm perform]
       NEWNAMECREATEERROR(J)=SHARETRACKINGERRORTEXT
[*TEK - v 1.1.0: If there was an error in creating the new name record,
** record the error in a note record under the new Share
*]
       IF NAMETYPESAFE(NEWNAMETYPE(J))=TRUE AND
          NEWNAMECREATEERROR(J)<>"" THEN
        DO
         IF VALUE(SACNAMELEVEL)=0 THEN
          TMPCHR="Account "
         ELSE
          TMPCHR="Share "
         FMPERFORM CREATE SHARE NEWSHAREID NOTE LOC 0
                          (0,0,NOTELOC,NOTEERROR)
          DO
           SET TEXT:1 TO "Opening Name Create Error:"
           SET TEXT:2 TO TMPCHR+FORMAT(" Name Type 99",NEWNAMETYPE(J))
           SET TEXT:3 TO NEWNAMEFIRST(J)+" "+NEWNAMELAST(J)
           SET TEXT:3 TO NEWNAMECREATEERROR(J)
          END
        END
      END
    END   [end of J]

   IF NAMEERRORTEXT="" AND
      SHARENAMEERRORTEXT="" AND
      TRACKINGERRORTEXT="" AND
      SHARETRACKINGERRORTEXT="" THEN
    DO
     ADDNAMEDONE=TRUE
    END
   ELSE IF NAMEERRORTEXT="" OR
           SHARENAMEERRORTEXT="" OR
           TRACKINGERRORTEXT="" OR
           SHARETRACKINGERRORTEXT="" THEN
    DO
     IF SHAREERRORMESSAGE<>"" THEN
      DO
       FMERRORFLAG=TRUE
       IF NAMEERRORTEXT="" THEN
        TMPNAMEERROR=NAMEERRORTEXT
       IF SHARENAMEERRORTEXT="" THEN
        TMPNAMEERROR=SHARENAMEERRORTEXT
       IF TRACKINGERRORTEXT="" THEN
        TMPNAMEERROR=TRACKINGERRORTEXT
       IF SHARETRACKINGERRORTEXT="" THEN
        TMPNAMEERROR=SHARETRACKINGERRORTEXT
      END
    END
  END     [end of name count]
END [PROCEDURE ADD NAME]

PROCEDURE PROCESSCOPYNAMES
[*take returned list of names to be copied from the UX and create them under
** the new share
*]
 NAMESCOPIEDCOUNT=0
 COPYINDEX=0
[* Loop through the list of locator codes of names to copy under the new share
*]
 FOR NAMESTOCOPYLOOP=1 TO NAMESTOCOPYCOUNT
  DO
[* For each name to copy, find the matching locator in the list of available names
** to copy from and record the location in the array (the index)
*]
   NAMETOCOPYLOC=NAMESTOCOPYLOC(NAMESTOCOPYLOOP)

   FOR COPYNAMELISTLOOP=1 TO COPYNAMELISTCOUNT
    DO
     TMPLOC=VALUE(COPYNAMELIST(CNLLOCATOR,COPYNAMELISTLOOP))
     IF NAMETOCOPYLOC=TMPLOC THEN
      DO
       COPYINDEX=COPYNAMELISTLOOP
       COPYNAMELISTLOOP=COPYNAMELISTCOUNT [target name was found - force loop to end]
      END
    END [FOR COPYNAMELISTLOOP=1 TO COPYNAMELISTCOUNT]
[* If the name to copy was found in the eligible names list, then copy it otherwise
** flag it for later error reporting. Since the name was not found in the list, we
** don't know the name or the name type.
*]
   IF COPYINDEX=0 THEN
    DO
     NAMESTOCOPYERROR(NAMESTOCOPYLOOP)="Error matching name Locator"
     NAMESTOCOPYNAME(NAMESTOCOPYLOOP)="Unknown Name"
     NAMESTOCOPYNAMETYPE(NAMESTOCOPYLOOP)=1 [unknown name type - force to 1]
    END
   ELSE
    DO
     NAMESTOCOPYNAME(NAMESTOCOPYLOOP)=COPYNAMELIST(CNLFIRST,COPYINDEX)+" "+
                                     COPYNAMELIST(CNLLAST,COPYINDEX)
     NAMESTOCOPYNAMETYPE(NAMESTOCOPYLOOP)=VALUE(COPYNAMELIST(CNLTYPE,COPYINDEX))
     CALL COPYNAME
     NAMESTOCOPYERROR(NAMESTOCOPYLOOP)=CNLERRORCHR
    END
  END [FOR NAMESTOCOPYLOOP=1 TO NAMESTOCOPYCOUNT]
END [PROCEDURE]

PROCEDURE COPYNAME
[* If the targeted name to copy was found in the list of eligible names then
** create the name record under the new share, if possible by referencing the
** name and address links otherwise, manually.
*]
 IF COPYINDEX>0 THEN
  DO
   IF NAMEMERGEACTIVE=TRUE AND
      COPYNAMELIST(CNLMBRADDRNUMLINK,COPYINDEX)<>"" AND
      COPYNAMELIST(CNLMEMBERNUMLINK,COPYINDEX)<>"" THEN
    DO [CREATE NAME BY REFERENCE]
     FMPERFORM CREATE SHARE NEXTID NAME
               LOC AFTERLAST (0,VALUE(COPYNAMELIST(CNLTYPE,COPYINDEX)),CNLERRORCHR)
      DO
       SET MBRADDRNUMLINK TO COPYNAMELIST(CNLMBRADDRNUMLINK,COPYINDEX)
       SET MEMBERNUMLINK TO COPYNAMELIST(CNLMEMBERNUMLINK,COPYINDEX)
      END
    END [IF NAMEMERGEACTIVE=TRUE AND...]
   ELSE [CREATE NAME MANUALLY]
    DO
     FMPERFORM CREATE SHARE NEXTID
               NAME LOC AFTERLAST
              (0,VALUE(COPYNAMELIST(CNLTYPE,COPYINDEX)),NEWNAMELOC,CNLERRORCHR)
      DO
       SET ADDRESSTYPE TO VALUE(COPYNAMELIST(CNLADDRESSTYPE,COPYINDEX))
       SET SUBTYPE TO VALUE(COPYNAMELIST(CNLSUBTYPE,COPYINDEX))
       SET NAMEFORMAT TO VALUE(COPYNAMELIST(CNLNAMEFORMAT,COPYINDEX))
       SET SSNTYPE TO VALUE(COPYNAMELIST(CNLSSNTYPE,COPYINDEX))
       SET SSN TO COPYNAMELIST(CNLSSN,COPYINDEX)
       SET SSNOVERRIDE TO VALUE(COPYNAMELIST(CNLSSNOVERRIDE,COPYINDEX))
       SET SSNCERTIFICATION TO VALUE(COPYNAMELIST(CNLSSNCERTIFICATION,COPYINDEX))
       SET FOREIGNTIN TO COPYNAMELIST(CNLFOREIGNTIN,COPYINDEX)
       SET USPERSONFLAG TO VALUE(COPYNAMELIST(CNLUSPERSONFLAG,COPYINDEX))
       SET TITLE TO COPYNAMELIST(CNLTITLE,COPYINDEX)
       SET LAST TO COPYNAMELIST(CNLLAST,COPYINDEX)
       SET FIRST TO COPYNAMELIST(CNLFIRST,COPYINDEX)
       SET MIDDLE TO COPYNAMELIST(CNLMIDDLE,COPYINDEX)
       SET SUFFIX TO COPYNAMELIST(CNLSUFFIX,COPYINDEX)
       SET BIRTHDATE TO DATEVALUE(COPYNAMELIST(CNLBIRTHDATE,COPYINDEX))
       SET SEX TO COPYNAMELIST(CNLSEX,COPYINDEX)
       SET PHONETYPE TO VALUE(COPYNAMELIST(CNLPHONETYPE,COPYINDEX))
       SET HOMEPHONE TO COPYNAMELIST(CNLHOMEPHONE,COPYINDEX)
       SET STREET TO COPYNAMELIST(CNLSTREET,COPYINDEX)
       SET EXTRAADDRESS TO COPYNAMELIST(CNLEXTRAADDRESS,COPYINDEX)
       SET CARRIERROUTE TO COPYNAMELIST(CNLCARRIERROUTE,COPYINDEX)
       SET CITY TO COPYNAMELIST(CNLCITY,COPYINDEX)
       SET STATE TO COPYNAMELIST(CNLSTATE,COPYINDEX)
       SET ZIPCODE TO COPYNAMELIST(CNLZIPCODE,COPYINDEX)
       SET COUNTRYCODE TO COPYNAMELIST(CNLCOUNTRYCODE,COPYINDEX)
       SET COUNTRY TO COPYNAMELIST(CNLCOUNTRY,COPYINDEX)
       SET RESTRICT TO VALUE(COPYNAMELIST(CNLRESTRICT,COPYINDEX))
       SET LASTADDRVERIFDATE TO DATEVALUE(COPYNAMELIST(CNLLASTADDRVERIFDATE,COPYINDEX))
      END [FMPERFORM]
    END [CREATE NAME MANUALLY]
  END [IF COPYINDEX>0]
END [PROCEDURE]

PROCEDURE DUPLICATENAMECHECK
[* Check each name record added under the new share. If a name with a matching SSN is found
** with a different address, then send an email to the CU to have the names reviewed. For
** each matching name include first, the new name info followed by the duplicate name info.
** i.e:
** New Share 0007 name added - name loc 91
*    conflicting address with Share 0100 name loc 26

*]
 EMAILHEADERPRINTED=FALSE
 FOR ACCOUNT ACCOUNT:NUMBER
  DO
   PRIMARYSHORTNAME=NAME:SHORTNAME
   FOR EACH SHARE WITH (SHARE:ID=NEWSHAREID)
    DO
     FOR EACH SHARE NAME
      DO
       BNODEBUGMSG=FORMAT("TESTING SHARE "+SHARE:ID+" NAME LOC #####9",SHARE NAME:LOCATOR)+
                   "  -  "+SHARE NAME:STREET+" - "+SHARE NAME:EXTRAADDRESS
       CALL BNODEBUGMSGADD

       DUPNAMECOUNT=0
       TESTNAMEIDTYPE=0
       TESTNAMEID=SHARE:ID
       TESTNAMESSN=SHARE NAME:SSN
       TESTNAMESHORTNAME=SHARE NAME:SHORTNAME
       TESTNAMESTREET=SHARE NAME:STREET
       TESTNAMEEXTRAADDRESS=SHARE NAME:EXTRAADDRESS
       TESTNAMECITY=SHARE NAME:CITY
       TESTNAMESTATE=SHARE NAME:STATE
       TESTNAMEZIPCODE=SHARE NAME:ZIPCODE
       TESTNAMELOCATOR=SHARE NAME:LOCATOR
       CALL TESTNAMEFORDUPS
      END
    END
  END
END [PROCEDURE]

PROCEDURE TESTNAMEFORDUPS
 FOR ACCOUNT ACCOUNT:NUMBER
  DO
   FOR EACH SHARE WITH (SHARE:CLOSEDATE=DATENULL OR
                        SHARE:CLOSEDATE>SYSTEMDATE)AND
                        SHARE:ID<>NEWSHAREID
    DO
     BNODEBUGMSG="   TESTING SHARE ID "+SHARE:ID
     CALL BNODEBUGMSGADD

     FOR EACH SHARE NAME WITH (VALIDSHARENAMETYPES(SHARE NAME:TYPE)=TRUE AND
                               SHARE NAME:DEATHDATE='--/--/--' AND
                              (SHARE NAME:EXPIRATIONDATE>SYSTEMDATE OR
                               SHARE NAME:EXPIRATIONDATE='--/--/--')AND
                               SHARE NAME:SSN=TESTNAMESSN)
      DO
       BNODEBUGMSG=FORMAT("     SHARE NAME LOC #####9",SHARE NAME:LOCATOR)+
                   "   "+SHARE NAME:STREET+" - "+SHARE NAME:EXTRAADDRESS
       CALL BNODEBUGMSGADD
       IF SHARE NAME:STREET<>TESTNAMESTREET OR
          SHARE NAME:EXTRAADDRESS<>TESTNAMEEXTRAADDRESS OR
          SHARE NAME:CITY<>TESTNAMECITY OR
          SHARE NAME:STATE<>TESTNAMESTATE OR
          SHARE NAME:ZIPCODE<>TESTNAMEZIPCODE THEN
        DO
         IF EMAILHEADERPRINTED=FALSE THEN
          CALL OPENEMAIL
         IF DUPNAMECOUNT=0 THEN
          DO
           TMPCHR="<br>New Share "+NEWSHAREID+
                   FORMAT(" name added -  name loc #####9<br>",TESTNAMELOCATOR)
           EMAILLINE(TMPCHR,EMAILSENDERROR)
          END
         TMPCHR="&nbsp;&nbsp;&nbsp;&nbsp;conflicting address with Share "+
                 SHARE:ID+FORMAT(" name loc #####9<br>",SHARE NAME:LOCATOR)
         EMAILLINE(TMPCHR,EMAILSENDERROR)
         DUPNAMECOUNT=DUPNAMECOUNT+1
         BNODEBUGMSG="       CONFLICTING NAME FOUND"
         CALL BNODEBUGMSGADD
        END
       ELSE
        DO
         BNODEBUGMSG="       NON-CONFLICTING NAME"
         CALL BNODEBUGMSGADD
        END
      END [FOR EACH SHARE NAME]
    END [FOR EACH SHARE WITH]
   FOR EACH LOAN WITH (LOAN:CLOSEDATE=DATENULL)
    DO
     BNODEBUGMSG="   TESTING LOAN ID "+LOAN:ID
     CALL BNODEBUGMSGADD
     FOR EACH LOAN NAME WITH (VALIDLOANNAMETYPES(LOAN NAME:TYPE)=TRUE AND
                               LOAN NAME:DEATHDATE='--/--/--' AND
                              (LOAN NAME:EXPIRATIONDATE>SYSTEMDATE OR
                               LOAN NAME:EXPIRATIONDATE='--/--/--')AND
                               LOAN NAME:SSN=TESTNAMESSN)
      DO
       BNODEBUGMSG=FORMAT("     LOAN NAME LOC #####9",LOAN NAME:LOCATOR)+
                   "   "+LOAN NAME:STREET+" - "+LOAN NAME:EXTRAADDRESS
       CALL BNODEBUGMSGADD
       IF LOAN NAME:STREET<>TESTNAMESTREET OR
          LOAN NAME:EXTRAADDRESS<>TESTNAMEEXTRAADDRESS OR
          LOAN NAME:CITY<>TESTNAMECITY OR
          LOAN NAME:STATE<>TESTNAMESTATE OR
          LOAN NAME:ZIPCODE<>TESTNAMEZIPCODE THEN
        DO
         IF EMAILHEADERPRINTED=FALSE THEN
          CALL OPENEMAIL
         IF DUPNAMECOUNT=0 THEN
          DO
           TMPCHR="<br>New Share "+NEWSHAREID+
                   FORMAT(" name added -  name loc #####9<br>",TESTNAMELOCATOR)
           EMAILLINE(TMPCHR,EMAILSENDERROR)
          END
         TMPCHR="&nbsp;&nbsp;&nbsp;&nbsp;conflicting address with Loan "+
                 LOAN:ID+FORMAT(" name loc #####9<br>",LOAN NAME:LOCATOR)
         EMAILLINE(TMPCHR,EMAILSENDERROR)
         DUPNAMECOUNT=DUPNAMECOUNT+1
         BNODEBUGMSG="       CONFLICTING NAME FOUND"
         CALL BNODEBUGMSGADD
        END
       ELSE
        DO
         BNODEBUGMSG="       NON-CONFLICTING NAME"
         CALL BNODEBUGMSGADD
        END
      END [FOR EACH LOAN NAME]
    END [FOR EACH LOAN WITH]
  END [FOR ACCOUNT ]
 IF EMAILHEADERPRINTED=TRUE THEN
  EMAILSEND(EMAILSENDERROR)
END [PROCEDURE]

PROCEDURE OPENEMAIL
[* Open email output to report name address conflict to the CU
*]
 EMAILSTART(SACCUSTAFFEMAILADDRESS,SACCUSTAFFEMAILADDRESS,SACCUSTAFFEMAILSUBJECT,EMAILSENDERROR)
 IF EMAILSENDERROR="" THEN
  DO
   EMAILLINE("MIME-Version: 1.0",EMAILSENDERROR)
   EMAILLINE("Content-Type: text/html; charset=us-ascii",EMAILSENDERROR)
   TMPCHR=PRIMARYSHORTNAME
   CALL NLTS
   EMAILLINE("Member ******"+
             SEGMENT(ACCOUNT:NUMBER,LENGTH(ACCOUNT:NUMBER)-3,LENGTH(ACCOUNT:NUMBER))+
            " ("+TMPCHR+") has just created a new share ID "+NEWSHAREID+".<br><br>"+
            " The name records",EMAILSENDERROR)
   EMAILLINE("added under the share include the following Name(s) which are located elsewhere",EMAILSENDERROR)
   EMAILLINE("on the account but with different addresses. Please review the new share and name",EMAILSENDERROR)
   EMAILLINE("record additions.",EMAILSENDERROR)
   EMAILLINE("<p />",EMAILSENDERROR)
   EMAILLINE("",EMAILSENDERROR)
  END

 EMAILHEADERPRINTED=TRUE
END [PROCEDURE]

PROCEDURE PHONENUMBERHANDLING
[* Assign new pnone number the the correct phone number type
*]
 NEWMOBILENUMBER=""
 NEWHOMENUMBER=""
 NEWWORKNUMBER=""

 IF NEWNAMEPHONETYPE(J)=0 THEN
  DO
   NEWMOBILENUMBER=NEWNAMEPHONE(J)
  END
 ELSE IF NEWNAMEPHONETYPE(J)=1 THEN
  NEWHOMENUMBER=NEWNAMEPHONE(J)
 ELSE IF NEWNAMEPHONETYPE(J)=2 THEN
  NEWWORKNUMBER=NEWNAMEPHONE(J)
END  [PROCEDURE PHONE HANDLING]

PROCEDURE FUNDSCHECK

 FOR EACH SHARE WITH (SHARE:CLOSEDATE='--/--/--' AND
                      SHARE:CHARGEOFFDATE='--/--/--')
  DO
   AVAILBALMIN=$0.00
   IF TRANSFERAMOUNT>$0.00 AND
      SHARE:ID=TRANSFERFROMID THEN
    AVAILBALMIN=TRANSFERAMOUNT  

   IF SACFEEAMT(1)>$0.00 AND
      SHARE:ID=FEEFROMID THEN
    AVAILBALMIN=AVAILBALMIN+SACFEEAMT(1) 

   IF AVAILBALMIN>$0.00 AND
      SHARE:AVAILABLEBALANCE<AVAILBALMIN THEN
    DO
     TRANERRORTEXT="FUNDS NO LONGER AVAILABLE"
    END
  END
 UNTIL TRANERRORTEXT<>""
 
 [RR: I don't think this works correctly since the NEWSHAREID will not have been created when
      FUNDSCHECK is called.]
 IF TRANERRORTEXT<>"" THEN
  DO
   FMPERFORM CREATE SHARE NEWSHAREID NOTE LOC 0
                    (0,0,NOTELOC,NOTEERROR)
    DO
     SET TEXT:1 TO "Opening Transfer Error:"
     SET TEXT:2 TO TRANERRORTEXT
    END
  END
END   [procedure funds check]

PROCEDURE FEECHECK

SACFEECOUNT=0
IF FEEFROMID<>"" THEN
 DO
  SACFEESHARETYPE=VALUE(NEWSHARETYPE)
  CALL GETSACFEEINFO
  IF SACFEESPECFILEERROR<>"" AND
     SACFEESPECFILEERROR<>NOSUCHFILEERROR THEN
   TRANERRORTEXT=SACFEESPECFILEERROR  
 END
END   [procedure funds check]

PROCEDURE PERFORMTRANSFER
 IF TRANSFERAMOUNT>$0.00 THEN
  DO
   TRANPERFORM XF (0,SEQ1,SEQ2,CAC,CN,TRANERRORTEXT)
    DO
     SET FMACCT TO ACCOUNT:NUMBER
     SET FMTYPE TO "S"
     SET FMID   TO TRANSFERFROMID
     SET TOACCT TO ACCOUNT:NUMBER
     SET TOTYPE TO "S"
     SET TOID   TO NEWSHAREID
     SET AMOUNT TO TRANSFERAMOUNT
    END [TRANPERFORM]
  END
 IF TRANERRORTEXT<>"" THEN
  DO
    FMPERFORM CREATE SHARE NEWSHAREID NOTE LOC 0
                     (0,0,NOTELOC,NOTEERROR)
     DO
      SET TEXT:1 TO "Opening Transfer Error:"
      SET TEXT:2 TO TRANERRORTEXT
     END
  END
END [PROCEDURE PERFORM TRANSFER]

PROCEDURE PERFORMFEE
 
 IF SACFEECOUNT>0 AND
    SACFEEAMT(1)<>$0.00 THEN
  DO
   TRANPERFORM WF (0,SEQ1,SEQ2,CAC,CN,FEETRANERRORTEXT)
    DO
     SET FMACCT TO ACCOUNT:NUMBER
     SET FMTYPE TO "S"
     SET FMID   TO FEEFROMID
     SET AMOUNT TO SACFEEAMT(1)
     SET COMMENT:1 TO SACFEEDESC(1)
     SET GLCODE TO SACFEEUSERGLCODE(1)
    END [TRANPERFORM]
  END
 IF FEETRANERRORTEXT<>"" THEN
  DO
    FMPERFORM CREATE SHARE NEWSHAREID NOTE LOC 0
                     (0,0,NOTELOC,NOTEERROR)
     DO
      SET TEXT:1 TO "Fee Posting Error:"
      SET TEXT:2 TO FEETRANERRORTEXT
     END
  END
END [PROCEDURE PERFORM TRANSFER]

PROCEDURE LOADFILETOARRAY
[* Get the valid ID Range(s) for the specific share type snd
** seed the IDRANGE array with the valid IDs
*]
[Array must be cleared]
 FOR J=0 TO IDVALUEMAX
  DO
   IDRANGE(J)=""
  END

 SFCURPOS=1
 WHILE SFCURPOS<=LENGTH(SFSEARCHLIST)
  DO
   CALL GETFIELDORSERIES
   IF SFHIGHID>0 THEN
    DO
     FOR J=SFLOWID TO SFHIGHID
      DO
       IF J<=IDVALUEMAX THEN
        IDRANGE(J)=FORMAT(REPEATCHR("9",IDLENGTH),J)
      END
    END
   ELSE
    DO
     IF SFLOWID<=IDVALUEMAX THEN
      IDRANGE(SFLOWID)=FORMAT(REPEATCHR("9",IDLENGTH),SFLOWID)
    END
  END
END [PROCEDURE]

PROCEDURE GETFIELDORSERIES
[* This procedure finds the next field or series of fields in a list of
** numbers separated by comas and/or dashes. The list must be stored in
** SFSEARCHLIST and the starting position passed in CURPOS. The starting
** ID, or single ID, is stored in SFLOWID and the ending ID, or zero, is
** stored in SFHIGHID.
]
 SFLOWID=0
 SFHIGHID=0
 CALL FINDNEXTSEPARATOR
 SFLOWID=SFNUMFOUND
 IF SFSEARCHPOS<LENGTH(SFSEARCHLIST) AND SFDELIMCHAR="-" THEN
  DO
   SFCURPOS=SFSEARCHPOS+1
   CALL FINDNEXTSEPARATOR
   SFHIGHID=SFNUMFOUND
  END
 SFCURPOS=SFSEARCHPOS+1
END [PROCEDURE]

PROCEDURE FINDNEXTSEPARATOR
[* Procedure expects a string called SFSEARCHLIST has been loaded with
** numbers separated by commas and/or dashes. It also expects you will
** set the starting point to search in the number variable called
** SFCURPOS.  The following will be returned:
**
**  SFDELIMCHAR - The separating character
**  SFNUMFOUND  - The number preceding the delimiter
**  SFSEARCHPOS - The position of the delimiter character
*]
  SFSEARCHPOS=SFCURPOS
  SFDELIMCHAR=SEGMENT(SFSEARCHLIST,SFSEARCHPOS,SFSEARCHPOS)
  WHILE SFDELIMCHAR>="0" AND SFDELIMCHAR<="9" AND
        SFDELIMCHAR<>CTRLCHR(32) AND
        SFSEARCHPOS<LENGTH(SFSEARCHLIST)
   DO
    SFSEARCHPOS=SFSEARCHPOS+1
    SFDELIMCHAR=SEGMENT(SFSEARCHLIST,SFSEARCHPOS,SFSEARCHPOS)
   END
  SFNUMFOUND=VALUE(SEGMENT(SFSEARCHLIST,SFCURPOS,SFSEARCHPOS))
END [PROCEDURE]

PROCEDURE NLTS
 CALL NLS
 CALL NTS
END [PROCEDURE]

PROCEDURE NLS
[* Remove leading spaces
**  PASS       TMPCHR
**  RETURN     TMPCHR
*]
 WHILE (LENGTH(TMPCHR)>0 AND
        SEGMENT(TMPCHR,1,1)=" ")
  DO
   IF LENGTH(TMPCHR)=1 THEN
    TMPCHR=""
   ELSE
    TMPCHR=SEGMENT(TMPCHR,2,LENGTH(TMPCHR))
  END
 IF LENGTH(TMPCHR)=0 THEN
  TMPCHR=""
END [PROCEDURE]

PROCEDURE NTS
[* Remove trailing spaces
**  PASS       TMPCHR
**  RETURN     TMPCHR
*]
 IF TMPCHR<>"" THEN
  TMPCHR=SEGMENT(TMPCHR,1,LENGTH(TMPCHR))
 IF LENGTH(TMPCHR)=0 THEN
  TMPCHR=""
END [PROCEDURE]

PROCEDURE CLEANUPTEXT
[* Check character string and remove out any characters or hidden
** characters which have an ASCII value which is not established in
** the VALIDCHRINPUT1 string in the SETUP division . This is to avoid
** display issues with displaying the terms or conditions. Additionally,
** if a back-slash or double quote is encountered, add a preceding
** backslash
**  PASS       TMPCHR   String to test
**  RETURN     TMPCHR   Updated string
*]
 LELISTINPUT=VALIDCHRINPUT1
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO MAXCHRVALUE
  DO
   VALIDCHARS(TMPLOOP)=LELIST(TMPLOOP)
  END
 TMPTEXT=""
 IF TMPCHR<>"" THEN
  DO
   FOR TMPTEXTLOOP=1 TO LENGTH(TMPCHR)
    DO
     CHRVAL=CHRVALUE(SEGMENT(TMPCHR,TMPTEXTLOOP,TMPTEXTLOOP))
     IF  VALIDCHARS(CHRVAL)=TRUE THEN
      DO
[* Check for back-slash or double-quote. If found, precede with a back-slash
*]
       IF (CHRVAL=92 OR CHRVAL=34) THEN
        TMPTEXT=TMPTEXT+BACKSLASH+SEGMENT(TMPCHR,TMPTEXTLOOP,TMPTEXTLOOP)
       ELSE
        TMPTEXT=TMPTEXT+SEGMENT(TMPCHR,TMPTEXTLOOP,TMPTEXTLOOP)
      END
    END
  END
 TMPCHR=TMPTEXT
END [PROCEDURE]

PROCEDURE ERRORHANDLER
[* Print error code information to output. If the custom error message
** is different than the standard then use that. For some error codes, add
** additional info to the logging error code detail to facilitate debugging.
** the displayErrorMessage is what the member will see.
**
**  PASS       ERRORCODE      Error code to print
**  PASS       TESTERRORCODE  Test error code (when forced - for testing)
**  PASS       ERRORDETAIL    Specific error detail
**
** ERROR CODES
**  500 - Program running in memo mode
**  501 - Config file read error
**  502 - Account warning exists
**  503 - Ineligible account type
**  504 - No eligible shares to be created
**  505 - Error reading ToC for group
**  506 - No Shares with sufficient funds to xfer
**  507 - Error reading passed name info
**  508 - Next ID calculation error
**  509 - Error getting new share rate
**  510 - Could not calculate new maturity date
**  511 - Error creating new share
**  512 - Maximum share limit error
**  513 - Error calculating fee
**  514 - Error reading fee disclosure LF for group
*]

 IF ERRORCODE>=500 AND ERRORCODE<=MAXERRORCODE THEN
  DO
   TMPNUM=ERRORCODE-500
   IF TESTERRORCODE>0 THEN
    ERRORDETAIL="TESTING: "
   ERRORDETAIL=ERRORDETAIL+ERRORCODEDESCR(ECDEFAULT,TMPNUM)

   IF ERRORCODE=501 THEN
    DO
     ERRORDETAIL=ERRORDETAIL+"-"+CONFIGFILENAME+": "+READCONFIGERROR
     IF CONFIGPROGRAMMISMATCH=TRUE THEN
      ERRORDETAIL=ERRORDETAIL+". Update and rerun CONFIG."
    END
   ELSE IF ERRORCODE=502 THEN
    ERRORDETAIL=ERRORDETAIL+" - "+FORMAT("warning code 999",I)
   ELSE IF ERRORCODE=503 THEN
    ERRORDETAIL=ERRORDETAIL+" - "+FORMAT("Acct type 9999",ACCOUNT:TYPE)
   ELSE IF ERRORCODE=505 THEN
    ERRORDETAIL=ERRORDETAIL+" - "+FORMAT("Share Grp 99 ",VALUE(OPENCATEGORY))+LFERROR
   ELSE IF ERRORCODE=511 THEN
    ERRORDETAIL=ERRORDETAIL+" - "+SHAREERRORMESSAGE
   ELSE IF ERRORCODE=514 THEN
    ERRORDETAIL=ERRORDETAIL+" - "+FORMAT("Share Grp 99 ",VALUE(OPENCATEGORY))+LFERROR 
  END

 CALL CUERRORHANDLING
 NEWLINE
 PRINT "    "+Q+"errorCode"+Q+": "+FORMAT("999",ERRORCODE)+","
 NEWLINE
 PRINT "    "+Q+"loggingErrorMessage"+Q+": "+
            Q+ERRORDETAIL+Q
 IF ERRORCODEDESCR(ECCUSTOM,TMPNUM)<>"" THEN
  TMPCHR=ERRORCODEDESCR(ECCUSTOM,TMPNUM)
 ELSE
  TMPCHR=ERRORCODEDESCR(ECDEFAULT,TMPNUM)
 PRINT ","
 NEWLINE
 PRINT "    "+Q+"displayErrorMessage"+Q+": "+Q
 IF TESTERRORCODE>0 THEN
  PRINT "TESTING: "
 PRINT TMPCHR+Q
 NEWLINE
END [PROCEDURE]

PROCEDURE JSONOPEN
 PRINT "{"
 NEWLINE
END [PROCEDURE]

PROCEDURE JSONCLOSE
 PRINT "}"
 NEWLINE
END [PROCEDURE]

PROCEDURE CUERRORHANDLING
[* Separate error detail into 2 lines if it's over 40 characters and then
** create the note record.
*]
 [CHECK ERROR TEXT LENGTH]
 IF LENGTH(ERRORDETAIL)<=40 THEN
  ERROR1=ERRORDETAIL
 ELSE
  DO
   POS=40
   FOUND=FALSE
   WHILE (POS>0 AND FOUND=FALSE)
    DO
     IF SEGMENT(ERRORDETAIL,POS,POS)=" " THEN
      FOUND=TRUE
     ELSE
      POS=POS-1
    END
   ERROR1=SEGMENT(ERRORDETAIL,1,POS-1)
   ERROR2=SEGMENT(ERRORDETAIL,POS+1,LENGTH(ERRORDETAIL))
  END

 CALL CREATENOTERECORD
END

PROCEDURE CREATENOTERECORD
[* Create a note record on the member's account detailing the error
** condition encountered
*]
 FMPERFORM CREATE NOTE LOC BEFOREFIRST
                     (0,0,NOTELOC,NOTEERROR)
  DO
   SET CODE TO 8000+ERRORCODE
   SET TEXT:1 TO "Banno sub account create error"
   SET TEXT:2 TO "Error: "+FORMAT("999",ERRORCODE)
   SET TEXT:3 TO ERROR1
   SET TEXT:4 TO ERROR2
   SET EXPIRATIONDATE TO SYSTEMDATE+30
  END
END [PROCEDURE]

PROCEDURE PRINTPROGRAMINFO
[* Print program info to JSON output
*]
 PRINT INDENT(1)+Q+"programInfo"+Q+": {"
 NEWLINE
 PRINT INDENT(2)+Q+"programName"+Q+": "+Q+"BANNO.NEWSUBCREATE.V1.POW"+Q+","
 NEWLINE
 PRINT INDENT(2)+Q+"programVersion"+Q+": "+Q+PROGRAMVERSION+Q+","
 NEWLINE
 PRINT INDENT(2)+Q+"programLastModDate"+Q+": "+Q+FORMAT("99/99/99-",LASTMODDATE)+LASTMODTIME+Q+","
 NEWLINE
 PRINT INDENT(2)+Q+"programNote1"+Q+": "+Q+PROGRAMUPDATENOTE1+Q+","
 NEWLINE
 PRINT INDENT(2)+Q+"programNote2"+Q+": "+Q+PROGRAMUPDATENOTE2+Q
 NEWLINE
 PRINT INDENT(1)+"},"
 NEWLINE
END [PROCEDURE]

PROCEDURE BUILDCOPYNAMELIST
[* Build a list of eligible names for the member to copy from. each eligible
** name is tested (by SSN) against those already added to the list and only
** added if no match was found
*]
 COPYNAMECOUNTMAX=15
 COPYNAMELISTCOUNT=0

 BNODEBUGMSG="IN BUILDCOPYNAMELIST"
 CALL BNODEBUGMSGADD

 IF VALUE(SACNAMECOPYSHAREFLAG)=TRUE THEN
  DO
   FOR EACH SHARE WITH (SHARE:CLOSEDATE=DATENULL AND
                        SHARE:CHARGEOFFDATE=DATENULL)
    DO
     IF COPYNAMELISTCOUNT<COPYNAMECOUNTMAX THEN
      DO
       FOR EACH SHARE NAME WITH (VALIDSHARENAMETYPES(SHARE NAME:TYPE)=TRUE AND
                           SHARE NAME:DEATHDATE='--/--/--' AND
                           SHARE NAME:EFFECTIVEDATE<=SYSTEMDATE AND
                          (SHARE NAME:EXPIRATIONDATE>SYSTEMDATE OR
                           SHARE NAME:EXPIRATIONDATE='--/--/--'))
        DO
         IF COPYNAMELISTCOUNT<COPYNAMECOUNTMAX THEN
          DO
           ADDNAMESSN=SHARE NAME:SSN
           ADDNAMESHORTNAME=SHARE NAME:SHORTNAME
           ADDNAMELONGNAME=SHARE NAME:LONGNAME
           ADDNAMEMBRNUMLINK=SHARE NAME:MEMBERNUMLINK
           ADDNAMEMBRADDRLINK=SHARE NAME:MBRADDRNUMLINK
           ADDNAMEFIRST=SHARE NAME:FIRST
           ADDNAMELAST=SHARE NAME:LAST
           ADDNAMEBIRTHDATE=SHARE NAME:BIRTHDATE
           ADDNAMESSN=SHARE NAME:SSN
           ADDNAMESTREET=SHARE NAME:STREET
           ADDNAMEEXADDR=SHARE NAME:EXTRAADDRESS
           ADDNAMECITY=SHARE NAME:CITY
           ADDNAMESTATE=SHARE NAME:STATE
           ADDNAMEZIPCODE=SHARE NAME:ZIPCODE
           ADDNAMEHOMEPHONE=SHARE NAME:HOMEPHONE
           ADDNAMETYPE=SHARE NAME:TYPE
           ADDNAMELOCATOR=SHARE NAME:LOCATOR
           ADDNAMESOURCE="SHARE"
           ADDNAMEADDRESSTYPE=SHARE NAME:ADDRESSTYPE
           ADDNAMESUBTYPE=SHARE NAME:SUBTYPE
           ADDNAMENAMEFORMAT=SHARE NAME:NAMEFORMAT
           ADDNAMESSNTYPE=SHARE NAME:SSNTYPE
           ADDNAMESSNOVERRIDE=SHARE NAME:SSNOVERRIDE
           ADDNAMESSNCERTIFICATION=SHARE NAME:SSNCERTIFICATION
           ADDNAMEFOREIGNTIN=SHARE NAME:FOREIGNTIN
           ADDNAMEUSPERSONFLAG=SHARE NAME:USPERSONFLAG
           ADDNAMETITLE=SHARE NAME:TITLE
           ADDNAMEMIDDLE=SHARE NAME:MIDDLE
           ADDNAMESUFFIX=SHARE NAME:SUFFIX
           ADDNAMESEX=SHARE NAME:SEX
           ADDNAMEPHONETYPE=SHARE NAME:PHONETYPE
           ADDNAMECARRIERROUTE=SHARE NAME:CARRIERROUTE
           ADDNAMECOUNTRYCODE=SHARE NAME:COUNTRYCODE
           ADDNAMECOUNTRY=SHARE NAME:COUNTRY
           ADDNAMERESTRICT=SHARE NAME:RESTRICT
           ADDNAMELASTADDRVERIFDATE=SHARE NAME:LASTADDRVERIFDATE

           CALL CHECKFORDUPLICATENAME
           IF DUPLICATENAMEFOUND=FALSE THEN
            CALL ADDNAMETOLIST

          END [IF COPYNAMELISTCOUNT<COPYNAMECOUNTMAX]
        END [FOR EACH SHARE NAME]
      END [IF COPYNAMELISTCOUNT<COPYNAMECOUNTMAX]
    END [FOR EACH SHARE]
  END [IF VALUE(SACNAMECOPYSHAREFLAG)=TRUE]

 IF VALUE(SACNAMECOPYLOANFLAG)=TRUE THEN
  DO
   FOR EACH LOAN WITH (LOAN:CLOSEDATE=DATENULL AND
                        LOAN:CHARGEOFFDATE=DATENULL)
    DO
     IF COPYNAMELISTCOUNT<COPYNAMECOUNTMAX THEN
      DO
       FOR EACH LOAN NAME WITH (VALIDLOANNAMETYPES(LOAN NAME:TYPE)=TRUE AND
                           LOAN NAME:DEATHDATE='--/--/--' AND
                           LOAN NAME:EFFECTIVEDATE<=SYSTEMDATE AND
                          (LOAN NAME:EXPIRATIONDATE>SYSTEMDATE OR
                           LOAN NAME:EXPIRATIONDATE='--/--/--'))
        DO
         IF COPYNAMELISTCOUNT<COPYNAMECOUNTMAX THEN
          DO
           ADDNAMESSN=LOAN NAME:SSN
           ADDNAMESHORTNAME=LOAN NAME:SHORTNAME
           ADDNAMELONGNAME=LOAN NAME:LONGNAME
           ADDNAMEMBRNUMLINK=LOAN NAME:MEMBERNUMLINK
           ADDNAMEMBRADDRLINK=LOAN NAME:MBRADDRNUMLINK
           ADDNAMEFIRST=LOAN NAME:FIRST
           ADDNAMELAST=LOAN NAME:LAST
           ADDNAMEBIRTHDATE=LOAN NAME:BIRTHDATE
           ADDNAMESSN=LOAN NAME:SSN
           ADDNAMESTREET=LOAN NAME:STREET
           ADDNAMEEXADDR=LOAN NAME:EXTRAADDRESS
           ADDNAMECITY=LOAN NAME:CITY
           ADDNAMESTATE=LOAN NAME:STATE
           ADDNAMEZIPCODE=LOAN NAME:ZIPCODE
           ADDNAMEHOMEPHONE=LOAN NAME:HOMEPHONE
           ADDNAMETYPE=LOAN NAME:TYPE
           ADDNAMELOCATOR=LOAN NAME:LOCATOR
           ADDNAMESOURCE="LOAN"
           ADDNAMEADDRESSTYPE=LOAN NAME:ADDRESSTYPE
           ADDNAMESUBTYPE=LOAN NAME:SUBTYPE
           ADDNAMENAMEFORMAT=LOAN NAME:NAMEFORMAT
           ADDNAMESSNTYPE=LOAN NAME:SSNTYPE
           ADDNAMESSNOVERRIDE=LOAN NAME:SSNOVERRIDE
           ADDNAMESSNCERTIFICATION=LOAN NAME:SSNCERTIFICATION
           ADDNAMEFOREIGNTIN=LOAN NAME:FOREIGNTIN
           ADDNAMEUSPERSONFLAG=LOAN NAME:USPERSONFLAG
           ADDNAMETITLE=LOAN NAME:TITLE
           ADDNAMEMIDDLE=LOAN NAME:MIDDLE
           ADDNAMESUFFIX=LOAN NAME:SUFFIX
           ADDNAMESEX=LOAN NAME:SEX
           ADDNAMEPHONETYPE=LOAN NAME:PHONETYPE
           ADDNAMECARRIERROUTE=LOAN NAME:CARRIERROUTE
           ADDNAMECOUNTRYCODE=LOAN NAME:COUNTRYCODE
           ADDNAMECOUNTRY=LOAN NAME:COUNTRY
           ADDNAMERESTRICT=LOAN NAME:RESTRICT
           ADDNAMELASTADDRVERIFDATE=LOAN NAME:LASTADDRVERIFDATE

           CALL CHECKFORDUPLICATENAME
           IF DUPLICATENAMEFOUND=FALSE THEN
            CALL ADDNAMETOLIST

          END [IF COPYNAMELISTCOUNT<COPYNAMECOUNTMAX]

        END [FOR EACH LOAN NAME]
      END [IF COPYNAMELISTCOUNT<COPYNAMECOUNTMAX]
    END [FOR EACH LOAN]
  END [IF VALUE(SACNAMECOPYLOANFLAG)=TRUE]

 BNODEBUGMSG=FORMAT("End of BUILDCOPYNAMELIST. COPYNAMELISTCOUNT:99",COPYNAMELISTCOUNT)
 CALL BNODEBUGMSGADD

 FOR TMPLOOP=1 TO COPYNAMELISTCOUNT
  DO
   BNODEBUGMSG=FORMAT("99 ",TMPLOOP)+
               COPYNAMELIST(CNLLOCATOR,TMPLOOP)+"  "+
               COPYNAMELIST(CNLSHORTNAME,TMPLOOP)+"  Duplicated? "+
               COPYNAMELIST(CNLDUPLICATED,TMPLOOP)
   CALL BNODEBUGMSGADD
  END
END [PROCEDURE]

PROCEDURE CHECKFORDUPLICATENAME
[* Check if the name being added to the list is already in the list (by
** ssn.
*]
 DUPLICATENAMEFOUND=FALSE

 BNODEBUGMSG="COPY NAME EVAL "+
              ADDNAMESOURCE+FORMAT(" NAME LOC #####9",ADDNAMELOCATOR)+
             "  SSN:"+ADDNAMESSN+
              FORMAT("  NAME TYPE:9999  ",ADDNAMETYPE)

 IF COPYNAMELISTCOUNT>0 THEN
  DO
   FOR TMPLOOP=1 TO COPYNAMELISTCOUNT
    DO
     IF ADDNAMESSN=COPYNAMELIST(CNLSSN,TMPLOOP) THEN
      DO
       DUPLICATENAMEFOUND=TRUE
       COPYNAMELIST(CNLDUPLICATED,TMPLOOP)="TRUE"
      END
    END
  END

 BNODEBUGMSG=BNODEBUGMSG+"DUP: "+
             TRUEFALSECHR(DUPLICATENAMEFOUND)
 CALL BNODEBUGMSGADD
END [PROCEDURE]

PROCEDURE ADDNAMETOLIST
[* Add the current name record being evaluated to the list of eligible name types.
*]
 IF COPYNAMELISTCOUNT<COPYNAMECOUNTMAX THEN
  DO
   COPYNAMELISTCOUNT=COPYNAMELISTCOUNT+1
   COPYNAMELIST(CNLSSN,COPYNAMELISTCOUNT)=ADDNAMESSN
   COPYNAMELIST(CNLLAST,COPYNAMELISTCOUNT)=ADDNAMELAST
   COPYNAMELIST(CNLFIRST,COPYNAMELISTCOUNT)=ADDNAMEFIRST
   COPYNAMELIST(CNLSTREET,COPYNAMELISTCOUNT)=ADDNAMESTREET
   COPYNAMELIST(CNLEXTRAADDRESS,COPYNAMELISTCOUNT)=ADDNAMEEXADDR
   COPYNAMELIST(CNLCITY,COPYNAMELISTCOUNT)=ADDNAMECITY
   COPYNAMELIST(CNLSTATE,COPYNAMELISTCOUNT)=ADDNAMESTATE
   COPYNAMELIST(CNLZIPCODE,COPYNAMELISTCOUNT)=ADDNAMEZIPCODE
   TMPCHR=FORMAT("########9",ADDNAMELOCATOR)
   CALL NLS
   COPYNAMELIST(CNLLOCATOR,COPYNAMELISTCOUNT)=TMPCHR
   COPYNAMELIST(CNLMBRADDRNUMLINK,COPYNAMELISTCOUNT)=ADDNAMEMBRADDRLINK
   COPYNAMELIST(CNLMEMBERNUMLINK,COPYNAMELISTCOUNT)=ADDNAMEMBRNUMLINK
   COPYNAMELIST(CNLTYPE,COPYNAMELISTCOUNT)=FORMAT("99",ADDNAMETYPE)
   COPYNAMELIST(CNLBIRTHDATE,COPYNAMELISTCOUNT)=FORMAT("99/99/9999",ADDNAMEBIRTHDATE)
   COPYNAMELIST(CNLSOURCE,COPYNAMELISTCOUNT)=ADDNAMESOURCE
   COPYNAMELIST(CNLSHORTNAME,COPYNAMELISTCOUNT)=ADDNAMESHORTNAME
   COPYNAMELIST(CNLLONGNAME,COPYNAMELISTCOUNT)=ADDNAMELONGNAME

   COPYNAMELIST(CNLADDRESSTYPE,COPYNAMELISTCOUNT)=FORMAT("9",ADDNAMEADDRESSTYPE)
   COPYNAMELIST(CNLSUBTYPE,COPYNAMELISTCOUNT)=FORMAT("99",ADDNAMESUBTYPE)
   COPYNAMELIST(CNLNAMEFORMAT,COPYNAMELISTCOUNT)=FORMAT("9",ADDNAMENAMEFORMAT)
   COPYNAMELIST(CNLSSNTYPE,COPYNAMELISTCOUNT)=FORMAT("9",ADDNAMESSNTYPE)
   COPYNAMELIST(CNLSSNOVERRIDE,COPYNAMELISTCOUNT)=FORMAT("9",ADDNAMESSNOVERRIDE)
   COPYNAMELIST(CNLSSNCERTIFICATION,COPYNAMELISTCOUNT)=FORMAT("9",ADDNAMESSNCERTIFICATION)
   COPYNAMELIST(CNLFOREIGNTIN,COPYNAMELISTCOUNT)=ADDNAMEFOREIGNTIN
   COPYNAMELIST(CNLUSPERSONFLAG,COPYNAMELISTCOUNT)=FORMAT("9",ADDNAMEUSPERSONFLAG)
   COPYNAMELIST(CNLTITLE,COPYNAMELISTCOUNT)=ADDNAMETITLE
   COPYNAMELIST(CNLMIDDLE,COPYNAMELISTCOUNT)=ADDNAMEMIDDLE
   COPYNAMELIST(CNLSUFFIX,COPYNAMELISTCOUNT)=ADDNAMESUFFIX
   COPYNAMELIST(CNLSEX,COPYNAMELISTCOUNT)=ADDNAMESEX
   COPYNAMELIST(CNLPHONETYPE,COPYNAMELISTCOUNT)=FORMAT("9",ADDNAMEPHONETYPE)
   COPYNAMELIST(CNLHOMEPHONE,COPYNAMELISTCOUNT)=ADDNAMEHOMEPHONE
   COPYNAMELIST(CNLCARRIERROUTE,COPYNAMELISTCOUNT)=ADDNAMECARRIERROUTE
   COPYNAMELIST(CNLCOUNTRYCODE,COPYNAMELISTCOUNT)=ADDNAMECOUNTRYCODE
   COPYNAMELIST(CNLCOUNTRY,COPYNAMELISTCOUNT)=ADDNAMECOUNTRY
   COPYNAMELIST(CNLRESTRICT,COPYNAMELISTCOUNT)=FORMAT("9",ADDNAMERESTRICT)
   COPYNAMELIST(CNLLASTADDRVERIFDATE,COPYNAMELISTCOUNT)=FORMAT("99/99/9999",ADDNAMELASTADDRVERIFDATE)

   BNODEBUGMSG=FORMAT("ADDING COPYNAME 99",COPYNAMELISTCOUNT)+
               FORMAT("  NAME LOC #####9",ADDNAMELOCATOR)
   CALL BNODEBUGMSGADD
  END [IF COPYNAMELISTCOUNT<COPYNAMELISTCOUNT]
END [PROCEDURE]

PROCEDURE BNODEBUGMSGADD
[* Add a message line to the debug message array
**
** PASS    BNODEBUGMSGMAX     Current array index max lines allowed
** PASS    BNODEBUGMSG        Debug message to add to array
**
** RETURN  BNODEBUGCOUNT      Count of debug message lines
** RETURN  BNODEBUGMSGLIST(A) Debug lines of data to print
**
**  Last Modification: 02/15/21
*]
 IF BNODEBUGCOUNT<BNODEBUGMSGMAX THEN
  DO
   BNODEBUGCOUNT=BNODEBUGCOUNT+1
   BNODEBUGMSGLIST(BNODEBUGCOUNT)=SEGMENT(BNODEBUGMSG,1,120)
   BNODEBUGMSG=""
  END
END [PROCEDURE]

PROCEDURE BNOPRINTDEBUG
[* Print debug output in proper JSON format. Requires BNODEBUGMODE to be
** on (or true).
**
**  PASS  BNODEBUGMODE        Boolean: Print debug data, T/F
**  PASS  BNODEBUGMSGLIST(A)  Array of debug messages to print
**  PASS  BNODEBUGCOUNT       Number of debug lines to print
**
**  Last Modification: 02/15/21
*]
 IF BNODEBUGMODE=BNODEBUGMODEON OR
   (LASTMODDATE+90>SYSTEMDATE) THEN
  DO
   PRINT ","
   NEWLINE
   PRINT BNOINDENT(2)+Q+"debugData"+Q+": ["
   NEWLINE
   PRINT BNOINDENT(2)+Q+"Debug note: Debug lines truncated to 100 characters"+Q
   IF BNODEBUGCOUNT>0 THEN
    DO
     FOR BNODEBUGLOOP=1 TO BNODEBUGCOUNT
      DO
       PRINT ","
       NEWLINE
       PRINT BNOINDENT(3)+Q+[FORMAT("999-",BNODEBUGLOOP)+]Segment(BNODEBUGMSGLIST(BNODEBUGLOOP),1,100)+Q
      END [FOR BNODEBUGLOOP=1 TO BNODEBUGCOUNT]
    END [IF BNODEBUGCOUNT>0 THEN]
   PRINT BNOINDENT(2)+"]"
   NEWLINE
  END
END [PROCEDURE]

PROCEDURE PARSEDATALINE
[* Parse through a line of delimited data and store individual fields into an array
**
**  PASS    BNODELIMITER       Character delimiter to be used. valid values are:
**                             BNODELIMQUOTE, BNODELIMCR, BNODELIMLF, BNODELIMCOMMA,
**                             BNODELIMTAB, BNODELIMPIPE, BNODELIMCARET or the ascii
**                             numeric value of the delimiter.
**  PASS    BNODATALINEINPUT   Line of data to be parsed.
**  RETURN  BNODATALINEFIELD   Array of data elements from the parsed BNODATALINEINPUT
**  RETURN  BNODATAFIELDCOUNT  Number of elements in the BNODATALINEFIELD array
*]

 FOR BNOLOCALLOOP=0 TO BNODATALINEFIELDMAX
  DO
   BNODATALINEFIELD(BNOLOCALLOOP)=""
  END
 BNODATAFIELDCOUNT=0
 IF BNODELIMITER=BNODELIMNONE THEN
  BNODELIMITER=BNODELIMCOMMA
 WHILE BNODATALINEINPUT<>""
  DO
   BNOPOS=CHARACTERSEARCH(BNODATALINEINPUT,CTRLCHR(BNODELIMITER))
   BNODATAFIELDCOUNT=BNODATAFIELDCOUNT+1
   IF BNOPOS=0 THEN
    DO
     BNODATALINEFIELD(BNODATAFIELDCOUNT)=BNODATALINEINPUT
     BNODATALINEINPUT=""
    END
   ELSE
    DO
     BNODATALINEFIELD(BNODATAFIELDCOUNT)=SEGMENT(BNODATALINEINPUT,1,BNOPOS-1)
     BNODATALINEINPUT=SEGMENT(BNODATALINEINPUT,BNOPOS+1,LENGTH(BNODATALINEINPUT))
    END
  END
END [PROCEDURE]

PROCEDURE SETTESTACCTSTATUS
[* Test account processing. If test account flag is set to true then create a
** list of test accounts
*]
 TESTMODE=FALSE
 TESTACCOUNT=FALSE

 IF VALUE(SACTESTMODEFLAG)=TRUE THEN
  TESTMODE=TRUE

 IF SACTESTMODEACCOUNTLIST<>"" THEN
  DO
   BNODELIMITER=BNODELIMCOMMA
   BNODATALINEINPUT=SACTESTMODEACCOUNTLIST
   CALL PARSEDATALINE
   IF BNODATAFIELDCOUNT>0 THEN
    DO
     FOR TMPLOOP=1 TO BNODATAFIELDCOUNT
      DO
       IF BNODATALINEFIELD(TMPLOOP)=ACCOUNT:NUMBER THEN
        TESTACCOUNT=TRUE
      END
    END
  END [IF VALUE(SACTESTMODEFLAG)=TRUE...]

 BNODEBUGMSG="ACCOUNT:"+ACCOUNT:NUMBER+FORMAT("  TESTMODE 9:",TESTMODE)+
             FORMAT("  TESTACCOUNT 9:",TESTACCOUNT)
 CALL BNODEBUGMSGADD

 IF TESTMODE=TRUE AND
    TESTACCOUNT=FALSE THEN
  DO
   SACSHAREGROUPSMAX=9
   SACCUSTAFFEMAILADDRESS=""
   SACCUSTAFFEMAILSUBJECT=""
   SACNAMECOPYSHAREFLAG="0"
   SACNAMECOPYSHARETYPES=""
   SACNAMECOPYLOANFLAG="0"
   SACNAMECOPYLOANTYPES=""
  END
END [PROCEDURE]

PROCEDURE SETUPERRORCODES
[* Set up default error code messages
*]
 ERRORCODEDESCR(ECDEFAULT,0)="Program running in memo mode"
 ERRORCODEDESCR(ECCUSTOM,0)=""

 ERRORCODEDESCR(ECDEFAULT,1)="CFG data file read error"
 ERRORCODEDESCR(ECCUSTOM,1)=""

 ERRORCODEDESCR(ECDEFAULT,2)="Account warning exists"
 ERRORCODEDESCR(ECCUSTOM,2)=""

 ERRORCODEDESCR(ECDEFAULT,3)="Ineligible account type"
 ERRORCODEDESCR(ECCUSTOM,3)=""

 ERRORCODEDESCR(ECDEFAULT,4)="No eligible shares available to be created"
 ERRORCODEDESCR(ECCUSTOM,4)=""

 ERRORCODEDESCR(ECDEFAULT,5)="Error reading Share group term file"
 ERRORCODEDESCR(ECCUSTOM,5)=""

 ERRORCODEDESCR(ECDEFAULT,6)="No shares with sufficient funds for required transfer"
 ERRORCODEDESCR(ECCUSTOM,6)=""

 ERRORCODEDESCR(ECDEFAULT,7)="Error reading passed name info"
 ERRORCODEDESCR(ECCUSTOM,7)=""

 ERRORCODEDESCR(ECDEFAULT,8)="Next ID calculation error"
 ERRORCODEDESCR(ECCUSTOM,8)=""

 ERRORCODEDESCR(ECDEFAULT,9)="Error getting new share rate"
 ERRORCODEDESCR(ECCUSTOM,9)=""

 ERRORCODEDESCR(ECDEFAULT,10)="Could not calculate new maturity date"
 ERRORCODEDESCR(ECCUSTOM,10)=""

 ERRORCODEDESCR(ECDEFAULT,11)="Error creating new share"
 ERRORCODEDESCR(ECCUSTOM,11)=""

 ERRORCODEDESCR(ECDEFAULT,12)="Maximum share limit error"
 ERRORCODEDESCR(ECCUSTOM,12)=""

 ERRORCODEDESCR(ECDEFAULT,13)="Error calculating fee"
 ERRORCODEDESCR(ECCUSTOM,13)=""

 ERRORCODEDESCR(ECDEFAULT,14)="Error reading Share group fee disclosure file"
 ERRORCODEDESCR(ECCUSTOM,14)=""
END [PROCEDURE]

PROCEDURE GETSACFEEINFO

 SACFEECOUNT=0
 SACFEEAMTTOTAL=$0.00
 SACFEESPECFILEERROR=""
 IF SACFEESPECFILENAME<>"" THEN
  DO
   INITSUBROUTINE(SACFEESPECFILEERROR)
   @ENVARGCODE1=SACFEESHARETYPE
   EXECUTE(SACFEESPECFILENAME,SACFEESPECFILEERROR)
   IF SACFEESPECFILEERROR="" THEN
    DO
     ADDFEEAMT=@ENVARGMONEY1
     ADDFEEDESC=@ENVARGCHAR1
     ADDFEEUSERGLCODE=@ENVARGCODE1
     CALL SACFEEADD
     ADDFEEAMT=@ENVARGMONEY2
     ADDFEEDESC=@ENVARGCHAR2
     ADDFEEUSERGLCODE=@ENVARGCODE2
     CALL SACFEEADD
     ADDFEEAMT=@ENVARGMONEY3
     ADDFEEDESC=@ENVARGCHAR3
     ADDFEEUSERGLCODE=@ENVARGCODE3
     CALL SACFEEADD
     ADDFEEAMT=@ENVARGMONEY4
     ADDFEEDESC=@ENVARGCHAR4
     ADDFEEUSERGLCODE=@ENVARGCODE4
     CALL SACFEEADD
     ADDFEEAMT=@ENVARGMONEY5
     ADDFEEDESC=@ENVARGCHAR5
     ADDFEEUSERGLCODE=@ENVARGCODE5
     CALL SACFEEADD
     ADDFEEAMT=@ENVARGMONEY6
     ADDFEEDESC=@ENVARGCHAR6
     ADDFEEUSERGLCODE=@ENVARGCODE6
     CALL SACFEEADD
     ADDFEEAMT=@ENVARGMONEY7
     ADDFEEDESC=@ENVARGCHAR7
     ADDFEEUSERGLCODE=@ENVARGCODE7
     CALL SACFEEADD
     ADDFEEAMT=@ENVARGMONEY8
     ADDFEEDESC=@ENVARGCHAR8
     ADDFEEUSERGLCODE=@ENVARGCODE8
     CALL SACFEEADD
     ADDFEEAMT=@ENVARGMONEY9
     ADDFEEDESC=@ENVARGCHAR9
     ADDFEEUSERGLCODE=@ENVARGCODE9
     CALL SACFEEADD
     ADDFEEAMT=@ENVARGMONEY10
     ADDFEEDESC=@ENVARGCHAR10
     ADDFEEUSERGLCODE=@ENVARGCODE10
     CALL SACFEEADD
    END
  END

[* NOW GET FEE SOURCE ACCOUNTS
*]
 IF SACFEEAMT(1)<>$0.00 THEN
  DO
   CALL BUILDSERVICEARRAY
   SACFEESHARECOUNT=0
   FOR EACH SHARE WITH (SHARE:CLOSEDATE='--/--/--' AND
                        SHARE:CHARGEOFFDATE='--/--/--' AND
                        SHARE:AVAILABLEBALANCE>SACFEEAMT(1) AND
                       (SERVICEOUT(SHARE:SERVICE:1)=TRUE OR
                        SERVICEOUT(SHARE:SERVICE:2)=TRUE OR
                        SERVICEOUT(SHARE:SERVICE:3)=TRUE OR
                        SERVICEOUT(SHARE:SERVICE:4)=TRUE OR
                        SERVICEOUT(SHARE:SERVICE:5)=TRUE OR
                        SERVICEOUT(SHARE:SERVICE:6)=TRUE OR
                        SERVICEOUT(SHARE:SERVICE:7)=TRUE OR
                        SERVICEOUT(SHARE:SERVICE:8)=TRUE))
    DO
     SACFEESHARECOUNT=SACFEESHARECOUNT+1
     TMPSLID="0000"+SHARE:ID
     TMPSLID=SEGMENT(TMPSLID,LENGTH(TMPSLID)-3,LENGTH(TMPSLID))
     SACFEESHAREACCTID(SACFEESHARECOUNT)=ACCOUNT:NUMBER+"S"+TMPSLID
     SACFEESHAREAVAILBAL(SACFEESHARECOUNT)=SHARE:AVAILABLEBALANCE
     SACFEESHAREDESC(SACFEESHARECOUNT)="S"+TMPSLID

     IF SHARE:NICKNAME<>"" AND
        CHARACTERSEARCH(SHARE:NICKNAME,PIPE)=0 AND
        CHARACTERSEARCH(SHARE:NICKNAME,TILDE)=0 AND
        CHARACTERSEARCH(SHARE:NICKNAME,AMPERSAND)=0 AND
        CHARACTERSEARCH(SHARE:NICKNAME,GREATERTHAN)=0 AND
        CHARACTERSEARCH(SHARE:NICKNAME,LESSTHAN)=0 THEN

      SACFEESHAREDESC(SACFEESHARECOUNT)=SHARE:NICKNAME
     ELSE IF SHARE:NICKNAME="" AND
             CHARACTERSEARCH(SEGMENT(SHARE:DESCRIPTION,1,30),PIPE)=0 AND
             CHARACTERSEARCH(SEGMENT(SHARE:DESCRIPTION,1,30),TILDE)=0  AND
             CHARACTERSEARCH(SEGMENT(SHARE:DESCRIPTION,1,30),AMPERSAND)=0 AND
             CHARACTERSEARCH(SEGMENT(SHARE:DESCRIPTION,1,30),GREATERTHAN)=0 AND
             CHARACTERSEARCH(SEGMENT(SHARE:DESCRIPTION,1,30),LESSTHAN)=0  THEN
      SACFEESHAREDESC(SACFEESHARECOUNT)=SEGMENT(SHARE:DESCRIPTION,1,30)
    END
   UNTIL SACFEESHARECOUNT=SACFEESHARECOUNTMAX  
  END
 
END

PROCEDURE SACFEEADD

 IF SACFEECOUNT<SACFEEMAX AND
    ADDFEEAMT<>$0.00 AND 
    ADDFEEDESC<>"" AND
    ADDFEEUSERGLCODE<>0 THEN
  DO
   SACFEECOUNT=SACFEECOUNT+1
   SACFEEAMT(SACFEECOUNT)=ADDFEEAMT
   SACFEEDESC(SACFEECOUNT)=ADDFEEDESC
   SACFEEUSERGLCODE(SACFEECOUNT)=ADDFEEUSERGLCODE
   SACFEEAMTTOTAL=SACFEEAMTTOTAL+ADDFEEAMT
  END 
END

PROCEDURE JSONFEEINFO

 IF SACFEECOUNT>0 THEN
  DO
   TMPCHR=FORMAT("###9.99",SACFEEAMT(1))
   CALL REMOVELEADINGSPACES
   PRINT "    ,"+Q+"feeDisclosure"+Q+": ["
   NEWLINE
   FOR TMPINDEX=1 TO SACFEEDISCLINECOUNT
    DO
     PRINT Q+SACFEEDISCLINE(TMPINDEX)+Q
     IF TMPINDEX<SACFEEDISCLINECOUNT THEN 
      PRINT ","
     NEWLINE 
    END 
   PRINT "    ],"
   NEWLINE

   PRINT "     "+Q+"fee"+Q+": {"
   NEWLINE
   PRINT "     "+Q+"amount"+Q+":"+Q+TMPCHR+Q+","
   NEWLINE

   PRINT "    "+Q+"sourceAccounts"+Q+": ["
   NEWLINE
   FOR SACFEESHAREINDEX=1 TO SACFEESHARECOUNT
    DO
     TMPCHR=SACFEESHAREDESC(SACFEESHAREINDEX)
     CALL NLTS
     CALL CLEANUPTEXT
     PRINT "    {"+Q+"name"+Q+":"+Q+TMPCHR+Q+","
     NEWLINE
     PRINT "     "+Q+"availableBalance"+Q+":"+Q
     TMPCHR=FORMAT("######9.99",SACFEESHAREAVAILBAL(SACFEESHAREINDEX))
     CALL NLS
     PRINT TMPCHR
     PRINT Q+","
     NEWLINE
     PRINT "     "+Q+"memberAccountNumber"+Q+":"+Q+SACFEESHAREACCTID(SACFEESHAREINDEX)+Q+"}"
     IF SACFEESHAREINDEX<SACFEESHARECOUNT THEN
      PRINT ","
     NEWLINE
    END
   PRINT "    ]"
   NEWLINE

   PRINT "    }"
   NEWLINE
  END
END

PROCEDURE REMOVELEADINGSPACES
 I=1
 WHILE SEGMENT(TMPCHR,I,I)=" " AND
       I<LENGTH(TMPCHR)
  DO
   I=I+1
  END
 TMPCHR=SEGMENT(TMPCHR,I,LENGTH(TMPCHR))
END

#INCLUDE "RB.LISTEXPAND"
