[*
**  PowerOn Name:       BANNO.CHECK.WITHDRAW.V1.POW
**  Letterfile Name:    BANNO.CHECK.WITHDRAW.V1.CFG
**
**  Copyright 2020-2023 Jack Henry & Associates, Inc.
**
**  Modification History:
**   Ver. 1.0.0  03/13/2020: T. Kainz - Original Programming
**   Ver. 1.0.1  04/16/2020: fixes for invalid punctuation in share descriptions
**   Ver. 1.0.2  05/14/2020: corrected error condition when no terms and conditions
**                           defined in the parameter file.
**   Ver. 1.0.3  08/12/2020: corrected TOC end of line spacing issue
**   Ver. 1.0.4  09/18/2020: Added check for attempted cross account access and return
**                           error code 505 if true. Updated TOC line spacing logic.
**   Ver. 1.1.0  08/26/2022: T. Kainz - Added parameter settings for min/max WD Amounts.
**                           Corrected max share/loan type calculation, added program
**                           info and debug output to JSON output. Corrected loan available
**                           amounts calculations. Corrected parameter file reading which was
**                           keeping blank lines from being recognized by the UX.
**   Ver. 1.1.1  10/23/2023: T. Kainz - Added check to make sure CFG settings are validated
**                           to have at least one valid Share or Loan type defined.
**   Ver. 1.2.0  11/01/2023: R. Robison - Added support for displayErrorMessage soft text.
**                           Refactor of error handling.
**
**  This Banno service PowerOn allows the user to request a
**  withdrawal by check from an eligible share or loan
**
**  For more information check
**  https://github.com/Banno/banno-powerons
**
**  Banno is not responsible for any modifications to this file
**  made by unauthorized personnel.
**
**  DO NOT MODIFY THIS FILE UNLESS YOU KNOW WHAT YOU'RE DOING!
*]

SYMCONNECT
STATELESS

TARGET=ACCOUNT

DEFINE
 #INCLUDE "RD.GETDATA.DEF"
 #INCLUDE "RB.LISTEXPAND.DEF"

 TRUE=1
 FALSE=0
 CONFIGFILENAME            = "BANNO.CHECK.WITHDRAW.V1.CFG"
 STATESTART                = "STATESTART"
 STATEPERFORMWITHDRAW      = "PERFORMWITHDRAW"
 DATENULL                  = '--/--/--'

 RGMEMBERNUM               = CHARACTER
 RGSLTYPE                  = CHARACTER
 RGSLID                    = CHARACTER
 RGWDAMOUNT                = MONEY

 BNODEBUGMODE              = NUMBER
 LFNUMBER                  = NUMBER
 LFERROR                   = CHARACTER
 LFLINE                    = CHARACTER
 READCONFIGERROR           = NUMBER
 READCONFIGERRORMSG        = CHARACTER

 PARAMREGD                 = NUMBER
 PARAMVALIDSHARETYPES      = CHARACTER
 PARAMVALIDLOANTYPES       = CHARACTER
 PARAMCASHADVLIMIT         = MONEY
 PARAMMINWDLIMIT           = MONEY
 PARAMMAXWDLIMIT           = MONEY
 PARAMWARNINGSACCT         = CHARACTER
 PARAMWARNINGSSHARE        = CHARACTER
 PARAMWARNINGSLOAN         = CHARACTER
 PARAMCUSTOMTERMS          = CHARACTER ARRAY(40)
 PARAMCUSTOMTERMLINES      = NUMBER
 PARAMCUSTOMTERMLINESMAX   = 40
 
 PARAMERRDISPLAY           = NUMBER ARRAY(10,1)
  ERRDISPLAYERRCODE        = 0
  ERRDISPLAYLINECOUNT      = 1
 PARAMERRDISPLAYCOUNT      = NUMBER
 PARAMERRDISPLAYLINES      = CHARACTER ARRAY(10,5)
 PARAMERRDISPLAYMAX        = 10
 PARAMERRDISPLAYLINESMAX   = 5
 PARAMERRDISPLAYERRLIST    = "501,502,503,504,505"

 PARAMNAME                 = CHARACTER
 PARAMVALUE                = CHARACTER

 FOUND                     = NUMBER
 FOUNDINDEX                = NUMBER
 TMPERRCODE                = NUMBER
 TMPDISPLAYLINE            = CHARACTER
 NAMEFOUND                 = NUMBER
 VALIDSHARETYPES           = NUMBER    ARRAY(9999)
 VALIDLOANTYPES            = NUMBER    ARRAY(9999)
 CASHADVLIMIT              = MONEY
 WARNINGSACCT              = NUMBER    ARRAY(999)
 WARNINGSSHARE             = NUMBER    ARRAY(999)
 WARNINGSLOAN              = NUMBER    ARRAY(999)
 SLAVAILABLEBALCHR         = CHARACTER
 TMPLOOP                   = NUMBER
 TMPLOOP2                  = NUMBER
 TMPCHR                    = CHARACTER
 POS                       = NUMBER
 Q                         = CHARACTER
 QQ                        = CHARACTER
 SLAVAILABLEBAL            = MONEY
 SLDESCRIPTION             = CHARACTER
 TRANSEQ1                  = NUMBER
 TRANSEQ2                  = NUMBER
 TRANCHKACCTCD             = CHARACTER
 TRANCHKNUMBER             = CHARACTER
 TRANERROR                 = CHARACTER
 REGDCHKCODE               = NUMBER
 SLIDLENGTH                = NUMBER
 SLTYPELENGTH              = NUMBER
 MAXWARNINGTYPES           = NUMBER
 MAXSLTYPES                = NUMBER
 TMPTEXT                   = CHARACTER
 TMPTEXTLOOP               = NUMBER
 CHRVAL                    = NUMBER
 ADDRESSLOC                = NUMBER
 NADDRESSTYPE              = NUMBER
   ADDRTYPEDOM             = 0
 VALIDCHRINPUT1            = CHARACTER
 VALIDCHARS                = NUMBER ARRAY(999)
 MAXCHRVALUE               = 255
 BACKSLASH                 = CHARACTER
 JSONBOOLEAN               = CHARACTER ARRAY(1)
 JSONPROPNAME              = CHARACTER

[* Validate status codes
*]
 VALIDATESTATUS            = NUMBER
 
 VALIDATEOK                = 0
 VALIDATEAVAILBALZERO      = 1
 VALIDATEINVALIDADDR       = 2
 VALIDATEACCTNOTFOUND      = 3
 VALIDATEWARNINGFOUND      = 4
 VALIDATESLNOTFOUND        = 5
 VALIDATEINVALIDSLTYPE     = 6
 VALIDATESLWARNINGFOUND    = 7
 VALIDATECROSSACCT         = 8

[* Transaction status codes
*]
 TRANSTATUS               = NUMBER
 
 TRANOK                    = 0
 TRANLIMITS                = 1
 TRANNSF                   = 2
 TRANPERFORMREGD           = 3
 TRANPERFORMNSF            = 4
 TRANPERFORMFAILEDOTHER    = 5

[* Error code setup
*]
 BNOERRCODECFGPARSE        = 500
 BNOERRCODESLAVAILBAL      = 501
 BNOERRCODEINVALIDADDR     = 502
 BNOERRCODENOTFOUND        = 503
 BNOERRCODEREGD            = 504
 BNOERRCODECROSSACCT       = 505
 BNOERRCODEINVALIDAMT      = 506
 BNOERRCODENSF             = 507
 BNOERRUNHANDLED           = 508
 BNOERRCODETRANPERFOTHER   = 509
  
 BNOERRORCODE              = NUMBER
 BNOERRCODE                = NUMBER
 BNOERRMESSAGE             = CHARACTER
 BNOERRDISPLAYMSG          = CHARACTER ARRAY(5)
 BNOERRDISPLAYMSGCOUNT     = NUMBER
 BNOERRCOUNT               = NUMBER
 BNOERRTMPCOUNT            = NUMBER
 BNOERRTMPCOUNT2           = NUMBER
 BNOERRFOUND               = NUMBER
 BNOERRDISPLAYLINE         = CHARACTER
 BNOERRCODES               = NUMBER ARRAY(99)
 BNOERRMESSAGES            = CHARACTER ARRAY(99)
 BNOERRDISPLAYMSGS         = CHARACTER ARRAY(99,5)
 BNOERRDISPLAYMSGSCOUNT    = NUMBER ARRAY(99)
 BNOERRDISPLAYMSGSMAX      = 5
 BNOERRMAX                 = 99
 BNOERRUNDEFINED           = "**Undefined**"

 BNOLASTMODDATE            = DATE
 BNOLASTMODTIME            = CHARACTER
 BNOPROGRAMNAME            = CHARACTER
 BNOCFGFILENAME            = CHARACTER
 BNOPROGRAMVERSION         = CHARACTER
 BNODEBUGLOOP              = NUMBER
 BNODEBUGCOUNT             = NUMBER
 BNODEBUGMSG               = CHARACTER
 BNODEBUGMSGLIST           = CHARACTER ARRAY(199)
 BNODEBUGMSGMAX            = 199
 BNOPRINTDEBUGINFODAYS     = NUMBER
 BNODEBUGMODEOFF           = 0
 BNODEBUGMODEON            = 1
END [DEFINE]

SETUP
 Q=CTRLCHR(34)
 QQ=CTRLCHR(34)

 BNOLASTMODDATE='11/01/23'
 BNOLASTMODTIME="14:30 MT"
 BNOPROGRAMNAME="BANNO.CHECK.WITHDRAW.V1.POW"
 BNOCFGFILENAME="BANNO.CHECK.WITHDRAW.V1.CFG"
 BNOPROGRAMVERSION="1.2.0"
 BNOPRINTDEBUGINFODAYS=90

 JSONBOOLEAN(TRUE)="true"
 JSONBOOLEAN(FALSE)="false"

 BNOERRCOUNT=0
 BNOERRMESSAGE=""
 BNOERRDISPLAYMSGCOUNT=0

 BNOERRCODE=BNOERRCODECFGPARSE          BNOERRMESSAGE="Error reading config file"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODESLAVAILBAL        BNOERRMESSAGE="Avail. Balance <= $0.00"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEINVALIDADDR       BNOERRMESSAGE="Invalid Address"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODENOTFOUND          BNOERRMESSAGE="Not Found"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEREGD              BNOERRMESSAGE="Reg D Limit"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODECROSSACCT         BNOERRMESSAGE="Cross Account WD Attempted"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEINVALIDAMT        BNOERRMESSAGE="Amount requested out of bounds"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODENSF               BNOERRMESSAGE="Insufficient Funds"
 CALL BNOERRADD
 BNOERRCODE=BNOERRUNHANDLED             BNOERRMESSAGE="Unhandled Error"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODETRANPERFOTHER     BNOERRMESSAGE="TRANPERFORM Other Error"
 CALL BNOERRADD

 SLIDLENGTH=GETDATANUMBER(GETPARAMIDLENGTH)
 SLTYPELENGTH=GETDATANUMBER(GETPARAMTYPELENGTH)
 IF SLTYPELENGTH=2 THEN
  MAXSLTYPES=99
 ELSE
  MAXSLTYPES=9999
 MAXWARNINGTYPES=999
 VALIDCHRINPUT1="32-126,128-175,181-184,189,190,198,199,208-216,221,222,224-253"
 BACKSLASH=CTRLCHR(92)
END [SETUP]

PRINT TITLE="BANNO.CHECK.WITHDRAW.V1.POW"
[* STATE: STATESTART
**   Find and validate account
**      Invalid account - return error code and logging message
**      Valid account - return account description, owner, payee address,
**      disclosure text and amount available for WD
** STATE: PERFORMWITHDRAW
**   Find and validate account
**      Invalid account - return error code and logging message
**      Valid account - perform WD Transaction
**        Unsuccessful - return error code and logging message
**        Successful - return 'success:true', memomode (true/false)
*]
 CALL INITIALIZEDATA
 CALL READCONFIGFILESETTINGS
 IF READCONFIGERROR=TRUE THEN
  DO
   BNOERRORCODE=BNOERRCODECFGPARSE
   BNOERRCODE=BNOERRCODECFGPARSE
   BNOERRMESSAGE=READCONFIGERRORMSG
   CALL BNOERRUPDATE
  END
 
 IF BNOERRORCODE=0 THEN
  DO
   CALL GETRGVALUES
   IF RGMEMBERNUM<>ACCOUNT:NUMBER THEN
    BNOERRORCODE=BNOERRCODECROSSACCT
  END
 
 IF BNOERRORCODE=0 THEN
  DO
   IF @RGSTATE=STATESTART THEN
    DO
     CALL VALIDATEACCOUNT
     IF VALIDATESTATUS<>VALIDATEOK THEN
      CALL VALIDATESETERROR
    END
   ELSE IF @RGSTATE=STATEPERFORMWITHDRAW THEN
    DO
     CALL VALIDATEACCOUNT
     IF VALIDATESTATUS<>VALIDATEOK THEN
      CALL VALIDATESETERROR

     IF BNOERRORCODE=0 THEN
      DO
       CALL CHECKAMOUNT
       IF TRANSTATUS<>TRANOK THEN
        CALL TRANSETERROR
      END 

     IF BNOERRORCODE=0 THEN
      DO
       CALL DOTRANPERFORM
       IF TRANERROR="" THEN
        TRANSTATUS=TRANOK
       ELSE
        DO
         IF CHARACTERSEARCH(UPPERCASE(TRANERROR),"REG D")>0 THEN
          TRANSTATUS=TRANPERFORMREGD
         ELSE IF TRANERROR="NSF" THEN
          TRANSTATUS=TRANPERFORMNSF
         ELSE
          TRANSTATUS=TRANPERFORMFAILEDOTHER  
         CALL TRANSETERROR 
        END 
      END
    END
  END

[* Output JSON 
*]
 CALL JSONOPEN
 
 IF @RGSTATE=STATESTART THEN
  DO
   IF BNOERRORCODE=0 THEN
    CALL JSONVALIDACCT
   ELSE 
    CALL JSONINVALIDACCT
  END
 ELSE IF @RGSTATE=STATEPERFORMWITHDRAW THEN
  DO
   IF BNOERRORCODE=0 THEN
    CALL JSONTRANSUCCESS 
   ELSE
    DO
     IF VALIDATESTATUS<>VALIDATEOK THEN
      CALL JSONINVALIDACCT
     ELSE
      CALL JSONTRANFAILED 
    END
  END

 CALL BNOPRINTPROGRAMINFO
 CALL BNOPRINTRGDATA
 CALL BNOPRINTDEBUG

 CALL JSONCLOSE
END [PRINT]

PROCEDURE INITIALIZEDATA
[* Initialize state variables
*]
 WHILELIMIT=100000
 RGMEMBERNUM=""
 RGSLTYPE=""
 RGSLID=""
 RGWDAMOUNT=$0.00

 BNOERRORCODE=0
 BNODEBUGMODE=FALSE
 LFNUMBER=0
 LFERROR=""
 READCONFIGERROR=FALSE
 READCONFIGERRORMSG=""
 LFERROR=""
 LFNUMBER=0
 ADDRESSLOC=0
 NADDRESSTYPE=-1
 PARAMREGD=TRUE
 PARAMVALIDSHARETYPES="ALL"
 PARAMVALIDLOANTYPES="ALL"
 PARAMCASHADVLIMIT=$0.00
 PARAMMINWDLIMIT=$0.00
 PARAMMAXWDLIMIT=$0.00
 PARAMWARNINGSACCT="NONE"
 PARAMWARNINGSSHARE="NONE"
 PARAMWARNINGSLOAN="NONE"
 PARAMCUSTOMTERMLINES=0
 PARAMERRDISPLAYCOUNT=0
 FOR TMPLOOP=0 TO PARAMERRDISPLAYMAX
  DO
   PARAMERRDISPLAY(TMPLOOP,ERRDISPLAYERRCODE)=0
   PARAMERRDISPLAY(TMPLOOP,ERRDISPLAYLINECOUNT)=0
  END

 VALIDATESTATUS=VALIDATEOK
 TRANSTATUS=TRANOK
 
 FOR TMPLOOP=0 TO MAXSLTYPES
  DO
   VALIDSHARETYPES(TMPLOOP)=FALSE
   VALIDLOANTYPES(TMPLOOP)=FALSE
  END

 FOR TMPLOOP=0 TO MAXWARNINGTYPES
  DO
   WARNINGSACCT(TMPLOOP)=FALSE
   WARNINGSSHARE(TMPLOOP)=FALSE
   WARNINGSLOAN(TMPLOOP)=FALSE
  END

 IF BNOLASTMODDATE+BNOPRINTDEBUGINFODAYS>SYSTEMDATE THEN
  BNODEBUGMODE=BNODEBUGMODEON
END [PROCEDURE]

PROCEDURE GETRGVALUES
[* Pull the values of the @RG variables for use during the state
*]
 RGMEMBERNUM=SEGMENT(@RGUSERCHR1,1,10)
 RGSLTYPE=UPPERCASE(SEGMENT(@RGUSERCHR1,11,11))
 RGSLID="00"+SEGMENT(@RGUSERCHR1,12,LENGTH(@RGUSERCHR1))
 RGSLID=SEGMENT(RGSLID,LENGTH(RGSLID)-(SLIDLENGTH-1),LENGTH(RGSLID))

 IF @RGSTATE=STATEPERFORMWITHDRAW THEN
  DO
   TMPCHR=@RGUSERCHR2+"00"

   POS=CHARACTERSEARCH(TMPCHR,".")
   IF POS>0 THEN
    TMPCHR=SEGMENT(TMPCHR,1,POS+2)

   RGWDAMOUNT=MONEY(VALUE(TMPCHR))
  END
END [PROCEDURE]

PROCEDURE DOTRANPERFORM

 IF RGSLTYPE="S" AND
    PARAMREGD=TRUE THEN
  REGDCHKCODE=1
 ELSE
  REGDCHKCODE=0
 IF RGSLTYPE="S" THEN
  DO
   TRANPERFORM WK (1,TRANSEQ1,TRANSEQ2,TRANCHKACCTCD,TRANCHKNUMBER,
                   TRANERROR)
    DO
     SET FMACCT TO RGMEMBERNUM
     SET FMTYPE TO RGSLTYPE
     SET FMID TO RGSLID
     SET AMOUNT TO RGWDAMOUNT
     SET ISSUE TO "S"
     SET REGDCHK TO REGDCHKCODE
     SET CHECKTYPE TO 0
    END
  END
 ELSE
  DO
   TRANPERFORM AK (1,TRANSEQ1,TRANSEQ2,TRANCHKACCTCD,TRANCHKNUMBER,
                   TRANERROR)
    DO
     SET FMACCT TO RGMEMBERNUM
     SET FMTYPE TO RGSLTYPE
     SET FMID TO RGSLID
     SET AMOUNT TO RGWDAMOUNT
     SET ISSUE TO "S"
     SET REGDCHK TO REGDCHKCODE
     SET CHECKTYPE TO 0
    END
  END
END [PROCEDURE]

PROCEDURE CHECKAMOUNT

 IF RGWDAMOUNT<=$0.00 OR
    RGWDAMOUNT>SLAVAILABLEBAL THEN
  TRANSTATUS=TRANNSF
 ELSE IF ((PARAMMINWDLIMIT>$0.00 AND
           RGWDAMOUNT<PARAMMINWDLIMIT) OR
          (PARAMMAXWDLIMIT>$0.00 AND
           RGWDAMOUNT>PARAMMAXWDLIMIT)) THEN
  TRANSTATUS=TRANLIMITS          
END [PROCEDURE]

PROCEDURE TRANSETERROR

 IF TRANSTATUS=TRANNSF THEN
  DO
   BNOERRORCODE=BNOERRCODENSF
   BNOERRCODE=BNOERRCODENSF
   TMPCHR=FORMAT(" ###,##9.99",RGWDAMOUNT)
   CALL NLS
   BNOERRMESSAGE="Amount req. "+TMPCHR
   TMPCHR=FORMAT(" ###,##9.99",SLAVAILABLEBAL)
   CALL NLS
   BNOERRMESSAGE=BNOERRMESSAGE+" exceeds avail. "+TMPCHR
   CALL BNOERRUPDATE
  END
 ELSE IF TRANSTATUS=TRANLIMITS THEN
  DO
   BNOERRORCODE=BNOERRCODEINVALIDAMT
   BNOERRCODE=BNOERRCODEINVALIDAMT
   BNOERRMESSAGE="Amount requested out of bounds"
   CALL BNOERRUPDATE
  END
 ELSE IF TRANSTATUS=TRANPERFORMREGD OR
         TRANSTATUS=TRANPERFORMNSF OR
         TRANSTATUS=TRANPERFORMFAILEDOTHER THEN
  DO
   IF TRANSTATUS=TRANPERFORMREGD THEN 
    DO
     BNOERRORCODE=BNOERRCODEREGD
     BNOERRCODE=BNOERRCODEREGD
    END
   ELSE IF TRANSTATUS=TRANPERFORMNSF THEN
    DO
     BNOERRORCODE=BNOERRCODENSF
     BNOERRCODE=BNOERRCODENSF
    END
   ELSE
    DO
     BNOERRORCODE=BNOERRCODETRANPERFOTHER
     BNOERRCODE=BNOERRCODETRANPERFOTHER
    END   
   BNOERRMESSAGE="TRANPERFORM Error: "+TRANERROR
   CALL BNOERRUPDATE
  END
 ELSE
  BNOERRORCODE=BNOERRUNHANDLED
END [PROCEDURE]

PROCEDURE VALIDATEACCOUNT
[* Look up the account and share/loan ID. Test for any disqualifications
** and if valid, get the available balance if it's a Share or if it's a
** loan, get the lesser of the available cash advance or the cash advance
** limit as set in the configuration parameters.
** PASS    RGMEMBERNUM               The member number (ACCOUNT:NUMBER)
** PASS    RGSLTYPE                  Is target a Share or Loan (S or L)
** PASS    RGSLID                    Target Share/Loan ID
** RETURN  VALIDATESTATUS          Validate status
** RETURN  SLAVAILABLEBAL          The available balance/loan advance
** RETURN  SLDESCRIPTION           The Share/Loan description
*]

 VALIDATESTATUS=VALIDATEACCTNOTFOUND
 SLAVAILABLEBAL=$0.00
 SLDESCRIPTION=""
 FOR ACCOUNT RGMEMBERNUM
  DO
[*Check to make sure account does not have a targeted warning
*]
   VALIDATESTATUS=VALIDATEOK
   FOR TMPLOOP=1 TO MAXWARNINGTYPES
    DO
     IF ANYWARNING(ACCOUNT,TMPLOOP) AND
        WARNINGSACCT(TMPLOOP)=TRUE THEN
      VALIDATESTATUS=VALIDATEWARNINGFOUND   
    END

   IF VALIDATESTATUS=VALIDATEOK THEN
    DO
[* Invalidate account if any key address fields are missing
*]
     NAMEFOUND=FALSE
     ADDRESSLOC=ACCOUNT:PAYEENAMELOCATOR
     FOR EACH NAME WITH (NAME:LOCATOR=ADDRESSLOC)
      DO
       NADDRESSTYPE=NAME:ADDRESSTYPE
       IF NAME:STREET<>"" AND
          NAME:CITY<>"" AND
          NAME:STATE<>"" AND
          NAME:ZIPCODE<>"" AND
        ((NADDRESSTYPE<>ADDRTYPEDOM AND
          NAME:COUNTRY<>"") OR
         (NADDRESSTYPE=ADDRTYPEDOM AND
          NAME:COUNTRY="")) THEN
        NAMEFOUND=TRUE
      END
     IF NAMEFOUND=FALSE THEN
      VALIDATESTATUS=VALIDATEINVALIDADDR
    END

   IF VALIDATESTATUS=VALIDATEOK AND RGSLTYPE="S" THEN
    DO
     VALIDATESTATUS=VALIDATESLNOTFOUND
     FOR EACH SHARE WITH (SHARE:ID=RGSLID AND
                          SHARE:CLOSEDATE=DATENULL AND
                          SHARE:CHARGEOFFDATE=DATENULL)
      DO
       VALIDATESTATUS=VALIDATEOK
       SLAVAILABLEBAL=SHARE:AVAILABLEBALANCE
       TMPCHR=SHARE:DESCRIPTION
       CALL CLEANUPTEXT
       SLDESCRIPTION=TMPCHR

       IF VALIDSHARETYPES(SHARE:TYPE)<>TRUE THEN
        VALIDATESTATUS=VALIDATEINVALIDSLTYPE

       IF VALIDATESTATUS=VALIDATEOK AND
          SLAVAILABLEBAL<=$0.00 THEN
        VALIDATESTATUS=VALIDATEAVAILBALZERO    

       IF VALIDATESTATUS=VALIDATEOK THEN 
        DO 
[* Check for targeted Share warning(s)
*]
         FOR TMPLOOP=1 TO MAXWARNINGTYPES
          DO
           IF ANYWARNING(SHARE,TMPLOOP) AND
              WARNINGSSHARE(TMPLOOP)=TRUE THEN
            VALIDATESTATUS=VALIDATESLWARNINGFOUND
          END
        END  
      END
    END

   IF VALIDATESTATUS=VALIDATEOK AND RGSLTYPE="L" THEN
    DO
     VALIDATESTATUS=VALIDATESLNOTFOUND
     FOR EACH LOAN WITH (LOAN:ID=RGSLID AND
                         LOAN:CLOSEDATE=DATENULL AND
                         LOAN:CHARGEOFFDATE=DATENULL)
      DO
       VALIDATESTATUS=VALIDATEOK
       TMPCHR=LOAN:DESCRIPTION
       CALL CLEANUPTEXT
       SLDESCRIPTION=TMPCHR

       IF (LOAN:CREDLIMITEXPIRATION=DATENULL OR
           LOAN:CREDLIMITEXPIRATION>SYSTEMDATE) THEN
        DO
         IF LOAN:LOANCODE=3 AND
         (LOAN:INTERESTTYPE>=10 AND
          LOAN:INTERESTTYPE<=8999) THEN
           SLAVAILABLEBAL=LOAN:AVAILABLECASHADVANCE
          ELSE
           SLAVAILABLEBAL=LOAN:AVAILABLECREDIT
        END

       IF PARAMCASHADVLIMIT>$0.00 AND
          SLAVAILABLEBAL>PARAMCASHADVLIMIT THEN
        SLAVAILABLEBAL=PARAMCASHADVLIMIT

       IF VALIDLOANTYPES(LOAN:TYPE)<>TRUE THEN
        VALIDATESTATUS=VALIDATEINVALIDSLTYPE

       IF VALIDATESTATUS=VALIDATEOK AND
          SLAVAILABLEBAL<=$0.00 THEN
        VALIDATESTATUS=VALIDATEAVAILBALZERO    
 
       IF VALIDATESTATUS=VALIDATEOK THEN 
        DO 

[* Check for targeted Loan warning(s)
*]
         FOR TMPLOOP=1 TO MAXWARNINGTYPES
          DO
           IF ANYWARNING(LOAN,TMPLOOP) AND
              WARNINGSLOAN(TMPLOOP)=TRUE THEN
            VALIDATESTATUS=VALIDATESLWARNINGFOUND
          END
        END
      END
    END
  END

 TMPCHR=FORMAT("#########9.99+",SLAVAILABLEBAL)
 CALL NLTS
 SLAVAILABLEBALCHR=TMPCHR
END [PROCEDURE]

PROCEDURE VALIDATESETERROR
[* Set correct BNOERRORCODE based on validate status
** PASS    [various]     valid acct test (true/false)
** RETURN  BNOERRORCODE  Error code for UX based upon flag
*]

 IF VALIDATESTATUS=VALIDATEINVALIDADDR THEN
  BNOERRORCODE=BNOERRCODEINVALIDADDR
 ELSE IF VALIDATESTATUS=VALIDATEACCTNOTFOUND OR
         VALIDATESTATUS=VALIDATEWARNINGFOUND OR
         VALIDATESTATUS=VALIDATESLNOTFOUND OR
         VALIDATESTATUS=VALIDATEINVALIDSLTYPE OR
         VALIDATESTATUS=VALIDATESLWARNINGFOUND THEN
  DO
   BNOERRORCODE=BNOERRCODENOTFOUND
   BNOERRCODE=BNOERRCODENOTFOUND

   IF VALIDATESTATUS=VALIDATEACCTNOTFOUND THEN
    BNOERRMESSAGE="Account Not Found"
   ELSE IF VALIDATESTATUS=VALIDATEWARNINGFOUND THEN
    BNOERRMESSAGE="Account Warning Found"
   ELSE IF VALIDATESTATUS=VALIDATESLNOTFOUND AND RGSLTYPE="S" THEN
    BNOERRMESSAGE="Share Not Found"
   ELSE IF VALIDATESTATUS=VALIDATESLNOTFOUND AND RGSLTYPE="L" THEN
    BNOERRMESSAGE="Loan Not Found"
   ELSE IF VALIDATESTATUS=VALIDATEINVALIDSLTYPE AND RGSLTYPE="S" THEN
    BNOERRMESSAGE="Invalid Share Type"
   ELSE IF VALIDATESTATUS=VALIDATEINVALIDSLTYPE AND RGSLTYPE="L" THEN
    BNOERRMESSAGE="Invalid Loan Type"
   ELSE IF VALIDATESTATUS=VALIDATESLWARNINGFOUND AND RGSLTYPE="S" THEN
    BNOERRMESSAGE="Share Warning Found"
   ELSE IF VALIDATESTATUS=VALIDATESLWARNINGFOUND AND RGSLTYPE="L" THEN
    BNOERRMESSAGE="Loan Warning Found"
   CALL BNOERRUPDATE
  END       
 ELSE IF VALIDATESTATUS=VALIDATEAVAILBALZERO THEN
  BNOERRORCODE=BNOERRCODESLAVAILBAL
 ELSE
  BNOERRORCODE=BNOERRUNHANDLED
END [PROCEDURE]

[*
**  --------------------------------------------------------------------
**  Config File Processing Procedures
**  --------------------------------------------------------------------
*]
PROCEDURE READCONFIGFILESETTINGS
[* read parameter settings from the configuration Letter file.
*]
 FILEOPEN("LETTER",CONFIGFILENAME,"READ",LFNUMBER,LFERROR)

 IF LFERROR<>"" THEN
  DO
   READCONFIGERROR=TRUE
   READCONFIGERRORMSG="Error Opening Letterfile "+CONFIGFILENAME+": "+LFERROR
  END
 ELSE
  DO
   FILEREADLINE(LFNUMBER,LFLINE,LFERROR)
   WHILE LFERROR=""
    DO
     CALL NORMALIZEDATA

     IF PARAMNAME<>"" THEN
      DO
[* Check for Reg D Param
*]
       IF PARAMNAME="REGD" AND
          PARAMVALUE<>"TRUE" THEN
        PARAMREGD=FALSE
[* Cash Advance Limit
*]
       ELSE IF PARAMNAME="CA" THEN
        PARAMCASHADVLIMIT=MONEY(VALUE(PARAMVALUE))

[* Minimum WD amount
*]
       ELSE IF PARAMNAME="MIN" THEN
        DO
         PARAMMINWDLIMIT=MONEY(VALUE(PARAMVALUE))
         IF PARAMMINWDLIMIT>$999,999.99 THEN
          PARAMMINWDLIMIT=$999,999.99
        END
[* Maximum WD amount
*]
       ELSE IF PARAMNAME="MAX" THEN
        DO
         PARAMMAXWDLIMIT=MONEY(VALUE(PARAMVALUE))
         IF PARAMMAXWDLIMIT>$999,999.99 THEN
          PARAMMAXWDLIMIT=$999,999.99
        END

[* Valid Share Types
*]
       ELSE IF PARAMNAME="ST" AND
               PARAMVALUE<>"" THEN
        PARAMVALIDSHARETYPES=PARAMVALUE
[* Valid Loan Types
*]
       ELSE IF PARAMNAME="LT" AND
          PARAMVALUE<>"" THEN
        PARAMVALIDLOANTYPES=PARAMVALUE
[* Account Warnings
*]
       ELSE IF PARAMNAME="AW" AND
               PARAMVALUE<>"" THEN
        PARAMWARNINGSACCT=PARAMVALUE
[* Share Warnings
*]
       ELSE IF PARAMNAME="SW" AND
               PARAMVALUE<>"" THEN
        PARAMWARNINGSSHARE=PARAMVALUE
[* Loan Warnings
*]
       ELSE IF PARAMNAME="LW" AND
               PARAMVALUE<>"" THEN
        PARAMWARNINGSLOAN=PARAMVALUE
[* Check for Debug Mode
*]
       ELSE IF PARAMNAME="DEBUG" THEN
        DO
         IF CHARACTERSEARCH("TRUEYES1DEBUGON",PARAMVALUE)>0 THEN
          BNODEBUGMODE=TRUE
         ELSE
          BNODEBUGMODE=FALSE
        END
[* Custom terms & conditions
*]
       ELSE IF PARAMNAME="TC" THEN
        DO
         IF PARAMCUSTOMTERMLINES<PARAMCUSTOMTERMLINESMAX THEN
          DO
           PARAMCUSTOMTERMLINES=PARAMCUSTOMTERMLINES+1
           TMPCHR=PARAMVALUE
           CALL NTS
           CALL CLEANUPTEXT
[* Retain only first 123 characters to account for JSON spacing and field delimiters
*]
           PARAMCUSTOMTERMS(PARAMCUSTOMTERMLINES)=SEGMENT(TMPCHR,1,123)
          END
        END

[* Custom error display messages
*]
       ELSE IF SEGMENT(PARAMNAME,1,3)="EDM" THEN
        DO
         TMPERRCODE=VALUE(SEGMENT(PARAMNAME,4,6))
         IF CHARACTERSEARCH(PARAMERRDISPLAYERRLIST,FORMAT("999",TMPERRCODE))>0 THEN
          DO
           TMPCHR=PARAMVALUE
           CALL NTS
           CALL CLEANUPTEXT
[* Retain only first 123 characters to account for JSON spacing and field delimiters
*]
           TMPDISPLAYLINE=SEGMENT(TMPCHR,1,123)

           CALL PARAMERRDISPLAYADD
          END
        END

      END
     PARAMNAME=""
     PARAMVALUE=""
     FILEREADLINE(LFNUMBER,LFLINE,LFERROR)
    END
   IF LFERROR<>"" AND
      LFERROR<>"EOF" THEN
    DO
     READCONFIGERROR=TRUE
     READCONFIGERRORMSG="Error Reading Letterfile "+CONFIGFILENAME+": "+LFERROR
    END
   FILECLOSE(LFNUMBER,LFERROR)
  END

 IF BNODEBUGMODE=TRUE THEN
  DO

   NEWLINE
   BNODEBUGMSG="CA: "+FORMAT("###,###,##9.99",PARAMCASHADVLIMIT)
   CALL BNODEBUGMSGADD
   BNODEBUGMSG="MIN: "+FORMAT("###,###,##9.99",PARAMMINWDLIMIT)
   CALL BNODEBUGMSGADD
   BNODEBUGMSG="MAX: "+FORMAT("###,###,##9.99",PARAMMAXWDLIMIT)
   CALL BNODEBUGMSGADD
   BNODEBUGMSG="ST: "+PARAMVALIDSHARETYPES
   CALL BNODEBUGMSGADD
   BNODEBUGMSG="LT: "+PARAMVALIDLOANTYPES
   CALL BNODEBUGMSGADD
   BNODEBUGMSG="AW: "+PARAMWARNINGSACCT
   CALL BNODEBUGMSGADD
   BNODEBUGMSG="SW: "+PARAMWARNINGSSHARE
   CALL BNODEBUGMSGADD
   BNODEBUGMSG="LW: "+PARAMWARNINGSLOAN
   CALL BNODEBUGMSGADD
   BNODEBUGMSG="DEBUG: "+FORMAT("9",BNODEBUGMODE)
   CALL BNODEBUGMSGADD
   FOR TMPLOOP=1 TO PARAMCUSTOMTERMLINES
    DO
     BNODEBUGMSG=FORMAT("TC-99:",TMPLOOP)+"'"+PARAMCUSTOMTERMS(TMPLOOP)+"'"
     CALL BNODEBUGMSGADD
    END
  END

 IF PARAMVALIDSHARETYPES="NONE" AND
    PARAMVALIDLOANTYPES="NONE" THEN
  DO
   READCONFIGERROR=TRUE
   READCONFIGERRORMSG="CFG Letterfile Error: No Share/Loan types defined."
  END

 IF READCONFIGERROR=FALSE THEN
  CALL CONFIGFILEPOSTPROCESS
END [PROCEDURE]

PROCEDURE CONFIGFILEPOSTPROCESS
[* Do post-processing of config file settings
*]
 LELISTINPUT=PARAMVALIDSHARETYPES
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO MAXSLTYPES
  DO
   VALIDSHARETYPES(TMPLOOP)=LELIST(TMPLOOP)
  END

 LELISTINPUT=PARAMVALIDLOANTYPES
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO MAXSLTYPES
  DO
   VALIDLOANTYPES(TMPLOOP)=LELIST(TMPLOOP)
  END

 LELISTINPUT=PARAMWARNINGSACCT
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO MAXWARNINGTYPES
  DO
   WARNINGSACCT(TMPLOOP)=LELIST(TMPLOOP)
  END

 LELISTINPUT=PARAMWARNINGSSHARE
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO MAXWARNINGTYPES
  DO
   WARNINGSSHARE(TMPLOOP)=LELIST(TMPLOOP)
  END

 LELISTINPUT=PARAMWARNINGSLOAN
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO MAXWARNINGTYPES
  DO
   WARNINGSLOAN(TMPLOOP)=LELIST(TMPLOOP)
  END

[* Ignore if only one blank line is configured
*]
 FOR TMPLOOP=1 TO PARAMERRDISPLAYCOUNT
  DO
   IF PARAMERRDISPLAY(TMPLOOP,ERRDISPLAYLINECOUNT)=1 AND 
      PARAMERRDISPLAYLINES(TMPLOOP,1)="" THEN
    PARAMERRDISPLAY(TMPLOOP,ERRDISPLAYLINECOUNT)=0
  END

 FOR TMPLOOP=1 TO PARAMERRDISPLAYCOUNT
  DO
   FOR TMPLOOP2=1 TO PARAMERRDISPLAY(TMPLOOP,ERRDISPLAYLINECOUNT)
    DO
     TMPCHR=PARAMERRDISPLAYLINES(TMPLOOP,TMPLOOP2)
     CALL NTS
     BNOERRDISPLAYLINE=TMPCHR
     CALL BNOERRDISPLAYAPPEND
    END
   BNOERRCODE=PARAMERRDISPLAY(TMPLOOP,ERRDISPLAYERRCODE) 
   CALL BNOERRDISPLAYUPDATE
  END
END [PROCEDURE]

PROCEDURE PARAMERRDISPLAYADD

 FOUNDINDEX=1
 FOUND=FALSE
 WHILE FOUNDINDEX<=PARAMERRDISPLAYCOUNT AND FOUND=FALSE
  DO
   IF PARAMERRDISPLAY(FOUNDINDEX,ERRDISPLAYERRCODE)=TMPERRCODE THEN
    FOUND=TRUE
   ELSE 
    FOUNDINDEX=FOUNDINDEX+1
  END

 IF FOUNDINDEX<=PARAMERRDISPLAYMAX THEN
  DO
   IF FOUND=FALSE THEN
    DO
     PARAMERRDISPLAYCOUNT=FOUNDINDEX
     PARAMERRDISPLAY(FOUNDINDEX,ERRDISPLAYERRCODE)=TMPERRCODE
     PARAMERRDISPLAY(FOUNDINDEX,ERRDISPLAYLINECOUNT)=1
     PARAMERRDISPLAYLINES(FOUNDINDEX,1)=TMPDISPLAYLINE
    END
   ELSE IF PARAMERRDISPLAY(FOUNDINDEX,ERRDISPLAYLINECOUNT)<PARAMERRDISPLAYLINESMAX THEN
    DO
     PARAMERRDISPLAY(FOUNDINDEX,ERRDISPLAYLINECOUNT)=PARAMERRDISPLAY(FOUNDINDEX,ERRDISPLAYLINECOUNT)+1
     PARAMERRDISPLAYLINES(FOUNDINDEX,PARAMERRDISPLAY(FOUNDINDEX,ERRDISPLAYLINECOUNT))=TMPDISPLAYLINE
    END 
  END
END [PROCEDURE]

[*
**  --------------------------------------------------------------------
**  Debug/Error Processing Procedures
**  --------------------------------------------------------------------
*]
PROCEDURE BNOERRADD
[* Adds an error code to the valid list of error codes
**
**  PASS    BNOERRCODE       Numeric error code
**  PASS    BNOERRMESSAGE    Error description
*]

 IF BNOERRCOUNT<BNOERRMAX THEN
  DO
   BNOERRCOUNT=BNOERRCOUNT+1
   BNOERRCODES(BNOERRCOUNT)=BNOERRCODE
   BNOERRMESSAGES(BNOERRCOUNT)=BNOERRMESSAGE
  END
 BNOERRMESSAGE=""
END [PROCEDURE]

PROCEDURE BNOERRUPDATE
[* Updates an error code error message or display message
**
**  PASS    BNOERRCODE       Numeric error code
**  PASS    BNOERRMESSAGE    Error description
*]

 BNOERRTMPCOUNT=1
 BNOERRFOUND=FALSE
 WHILE BNOERRTMPCOUNT<=BNOERRCOUNT AND 
       BNOERRFOUND=FALSE
  DO
   IF BNOERRCODES(BNOERRTMPCOUNT)=BNOERRCODE THEN
    DO
     BNOERRFOUND=TRUE
     BNOERRMESSAGES(BNOERRTMPCOUNT)=BNOERRMESSAGE
    END
   BNOERRTMPCOUNT=BNOERRTMPCOUNT+1
  END
 BNOERRMESSAGE=""
END [PROCEDURE]

PROCEDURE BNOERRDISPLAYAPPEND

 IF BNOERRDISPLAYMSGCOUNT<BNOERRDISPLAYMSGSMAX THEN
  DO
   BNOERRDISPLAYMSGCOUNT=BNOERRDISPLAYMSGCOUNT+1
   BNOERRDISPLAYMSG(BNOERRDISPLAYMSGCOUNT)=BNOERRDISPLAYLINE
  END 
END [PROCEDURE]

PROCEDURE BNOERRDISPLAYUPDATE

 BNOERRTMPCOUNT=1
 BNOERRFOUND=FALSE
 WHILE BNOERRTMPCOUNT<=BNOERRCOUNT AND 
       BNOERRFOUND=FALSE
  DO
   IF BNOERRCODES(BNOERRTMPCOUNT)=BNOERRCODE THEN
    DO
     BNOERRFOUND=TRUE
     BNOERRDISPLAYMSGSCOUNT(BNOERRTMPCOUNT)=BNOERRDISPLAYMSGCOUNT
     FOR BNOERRTMPCOUNT2=1 TO BNOERRDISPLAYMSGCOUNT
      DO
       BNOERRDISPLAYMSGS(BNOERRTMPCOUNT,BNOERRTMPCOUNT2)=BNOERRDISPLAYMSG(BNOERRTMPCOUNT2)
      END
    END
   BNOERRTMPCOUNT=BNOERRTMPCOUNT+1
  END
 BNOERRDISPLAYMSGCOUNT=0
END [PROCEDURE]

PROCEDURE BNOERRGET
[* Gets the error message associated with the BNOERRORCODE
**
**  PASS    BNOERRORCODE     Numeric error code
**
**  RETURN  BNOERRCODE       Error code
**  RETURN  BNOERRMESSAGE    Error description
*]

 BNOERRMESSAGE=BNOERRUNDEFINED
 BNOERRCODE=BNOERRORCODE
 BNOERRTMPCOUNT=1
 WHILE BNOERRTMPCOUNT<=BNOERRCOUNT AND 
       BNOERRMESSAGE=BNOERRUNDEFINED
  DO
   IF BNOERRCODES(BNOERRTMPCOUNT)=BNOERRORCODE THEN
    DO
     BNOERRMESSAGE=BNOERRMESSAGES(BNOERRTMPCOUNT)
     BNOERRDISPLAYMSGCOUNT=BNOERRDISPLAYMSGSCOUNT(BNOERRTMPCOUNT)
     FOR BNOERRTMPCOUNT2=1 TO BNOERRDISPLAYMSGCOUNT
      DO
       BNOERRDISPLAYMSG(BNOERRTMPCOUNT2)=BNOERRDISPLAYMSGS(BNOERRTMPCOUNT,BNOERRTMPCOUNT2)
      END
    END 
   BNOERRTMPCOUNT=BNOERRTMPCOUNT+1
  END
END [PROCEDURE]

PROCEDURE BNOPRINTPROGRAMINFO
[* Print program info to direct JSON output
**
**  PASS    BNOPROGRAMNAME     Program name
**  PASS    BNOPROGRAMVERSION  Program version
**  PASS    BNOLASTMODDATE     Last mod date
**  PASS    BNOLASTMODTIME     Last mod time
*]

 PRINT ","
 JSONPROPNAME="programInfo"
 CALL JSONPROP
 PRINT QQ+BNOPROGRAMNAME+"  "+
          BNOPROGRAMVERSION+"  "+
          FORMAT("99/99/99 ",BNOLASTMODDATE)+
          BNOLASTMODTIME+QQ
 NEWLINE
END [PROCEDURE]

PROCEDURE BNOPRINTRGDATA
[* Print @RGUSER[CHR,NUM] data passed from the UX in proper JSON format
**
**  PASS    DEBUGMODE        Boolean: Print debug data, T/F
*]
 IF BNODEBUGMODE=BNODEBUGMODEON THEN
  DO
   PRINT ","
   NEWLINE
   PRINT "  "+Q+"rgData"+Q+": ["
   NEWLINE
   PRINT "    "+Q+"@RGSTATE: "+@RGSTATE+"  "+
              "CHR1:"+@RGUSERCHR1+"  "+
              "CHR2:"+@RGUSERCHR2+Q+","
   NEWLINE
   PRINT "    "+Q+"CHR3:"+@RGUSERCHR3+" "+
                  "CHR4:"+@RGUSERCHR4+Q+","

   NEWLINE
   PRINT "    "+Q+"CHR5:"+@RGUSERCHR5+" "+
                  "NUM1:"+FORMAT("#########9 ",@RGUSERNUM1)+
                  "NUM2:"+FORMAT("#########9 ",@RGUSERNUM2)+
                  "NUM3:"+FORMAT("#########9 ",@RGUSERNUM3)+
                  "NUM4:"+FORMAT("#########9 ",@RGUSERNUM4)+
                  "NUM5:"+FORMAT("#########9",@RGUSERNUM5)+Q
   NEWLINE
   PRINT "  ]"
   NEWLINE
  END
END [PROCEDURE]

PROCEDURE BNOPRINTDEBUG
[* Add debug messages to JSON output
**  PASS    DEBUGMODE  Boolean - is debug mode on
**  PASS    BNODEBUGCOUNT  Number of debut lines to send to JSON output
**  RETURN  BNODEBUGMSGLIST  debug output
*]
 IF BNODEBUGMODE=BNODEBUGMODEON THEN
  DO
   FOR BNODEBUGLOOP=1 TO BNODEBUGCOUNT
    DO

     IF BNODEBUGLOOP=1 THEN
      DO
       PRINT ","
       NEWLINE

       PRINT "    "+Q+"debugData"+Q+": ["
       NEWLINE
      END

     PRINT "    "+Q+BNODEBUGMSGLIST(BNODEBUGLOOP)+Q
     IF BNODEBUGLOOP<BNODEBUGCOUNT THEN
      PRINT ","
     NEWLINE
    END
   PRINT "    ]"
   NEWLINE
  END
END [PROCEDURE]

PROCEDURE BNODEBUGMSGADD
[* Add debug line output to array for later display in JSON output
**  PASS    BNODEBUGMSG  Line of debug output
**  RETURN  BNODEBUGMSGLIST  Array of debug messages to display
**  RETURN  BNODEBUGCOUNT  number of debug lines to display
**
*]
 IF BNODEBUGCOUNT<BNODEBUGMSGMAX THEN
  DO
   BNODEBUGCOUNT=BNODEBUGCOUNT+1
   BNODEBUGMSGLIST(BNODEBUGCOUNT)=BNODEBUGMSG
   BNODEBUGMSG=""
  END
END [PROCEDURE]

[*
**  --------------------------------------------------------------------
**  JSON Procedures
**  --------------------------------------------------------------------
*]

PROCEDURE JSONINVALIDACCT

 CALL BNOERRGET

 JSONPROPNAME="errorCode"
 CALL JSONPROP
 PRINT FORMAT("999",BNOERRCODE)
 NEWLINE

 PRINT ","
 JSONPROPNAME="loggingErrorMessage"
 CALL JSONPROP
 PRINT QQ+BNOERRMESSAGE+QQ
 NEWLINE

 IF BNOERRDISPLAYMSGCOUNT>0 THEN
  DO
   PRINT ","
   JSONPROPNAME="displayErrorMessage"
   CALL JSONPROP

   CALL JSONARRAY
   FOR TMPLOOP=1 TO BNOERRDISPLAYMSGCOUNT
    DO
     TMPCHR=BNOERRDISPLAYMSG(TMPLOOP)
     CALL NTS
     PRINT Q+TMPCHR+Q
     IF TMPLOOP<BNOERRDISPLAYMSGCOUNT THEN
      PRINT ","
     NEWLINE
    END
   CALL JSONARRAYEND
  END
END [PROCEDURE]

PROCEDURE JSONVALIDACCT
[* Set the return JSON code for a valid account
*]

 JSONPROPNAME="results"
 CALL JSONPROP
 CALL JSONOBJ
 NEWLINE

 JSONPROPNAME="eligible"
 CALL JSONPROP
 PRINT JSONBOOLEAN(TRUE)
 NEWLINE

 PRINT ","
 JSONPROPNAME="memberAccountNumber"
 CALL JSONPROP
 PRINT Q+@RGUSERCHR1+Q
 NEWLINE

 PRINT ","
 JSONPROPNAME="shareLoanDescription"
 CALL JSONPROP
 PRINT Q+SLDESCRIPTION+Q
 NEWLINE

 PRINT ","
 JSONPROPNAME="available"
 CALL JSONPROP
 PRINT Q+SLAVAILABLEBALCHR+Q
 NEWLINE

 TMPCHR=FORMAT("########9.99",PARAMMINWDLIMIT)
 CALL NLTS
 PRINT ","
 JSONPROPNAME="minWdAmount"
 CALL JSONPROP
 PRINT Q+TMPCHR+Q
 NEWLINE

 TMPCHR=FORMAT("########9.99",PARAMMAXWDLIMIT)
 CALL NLTS
 PRINT ","
 JSONPROPNAME="maxWdAmount"
 CALL JSONPROP
 PRINT Q+TMPCHR+Q
 NEWLINE

 PRINT ","
 JSONPROPNAME="owner"
 CALL JSONPROP
 PRINT Q+NAME:LONGNAME+Q
 NEWLINE

 PRINT ","
 JSONPROPNAME="address"
 CALL JSONPROP
 NEWLINE
 CALL JSONARRAY
 TMPCHR=ACCOUNT:PAYEELINE:1
 CALL NLTS
 PRINT Q+TMPCHR+Q+","
 NEWLINE
 TMPCHR=ACCOUNT:PAYEELINE:2
 CALL NLTS
 PRINT Q+TMPCHR+Q+","
 NEWLINE
 TMPCHR=ACCOUNT:PAYEELINE:3
 CALL NLTS
 PRINT Q+TMPCHR+Q+","
 NEWLINE
 TMPCHR=ACCOUNT:PAYEELINE:4
 CALL NLTS
 PRINT Q+TMPCHR+Q+","
 NEWLINE
 TMPCHR=ACCOUNT:PAYEELINE:5
 CALL NLTS
 PRINT Q+TMPCHR+Q+","
 NEWLINE
 TMPCHR=ACCOUNT:PAYEELINE:6
 CALL NLTS
 PRINT Q+TMPCHR+Q+""
 NEWLINE
 CALL JSONARRAYEND [end address array]

 PRINT ","
 JSONPROPNAME="disclaimerText"
 CALL JSONPROP
 NEWLINE
 CALL JSONARRAY
 FOR TMPLOOP=1 TO PARAMCUSTOMTERMLINES
  DO
   TMPCHR=PARAMCUSTOMTERMS(TMPLOOP)
   CALL NTS
   PRINT Q+TMPCHR+Q
   IF TMPLOOP<PARAMCUSTOMTERMLINES THEN
    PRINT ","
   NEWLINE
  END
 CALL JSONARRAYEND [end disclaimerText array]
 
 CALL JSONOBJEND [results object]
END [PROCEDURE]

PROCEDURE JSONTRANSUCCESS

 JSONPROPNAME="results"
 CALL JSONPROP
 CALL JSONOBJ
 NEWLINE

 JSONPROPNAME="success"
 CALL JSONPROP
 PRINT JSONBOOLEAN(TRUE)
 NEWLINE

 PRINT ","
 JSONPROPNAME="memoMode"
 CALL JSONPROP
 PRINT JSONBOOLEAN(SYSMEMOMODE)
 NEWLINE

 CALL JSONOBJEND [results object]
END [PROCEDURE]

PROCEDURE JSONTRANFAILED

 CALL BNOERRGET

 JSONPROPNAME="errorCode"
 CALL JSONPROP
 PRINT FORMAT("999",BNOERRCODE)
 NEWLINE

 PRINT ","
 JSONPROPNAME="loggingErrorMessage"
 CALL JSONPROP
 PRINT QQ+BNOERRMESSAGE+QQ
 NEWLINE

 IF BNOERRDISPLAYMSGCOUNT>0 THEN
  DO
   PRINT ","
   JSONPROPNAME="displayErrorMessage"
   CALL JSONPROP

   CALL JSONARRAY
   FOR TMPLOOP=1 TO BNOERRDISPLAYMSGCOUNT
    DO
     TMPCHR=BNOERRDISPLAYMSG(TMPLOOP)
     CALL NTS
     PRINT Q+TMPCHR+Q
     IF TMPLOOP<BNOERRDISPLAYMSGCOUNT THEN
      PRINT ","
     NEWLINE
    END
   CALL JSONARRAYEND
  END

 IF TRANSTATUS=TRANLIMITS AND
    BNOERRCODE=BNOERRCODEINVALIDAMT THEN
  DO
   PRINT ","
   TMPCHR=FORMAT(" ###,##9.99",RGWDAMOUNT)
   CALL NLS
   JSONPROPNAME="requested"
   CALL JSONPROP
   PRINT Q+TMPCHR+Q
   NEWLINE

   PRINT ","
   TMPCHR=FORMAT(" ###,##9.99",PARAMMINWDLIMIT)
   CALL NLS
   JSONPROPNAME="minWdAmount"
   CALL JSONPROP
   PRINT Q+TMPCHR+Q
   NEWLINE

   PRINT ","
   TMPCHR=FORMAT(" ###,##9.99",PARAMMAXWDLIMIT)
   CALL NLS
   JSONPROPNAME="maxWdAmount"
   CALL JSONPROP
   PRINT Q+TMPCHR+Q
   NEWLINE
  END 
END [PROCEDURE]

[*
**  --------------------------------------------------------------------
**  JSON Procedures - Common
**  --------------------------------------------------------------------
*]
PROCEDURE JSONOPEN
[* Print JSON open char
*]
 PRINT "{"
 NEWLINE
END [PROCEDURE]

PROCEDURE JSONCLOSE
[* Print JSON close char
*]
 PRINT "}"
 NEWLINE
END [PROCEDURE]

PROCEDURE JSONOBJ

 PRINT "{"
END [PROCEDURE]

PROCEDURE JSONOBJEND

 PRINT "}"
 NEWLINE
END [PROCEDURE]

PROCEDURE JSONARRAY

 PRINT "["
END [PROCEDURE]

PROCEDURE JSONARRAYEND

 PRINT "]"
 NEWLINE
END [PROCEDURE]

PROCEDURE JSONPROP

 PRINT QQ+JSONPROPNAME+QQ+":"
END [PROCEDURE]

[*
**  --------------------------------------------------------------------
**  Utility Procedures
**  --------------------------------------------------------------------
*]

PROCEDURE NORMALIZEDATA
[* Normalize the data and if a parameter, separate into
** parameter name and value
** PASS    LFLINE          Character line read in
** RETURN  PARAMNAME       Parameter name found
** RETURN  PARAMVALUE      Parameter value
**
*]
 PARAMNAME=""
 PARAMVALUE=""

 POS=CHARACTERSEARCH(LFLINE,":")
 IF LFLINE<>"" AND
    SEGMENT(LFLINE,1,1)<>"*" AND
    POS>1 THEN
  DO
   TMPCHR=SEGMENT(LFLINE,1,POS-1)
   CALL NLTS
   PARAMNAME=UPPERCASE(TMPCHR)

   TMPCHR=SEGMENT(LFLINE,POS+1,LENGTH(LFLINE))
   CALL NLTS
   PARAMVALUE=TMPCHR
  END
END [PROCEDURE]

PROCEDURE NLTS
[* Remove leading AND trailing spaces
**  PASS       TMPCHR
**  RETURN     TMPCHR
*]
 CALL NLS
 IF TMPCHR<>"" THEN
  CALL NTS
END [PROCEDURE]

PROCEDURE NLS
[* Remove leading spaces
**  PASS       TMPCHR
**  RETURN     TMPCHR
*]
 WHILE (LENGTH(TMPCHR)>0 AND
        SEGMENT(TMPCHR,1,1)=" ")
  DO
   IF LENGTH(TMPCHR)=1 THEN
    TMPCHR=""
   ELSE
    TMPCHR=SEGMENT(TMPCHR,2,LENGTH(TMPCHR))
  END
 IF LENGTH(TMPCHR)=0 THEN
  TMPCHR=""
END [PROCEDURE]

PROCEDURE NTS
[* Remove trailing spaces
**  PASS       TMPCHR
**  RETURN     TMPCHR
*]
 IF TMPCHR<>"" THEN
  TMPCHR=SEGMENT(TMPCHR,1,LENGTH(TMPCHR))
 IF LENGTH(TMPCHR)=0 THEN
  TMPCHR=""

END [PROCEDURE]

PROCEDURE CLEANUPTEXT
[* Check character string and remove out any characters or hidden
** characters which have an ASCII value which is not established in
** the VALIDCHRINPUT1 string in the SETUP division . This is to avoid
** display issues with displaying the terms or conditions. Additionally,
** if a back-slash or double quote is encountered, add a preceding
** backslash
**  PASS       TMPCHR   String to test
**  RETURN     TMPCHR   Updated string
*]
 LELISTINPUT=VALIDCHRINPUT1
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO MAXCHRVALUE
  DO
   VALIDCHARS(TMPLOOP)=LELIST(TMPLOOP)
  END
 TMPTEXT=""

 IF TMPCHR<>"" THEN
  DO
   FOR TMPTEXTLOOP=1 TO LENGTH(TMPCHR)
    DO
     CHRVAL=CHRVALUE(SEGMENT(TMPCHR,TMPTEXTLOOP,TMPTEXTLOOP))
     IF  VALIDCHARS(CHRVAL)=TRUE THEN
      DO
[* Check for back-slash or double-quote. If found, precede with a back-slash
*]
       IF (CHRVAL=92 OR CHRVAL=34) THEN
        TMPTEXT=TMPTEXT+BACKSLASH+SEGMENT(TMPCHR,TMPTEXTLOOP,TMPTEXTLOOP)
       ELSE
        TMPTEXT=TMPTEXT+SEGMENT(TMPCHR,TMPTEXTLOOP,TMPTEXTLOOP)
      END
    END
  END
 TMPCHR=TMPTEXT
END [PROCEDURE]

#INCLUDE "RB.LISTEXPAND"
