[*  Copyright 2025-2026 Jack Henry and Associates
**
**  PowerOn Name:                     BANNO.LOAN.PAYOFF.V2.POW
**  Configuration Letterfile Name:    BANNO.LOAN.PAYOFF.V2.CFG
**  Fee Display PowerOn Name:         BANNO.LOAN.PAYOFF.FEES.POW (template)
**
**  --------------------------------------------------------------------
**  Program Summary
**  --------------------------------------------------------------------
**  This Banno service PowerOn allows the user to request a loan
**  payoff for an entered date.
**
**  --------------------------------------------------------------------
**  Program states and JSON returns
**  --------------------------------------------------------------------
**    STATE:  GETPRELOADDATA
**  PROCESS:  Process GETPRELOADDATA state and create json response
**     PASS:  @RGUSERCHR1 10-character member number/account number
**            @RGUSERNUM1 ????
**   RETURN:  Provides UX GETPRELOADDATA response
**
**    STATE:  PERFORMLOANPAYOFFCALC
**  PROCESS:  Process PERFORMLOANPAYOFFCALC state and create json response
**     PASS:  @RGUSERCHR1 10-character member number/account number
**            @RGUSERCHR2 Payoff date in yyyy-mm-dd format
**            @RGUSERNUM1 ????
**   RETURN:  Provides UX PERFORMLOANPAYOFFCALC response
**
**  --------------------------------------------------------------------
**  Error codes and Logging Messages
**  --------------------------------------------------------------------
**  500: Config file open/read error
**  501: Config file validation error
**  502: Duplicate loan type in CFG
**  503: Ineligible Loan Type
**  504: Account Warning Found
**  505: Loan Warning Found
**  506: Loan Projection Error
**  507: Fee Specfile Error
**  508: Payoff date too many days in the future
**  509: Invalid
**
**  --------------------------------------------------------------------
**  Additional Information
**  --------------------------------------------------------------------
**
**  For more information check
**  https://github.com/Banno/banno-powerons
**
**  Banno is not responsible for any modifications to this file
**  made by unauthorized personnel.
**
**  DO NOT MODIFY THIS FILE UNLESS YOU KNOW WHAT YOU'RE DOING!
**
**  --------------------------------------------------------------------
**  Modification History
**    Ver. 2.0.0  12/26/2025 R. Robison: Original V2 version of loan payoff PO
**                           Feature set based on: BANNO.LOAN.PAYOFF.V1.POW Ver. 1.1.1  06/19/24
**    Ver. 2.0.1  01/02/2026 R. Robison: Fix spanish collateral labels
**                           Add Spanish support collateral categories (boat, vehicle, etc)
**                           Add Spanish support for interest type descriptions
**    
*]
SYMCONNECT
STATELESS

TARGET=ACCOUNT

DEFINE
 #INCLUDE "RD.GETDATA.DEF"
 #INCLUDE "RB.LISTEXPAND.DEF"

 BNOLASTMODDATE            = '01/02/26'
 BNOLASTMODTIME            = "10:00 MT"
 BNOPROGRAMNAME            = "BANNO.LOAN.PAYOFF.V2.POW"
 BNOCFGFILENAME            = "BANNO.LOAN.PAYOFF.V2.CFG"
 BNOPROGRAMVERSION         = "2.0.1"
 BNOPROGRAMNOTE1           = "Fix collateral labels for spanish"
 BNOPROGRAMNOTE2           = "Other fixes"

 BNODEBUGPRINTINFODAYS     = 60
 BNODEBUGINCLUDEPARAMS     = 1

 STATEGETPRELOADDATA       = "GETPRELOADDATA"
 STATEPERFORMCALC          = "PERFORMLOANPAYOFFCALC"

[* Error code setup
*]
 BNOERRCODECONFIGREAD      = 500
  BNOERRMODOPEN            = "[configuration file name] open error - [system generated letter file read error message]"
  BNOERRMODREAD            = "[configuration file name] read error - [system generated letter file read error message]"
 BNOERRCODECONFIGVALIDATE  = 501
  BNOERRMODDUPLICATEPARAM  = "Duplicate Param file entry([parameter name])"
  BNOERRMODINVALIDVALUE    = "Invalid Param Value([parameter name])"
 BNOERRCODEDUPLOANTYPE     = 502
  BNOERRMODDUPLOANTYPE     = "Loan Type [4-digit loan type] ([parameter name]))"
 BNOERRCODEINELIGLOANTYPE  = 503
  BNOERRMODINELIGLOANTYPE  = "[4-digit loan type]"
 BNOERRCODEACCTWARNING     = 504
  BNOERRMODACCTWARNING     = "[3-digit comma separated account warning list]"
 BNOERRCODELOANWARNING     = 505
  BNOERRMODLOANWARNING     = "[3-digit comma separated loan warning list]"
 BNOERRCODELOANPROJECT     = 506
  BNOERRMODLOANPROJECT     = "[system generated PowerOn function LOANPROJECTCALC error message]"
 BNOERRCODEFEESPECFILE     = 507
  BNOERRMODFEESPECFILE     = "[Banno loan payoff fees PowerOn generated error message]"
 BNOERRCODEBADPAYOFFDATE   = 508
 BNOERRCODEINVALID         = 509

[* RGUSER Pass variables - passed from UX code
*]
 RGLANGUAGE=NUMBER
 RGMEMBERNUMBER=CHARACTER(10)
 RGSLID=CHARACTER
 RGPAYOFFDATE=DATE

[* Main PowerOn variables and data structures for json
*]
 INVALIDWARNLIST=CHARACTER
 LOANFOUND=NUMBER
 FOUND=NUMBER
 LOANELIGIBLE=NUMBER
 CTLLABEL=CHARACTER
 CTLINFOCOUNT=NUMBER
 CTLINFO=CHARACTER ARRAY(10)
 CTLINFOLABEL=CHARACTER ARRAY(10)
 CTLINFOMAX=10
 ADDCTLINFO=CHARACTER
 ADDCTLINFOLABEL=CHARACTER
 BOATUSERCHAR=CHARACTER
 VEHLOANFLD=CHARACTER
 COLLATERALFIELDDATA=CHARACTER
 CURRENTFIELD=NUMBER

 USERNUMBER=NUMBER
 USERCHAR=CHARACTER
 USERDATE=DATE
 USERRATE=RATE
 USERCODE=NUMBER
 USERAMOUNT=MONEY

 PAYOFFCALCAMOUNT=MONEY
 PAYOFFCALCPRINCIPALBAL=MONEY
 PAYOFFCALCINTERESTTYPE=CHARACTER
 PAYOFFCALCINTRATE=RATE
 PAYOFFCALCINTERESTDUE=MONEY
 PAYOFFCALCDUEDATE=DATE
 PAYOFFCALCAMTPASTDUE=MONEY
 PAYOFFCALCPASTDUECOUNT=NUMBER
 PAYOFFCALCLATECHARGEDUE=MONEY
 PAYOFFCALCLOANCODE=NUMBER

[* SUBROUTINE fee specfile
*]
 PAYOFFFEESPECFILEERROR=CHARACTER
 PAYOFFFEEAMT=MONEY ARRAY(10)
 PAYOFFFEEDESC=CHARACTER ARRAY(10)
 PAYOFFFEECOUNT=NUMBER
 PAYOFFFEEAMTTOTAL=MONEY
 PAYOFFFEEMAX=10
 ADDFEEAMT=MONEY
 ADDFEEDESC=CHARACTER

[* CFG Parameter variables specific to this PowerOn
*]
 PARAMELIGLOANTYPELIST=CHARACTER
 PARAMELIGLOANTYPES=NUMBER ARRAY(9999)
 PARAMHLT="HLT"
 PARAMHOMELOANTYPELIST=CHARACTER
 PARAMHOMELOANTYPES=NUMBER ARRAY(9999)
 PARAMBLT="BLT"
 PARAMBOATLOANTYPELIST=CHARACTER
 PARAMBOATLOANTYPES=NUMBER ARRAY(9999)
 PARAMVLT="VLT"
 PARAMVEHLOANTYPELIST=CHARACTER
 PARAMVEHLOANTYPES=NUMBER ARRAY(9999)
 PARAMSLT="SLT"
 PARAMSECUREDLOANTYPELIST=CHARACTER
 PARAMSECUREDLOANTYPES=NUMBER ARRAY(9999)

 PARAMLOANWARNLIST=CHARACTER
 PARAMLOANWARNCODES=NUMBER ARRAY(99)
 PARAMACCTWARNLIST=CHARACTER
 PARAMACTTWARNCODES=NUMBER ARRAY(99)

 PARAMPAYOFFFEESFNAME=CHARACTER
 PARAMFUTUREDAYSMAX=NUMBER
 PARAMBOATLOANTT=NUMBER
 PARAMBOATLOANTFLD=CHARACTER
 PARAMVEHLOANTT=NUMBER
 PARAMVEHLOANTFLD=CHARACTER ARRAY(3)
 PARAMVEHLOANTLBL=CHARACTER ARRAY(3,2)
 PARAMVEHCTLCOUNT=NUMBER
 PARAMVEHCTLMAX=3

 PARAMHOMECTLDESC=CHARACTER ARRAY(2)
 PARAMBOATCTLDESC=CHARACTER ARRAY(2)
 PARAMSECUREDCTLDESC=CHARACTER ARRAY(2)
 PARAMVEHCTLDESC=CHARACTER ARRAY(2)

 PARAMINTTYPEDESC=CHARACTER ARRAY(8,2)
 PARAMINTTYPEMAX=8

[* CFG Parameter variables -- common
*]
 PARAMLANGSPANISH=NUMBER
 PARAMDEBUGMODE=NUMBER
 PARAMTESTMODE=NUMBER
 PARAMTESTEC=NUMBER
 PARAMPROGINSTALLDATE=DATE

[* CFG Parameter variables for soft text messages
*]
 PARAMMSGTAGSMAX=20
 PARAMMSGTAGSCOUNT=NUMBER
 PARAMMSGTAG=CHARACTER
 PARAMMSGPROP=CHARACTER
 PARAMMSGOPT=NUMBER
 PARAMMSGMAXLINES=NUMBER
 PARAMMSGTAGLANG=NUMBER

 PARAMMSGTAGS=CHARACTER ARRAY(20)
 PARAMMSGPROPS=CHARACTER ARRAY(20)
 PARAMMSGOPTIONAL=NUMBER ARRAY(20)
 PARAMMSGDEFINED=NUMBER ARRAY(20)
 PARAMMSGMAX=NUMBER ARRAY(20)
 PARAMMSGALLMAX=800
 PARAMMSGALL=CHARACTER ARRAY(800)
 PARAMMSGALLTAGS=CHARACTER ARRAY(800)
 PARAMMSGALLTAGSLANG=NUMBER ARRAY(800)
 PARAMMSGTAGNONE=0
 PARAMMSGTAGENGLISH=1
 PARAMMSGTAGSPANISH=2
 PARAMMSGTAGENGLISHSFX="_EN"
 PARAMMSGTAGSPANISHSFX="_SP"
 PARAMMSGALLCOUNT=NUMBER
 PARAMMSGTAGFOUND=NUMBER
 PARAMMSGTAGINDEX=NUMBER
 PARAMMSGALLINDEX=NUMBER
 PARAMMSGDEFAULTMAX=20 [each message can be up to 20 lines long by default]

[* CFG Parameter variables for errorDisplayMessages (EDM)
*] 
 PARAMERRDISPLAYMAX=200
 PARAMERRDISPLAYERRCODES=NUMBER ARRAY(200)
 PARAMERRDISPLAYLINES=CHARACTER ARRAY(200)
 PARAMERRDISPLAYLANG=NUMBER ARRAY(200)
 PARAMERRDISPLAYCOUNT=NUMBER
 PARAMERRDISPLAYINDEX=NUMBER

[* CFG Parameter processing - general
*]
 BNOCFGPARAMMAX=200
 BNOCFGPARAMCOUNT=NUMBER
 BNOCFGPARAM=CHARACTER ARRAY(200)
 BNOCFGPARAMVAL=CHARACTER ARRAY(200)
 BNOCFGFILENUMBER=NUMBER
 BNOCFGFILEFERROR=CHARACTER
 BNOCFGFILELINE=CHARACTER
 BNOCFGPARAMALLOWDUPS=NUMBER

 BNOPARAMFOUND=NUMBER
 BNOPARAMFOUNDINDEX=NUMBER
 BNOPARAMFIND=CHARACTER
 BNOPARAMVAL=CHARACTER
 BNOPARAMTMP=CHARACTER
 BNOPARAMVALTMP=CHARACTER
 BNOPARAMLOOP=NUMBER

[* Debug handling variables
*]
 BNODEBUGMSGMAX=999
 BNODEBUGMSGLIST=CHARACTER ARRAY(999)
 BNODEBUGLOOP=NUMBER
 BNODEBUGCOUNT=NUMBER
 BNODEBUGMSG=CHARACTER
 BNODEBUGMODE=NUMBER

[* Error handling variables
*]
 BNOERRMAX=99
 BNOERRCODE=NUMBER
 BNOERRMESSAGE=CHARACTER
 BNOERRMODIFIER=CHARACTER
 BNOERRCOUNT=NUMBER
 BNOERRTMPCOUNT=NUMBER
 BNOERRTMPCOUNT2=NUMBER
 BNOERRDISPLAYLIST=CHARACTER
 BNOERRDISPLAYCODE=NUMBER
 BNOERRFOUND=NUMBER
 BNOERRCODES=NUMBER ARRAY(99)
 BNOERRMESSAGES=CHARACTER ARRAY(99)
 BNOERRUNDEFINED="**Undefined**"

 BNOERRDISPLAYMSGSMAX=5
 BNOERRDISPLAYMSG=CHARACTER ARRAY(5)
 BNOERRDISPLAYMSGCOUNT=NUMBER
 BNOERRDISPLAYLINE=CHARACTER

[* Misc. Variables
*]
 BNOTEXT=CHARACTER
 BNOAMT=MONEY
 BNORATE=RATE
 BNOTMPLOOP=NUMBER
 BNOPOS=NUMBER 
 BNOERRORCODE=NUMBER
 BNOERRORMODIFIER=CHARACTER
 BNOIDLENGTH=NUMBER
 BNOSLTYPELENGTH=NUMBER

 JSONBOOLEAN=CHARACTER ARRAY(1)
 JSONPROPNAME=CHARACTER
 JSONOBJFIRSTPROP=NUMBER

 TMPLOOP=NUMBER
 TMPLOOP2=NUMBER
 TMPCHR=CHARACTER
 QQ=CHARACTER
 TMPERRCODE=NUMBER
 TMPDISPLAYLINE=CHARACTER
 CHRVAL=NUMBER
 TMPLINECOUNT=NUMBER
 LINECOUNT=NUMBER
 MSGTAGSELECTED=NUMBER
 MSGPROPSELECT=CHARACTER
 MSGPROPSELECTLIST=CHARACTER
 TAGSFXPOS=NUMBER
 TMPINDEX=NUMBER
 USELANGUAGE=NUMBER
 
 SYMXINSTANCE=NUMBER
 SYMXCLIENTNUM=NUMBER

[* BNOPARSEDATALINE variables
*]
 BNODATALINE=CHARACTER
 BNODLINDEX=NUMBER
 BNODLFIELDCOUNT=NUMBER
 BNODLFIELD=CHARACTER ARRAY(99)
 BNODLFIELDMAX=99
 BNODLPOS=NUMBER
 BNODLDELIMITER=CHARACTER

[* BNOCLEANUP variables
*]
 BNOCLEANLOOP=NUMBER
 BNOCLEANVALIDCHRLIST="32-126,128-175,181-184,189,190,198,199,208-216,221,222,224-253"
 BNOCLEANVALIDCHRS=NUMBER ARRAY(255)
 BNOCLEANVALIDCHRMAX=255

[* Replace variables
*]
 TRUE=1
 FALSE=0
 DATENULL='--/--/--'
 BNODEBUGMODEOFF=0
 BNODEBUGMODEON=1
 BNODEBUGMODEUNDEFINED=9999

 LOANTYPESMAX=9999
 WARNINGCODESMAX=99
 PLEDGETYPESHARESECURED=0
 NAMETYPEPROPERTYADDRESS=29

 CHRVALQUOTE=34
 CHRVALBACKSLASH=92
END [DEFINE]

SETUP
 CALL BNOERRINIT

[* Register supported error messages
*] 
 BNOERRCODE=BNOERRCODECONFIGREAD          BNOERRMESSAGE="Config file open/read error"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODECONFIGVALIDATE      BNOERRMESSAGE="Config file validation error"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEDUPLOANTYPE         BNOERRMESSAGE="Duplicate loan type in CFG"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEINELIGLOANTYPE      BNOERRMESSAGE="Ineligible Loan Type"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEACCTWARNING         BNOERRMESSAGE="Account Warning Found"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODELOANWARNING         BNOERRMESSAGE="Loan Warning Found"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODELOANPROJECT         BNOERRMESSAGE="Loan Projection Error"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEFEESPECFILE         BNOERRMESSAGE="Fee Specfile Error"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEBADPAYOFFDATE       BNOERRMESSAGE="Payoff date too many days in the future"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEINVALID             BNOERRMESSAGE="Invalid"
 CALL BNOERRADD

 [* Set any errors that support display messages
 *]
 [BNOERRDISPLAYCODE=BNOERRCODEMEMOMODE
 CALL BNOERRDISPLAYLISTADD]

[* This is where you define all the soft text CFG tags and json properties
**  - Optionally set PARAMMSGMAXLINES to override the default of 20 lines per message
**  - Optionally set PARAMMSGOPT to mark a message as optional. Message will not be returned in
**    json response if no message lines found in the CFG.
*]
 CALL PARAMMSGINIT

 PARAMMSGTAG="TC"     PARAMMSGPROP="disclaimerText"     [Disclaimer Text Message]
 PARAMMSGMAXLINES=40
 CALL PARAMMSGTAGADD

 PARAMMSGTAG="CS"     PARAMMSGPROP="summaryText"        [Summary Text Message]
 PARAMMSGMAXLINES=40
 PARAMMSGOPT=TRUE
 CALL PARAMMSGTAGADD

 CALL SETUPDATA
END [SETUP]

PRINT TITLE=BNOPROGRAMNAME

 CALL INITIALIZEDATA
 CALL GETRGDATA

 CALL BNOCFGFILEREAD

 IF BNOERRORCODE=0 THEN
  CALL BNOSETPARAMVALS

 IF BNOERRORCODE=0 THEN
  CALL PARAMPOSTPROCESS

 CALL GETUSELANGUAGE

 IF BNOERRORCODE=0 AND
    PARAMTESTMODE=TRUE THEN
  BNOERRORCODE=PARAMTESTEC

 IF BNOERRORCODE=0 AND PARAMTESTMODE=FALSE THEN
  DO
   IF @RGSTATE=STATEGETPRELOADDATA THEN
    CALL VALIDATEPAYOFFDATA
   ELSE IF @RGSTATE=STATEPERFORMCALC THEN
    DO
     CALL VALIDATEPAYOFFDATA
     IF BNOERRORCODE=0 THEN
      CALL CALCULATEPAYOFF
     IF BNOERRORCODE=0 THEN
      CALL GETCOLLATERAL 
    END  
  END  

[* Output JSON 
*]
 CALL JSONOPEN
 
 IF @RGSTATE=STATEGETPRELOADDATA THEN
  DO
   IF BNOERRORCODE=0 THEN
    CALL JSONSUCCESSPRELOADDATA
   ELSE 
    CALL JSONERROR
  END
 ELSE IF @RGSTATE=STATEPERFORMCALC THEN
  DO
   IF BNOERRORCODE=0 THEN
    CALL JSONSUCCESSPERFORMCALC
   ELSE 
    CALL JSONERROR
  END 

 CALL BNOCFGDEBUGADD
 CALL BNOJSONRGDATA
 CALL BNOJSONDEBUGDATA
 IF BNODEBUGMODE=BNODEBUGMODEOFF THEN
  NEWLINE
 
 CALL JSONCLOSE
END [PRINT]

PROCEDURE SETUPDATA
[* Set the SETUP data constants
*]
 JSONBOOLEAN(TRUE)="true"
 JSONBOOLEAN(FALSE)="false"
 
[* This is the default state of debug mode.  This may be overridden if the Program Install Date (PID)
** is set in the CFG configuration file.
*] 
 IF BNOLASTMODDATE+BNODEBUGPRINTINFODAYS>SYSTEMDATE THEN
  BNODEBUGMODE=BNODEBUGMODEON
 ELSE 
  BNODEBUGMODE=BNODEBUGMODEOFF 

 SYMXINSTANCE=@SYMXINSTANCEID
 SYMXCLIENTNUM=@CLIENTNUMBER
 BNOIDLENGTH=GETDATANUMBER(GETPARAMIDLENGTH)
 BNOSLTYPELENGTH=GETDATANUMBER(GETPARAMTYPELENGTH)

 QQ=CTRLCHR(CHRVALQUOTE)
 CALL BNOCLEANUPINIT
END [PROCEDURE]

PROCEDURE INITIALIZEDATA
[* Initialize variables
*]

 BNOERRORCODE=0
 BNOERRORMODIFIER=""
 BNOCFGPARAMALLOWDUPS=FALSE
 JSONOBJFIRSTPROP=TRUE
 BNODLDELIMITER=""
 MSGPROPSELECTLIST=""
 CTLLABEL=""
 CTLINFOCOUNT=0
END [PROCEDURE]

PROCEDURE GETRGDATA
[* Read in the @RG values from the UX, segment them into their individual
** values.
*]
 RGLANGUAGE=@RGSESSION
 RGMEMBERNUMBER=SEGMENT(@RGUSERCHR1,1,10)
 RGSLID=SEGMENT(@RGUSERCHR1,12,LENGTH(@RGUSERCHR1))
 RGSLID="0000"+RGSLID
 RGSLID=SEGMENT(RGSLID,(LENGTH(RGSLID)-BNOIDLENGTH)+1,LENGTH(RGSLID))
 IF @RGSTATE=STATEGETPRELOADDATA THEN
  DO
[* Nothing to do here. RGMEMBERNUMBER and RGSLID set for all states
*]  
  END
 ELSE IF @RGSTATE=STATEPERFORMCALC THEN
  DO
   RGPAYOFFDATE=DATEVALUE(@RGUSERCHR2)
  END
END [PROCEDURE]

PROCEDURE VALIDATEPAYOFFDATA

 INVALIDWARNLIST=""

 IF RGPAYOFFDATE>SYSTEMDATE+PARAMFUTUREDAYSMAX THEN
  BNOERRORCODE=BNOERRCODEBADPAYOFFDATE

 IF BNOERRORCODE=0 THEN
  DO
   LOANFOUND=FALSE
   FOR ACCOUNT WITH NUMBER RGMEMBERNUMBER
    DO
[* Check for invalid account warnings
*]    
     TMPLOOP=1
     WHILE TMPLOOP<=WARNINGCODESMAX
      DO
       IF ANYWARNING(ACCOUNT,TMPLOOP) AND
          PARAMACTTWARNCODES(TMPLOOP)=TRUE THEN
        DO
         IF INVALIDWARNLIST<>"" THEN
             INVALIDWARNLIST=INVALIDWARNLIST+","
          INVALIDWARNLIST=INVALIDWARNLIST+FORMAT("999",TMPLOOP)
        END  
       TMPLOOP=TMPLOOP+1
      END

     IF INVALIDWARNLIST<>"" THEN
      DO
       BNOERRORCODE=BNOERRCODEACCTWARNING
       BNOERRORMODIFIER=BNOERRMODACCTWARNING
       BNOERRORMODIFIER=INVALIDWARNLIST
      END 

     IF BNOERRORCODE=0 THEN
      DO
       FOR EACH LOAN WITH (LOAN:ID=RGSLID)
        DO
         LOANFOUND=TRUE
         IF PARAMELIGLOANTYPES(LOAN:TYPE)=FALSE THEN
          DO
           BNOERRORCODE=BNOERRCODEINELIGLOANTYPE
           BNOERRORMODIFIER=BNOERRMODINELIGLOANTYPE
           BNOERRORMODIFIER=FORMAT("9999",LOAN:TYPE)
          END
         
        IF BNOERRORCODE=0 THEN
         DO
          TMPLOOP=1
          WHILE TMPLOOP<=WARNINGCODESMAX
           DO
            IF ANYWARNING(LOAN,TMPLOOP) AND
               PARAMLOANWARNCODES(TMPLOOP)=TRUE THEN
             DO
              IF INVALIDWARNLIST<>"" THEN
               INVALIDWARNLIST=INVALIDWARNLIST+","
              INVALIDWARNLIST=INVALIDWARNLIST+FORMAT("999",TMPLOOP)
             END  
            TMPLOOP=TMPLOOP+1
           END
  
          IF INVALIDWARNLIST<>"" THEN
           DO
            BNOERRORCODE=BNOERRCODELOANWARNING
            BNOERRORMODIFIER=BNOERRMODLOANWARNING
            BNOERRORMODIFIER=INVALIDWARNLIST
           END 
         END
        
        END
       UNTIL LOANFOUND=TRUE 
      END
    END

   IF BNOERRORCODE=0 AND
      LOANFOUND=FALSE THEN
    BNOERRORCODE=BNOERRCODEINVALID
  END
END [PROCEDURE]

PROCEDURE MSGPROPSELECTADD
[* Call before JSONMSGARRAYS to selectively output soft text/message properties.
** This may be multiple times with different MSGPROPSELECT values to select and output
** multiple soft text properties.  JSONMSGARRAYS will output all defined soft text messages
** if this procedure is not called prior to JSONMSGARRAYS.
** Example:
**
**  MSGPROPSELECT="informationMsg"
**  CALL MSGPROPSELECTADD
**  CALL JSONMSGARRAYS
**
**  PASS    MSGPROPSELECT      The json property name for soft text that should be selected
**  
**  RETURN  MSGPROPSELECTLIST  Updated list
*]

 IF MSGPROPSELECTLIST<>"" THEN
  MSGPROPSELECTLIST=MSGPROPSELECTLIST+","
 MSGPROPSELECTLIST=MSGPROPSELECTLIST+MSGPROPSELECT 
END

PROCEDURE CALCULATEPAYOFF

 FOR ACCOUNT RGMEMBERNUMBER
  DO
   CALL GETLOANPAYOFFFEES
   LOANFOUND=FALSE
   FOR EACH LOAN WITH (LOAN:ID=RGSLID)
    DO
     LOANFOUND=TRUE
     PAYOFFCALCDUEDATE=LOAN:DUEDATE
     IF LOAN:LOANCODE=6 THEN
      PAYOFFCALCINTRATE=LOAN:AVGWEIGHTEDINTRATE
     ELSE
      PAYOFFCALCINTRATE=LOAN:INTERESTRATE
     PAYOFFCALCLOANCODE=LOAN:LOANCODE
     
     LOANPROJECTINIT(1,0)
     @LOANPROJECTCALCULATIONTYPE=3
     @LOANPROJECTPAYOFFDATE=RGPAYOFFDATE
   [Handle Member Birthdate insurance calc]
     @LOANPROJECTFIRSTINSBIRTHDATE=LOAN:FIRSTINSBIRTHDATE
     @LOANPROJECTSECONDINSBIRTHDATE=LOAN:SECONDINSBIRTHDATE

     LOANPROJECTCALC
     IF @LOANPROJECTERROR<>"" THEN
      DO
       BNOERRORCODE=BNOERRCODELOANPROJECT
       BNOERRORMODIFIER=BNOERRMODLOANPROJECT
       BNOERRORMODIFIER=@LOANPROJECTERROR
      END
     ELSE IF PAYOFFFEESPECFILEERROR<>"" THEN
      DO
       BNOERRORCODE=BNOERRCODEFEESPECFILE
       BNOERRORMODIFIER=BNOERRMODFEESPECFILE
       BNOERRORMODIFIER=PAYOFFFEESPECFILEERROR
      END
     ELSE
      DO
       PAYOFFCALCPRINCIPALBAL=@LOANPROJECTLOANAMOUNT
       PAYOFFCALCINTERESTDUE=@LOANPROJECTINTERESTPAYOFF
       PAYOFFCALCAMTPASTDUE=@LOANPROJECTAMOUNTPASTDUE
       PAYOFFCALCPASTDUECOUNT=@LOANPROJECTCOUNTPASTDUE
       PAYOFFCALCLATECHARGEDUE=@LOANPROJECTLATECHGDUE
       PAYOFFCALCAMOUNT=@LOANPROJECTAMOUNTPAYOFF
       IF @LOANPROJECTINTERESTTYPE=9 THEN
        PAYOFFCALCINTERESTTYPE="Unknown"
       ELSE IF @LOANPROJECTINTERESTTYPE>9 THEN
        PAYOFFCALCINTERESTTYPE=GETDATACHARACTER(
         GETPARAMINTTYPEDESCRIPTION,@LOANPROJECTINTERESTTYPE)
       ELSE
        PAYOFFCALCINTERESTTYPE=PARAMINTTYPEDESC(@LOANPROJECTINTERESTTYPE,USELANGUAGE)
      END
    END
   UNTIL LOANFOUND=TRUE 
  END
END

PROCEDURE GETLOANPAYOFFFEES

 PAYOFFFEECOUNT=0
 PAYOFFFEEAMTTOTAL=$0.00
 PAYOFFFEESPECFILEERROR=""
 IF PARAMPAYOFFFEESFNAME<>"" THEN
  DO
   INITSUBROUTINE(PAYOFFFEESPECFILEERROR)
   @ENVARGCHAR1=RGMEMBERNUMBER
   @ENVARGCHAR2=RGSLID
   @ENVARGDATE1=RGPAYOFFDATE
   EXECUTE(PARAMPAYOFFFEESFNAME,PAYOFFFEESPECFILEERROR)
   IF PAYOFFFEESPECFILEERROR="" THEN
    DO
     ADDFEEAMT=@ENVARGMONEY1
     ADDFEEDESC=@ENVARGCHAR1
     CALL PAYOFFFEEADD
     ADDFEEAMT=@ENVARGMONEY2
     ADDFEEDESC=@ENVARGCHAR2
     CALL PAYOFFFEEADD
     ADDFEEAMT=@ENVARGMONEY3
     ADDFEEDESC=@ENVARGCHAR3
     CALL PAYOFFFEEADD
     ADDFEEAMT=@ENVARGMONEY4
     ADDFEEDESC=@ENVARGCHAR4
     CALL PAYOFFFEEADD
     ADDFEEAMT=@ENVARGMONEY5
     ADDFEEDESC=@ENVARGCHAR5
     CALL PAYOFFFEEADD
     ADDFEEAMT=@ENVARGMONEY6
     ADDFEEDESC=@ENVARGCHAR6
     CALL PAYOFFFEEADD
     ADDFEEAMT=@ENVARGMONEY7
     ADDFEEDESC=@ENVARGCHAR7
     CALL PAYOFFFEEADD
     ADDFEEAMT=@ENVARGMONEY8
     ADDFEEDESC=@ENVARGCHAR8
     CALL PAYOFFFEEADD
     ADDFEEAMT=@ENVARGMONEY9
     ADDFEEDESC=@ENVARGCHAR9
     CALL PAYOFFFEEADD
     ADDFEEAMT=@ENVARGMONEY10
     ADDFEEDESC=@ENVARGCHAR10
     CALL PAYOFFFEEADD
    END
  END  
END

PROCEDURE PAYOFFFEEADD

 IF PAYOFFFEECOUNT<PAYOFFFEEMAX AND
    ADDFEEAMT<>$0.00 AND 
    ADDFEEDESC<>"" THEN
  DO
   PAYOFFFEECOUNT=PAYOFFFEECOUNT+1
   PAYOFFFEEAMT(PAYOFFFEECOUNT)=ADDFEEAMT
   PAYOFFFEEDESC(PAYOFFFEECOUNT)=ADDFEEDESC
   PAYOFFFEEAMTTOTAL=PAYOFFFEEAMTTOTAL+ADDFEEAMT
  END 
END

PROCEDURE ADDCOLLATERALINFO

 IF CTLINFOCOUNT<CTLINFOMAX THEN
  DO
   CTLINFOCOUNT=CTLINFOCOUNT+1
   CTLINFO(CTLINFOCOUNT)=ADDCTLINFO
   CTLINFOLABEL(CTLINFOCOUNT)=ADDCTLINFOLABEL
  END
END

PROCEDURE GETCOLLATERAL

 LOANFOUND=FALSE
 FOR EACH LOAN WITH (LOAN:ID=RGSLID)
  DO
   LOANFOUND=TRUE
   IF PARAMHOMELOANTYPES(LOAN:TYPE)=TRUE THEN
    CALL GETCTLHOMELOANS
   ELSE IF PARAMBOATLOANTYPES(LOAN:TYPE)=TRUE THEN
    CALL GETCTLBOATLOANS
   ELSE IF PARAMVEHLOANTYPES(LOAN:TYPE)=TRUE THEN
    CALL GETCTLVEHLOANS
   ELSE IF PARAMSECUREDLOANTYPES(LOAN:TYPE)=TRUE THEN
    CALL GETCTLSECUREDLOANS
  END
 UNTIL LOANFOUND=TRUE  
END [PROCEDURE]

PROCEDURE GETCTLHOMELOANS

 CTLLABEL=PARAMHOMECTLDESC(USELANGUAGE)
 FOUND=FALSE
 FOR EACH LOAN NAME WITH LOAN NAME:TYPE=NAMETYPEPROPERTYADDRESS
  DO
   FOUND=TRUE
   ADDCTLINFOLABEL=""
   ADDCTLINFO=LOAN NAME:STREET
   CALL ADDCOLLATERALINFO
   IF LOAN NAME:EXTRAADDRESS<>"" THEN
    DO
     ADDCTLINFO=LOAN NAME:EXTRAADDRESS
     CALL ADDCOLLATERALINFO
    END 
   ADDCTLINFO=LOAN NAME:CITY+" "+LOAN NAME:STATE+" "+LOAN NAME:ZIPCODE
   CALL ADDCOLLATERALINFO
  END
 UNTIL FOUND=TRUE 
END [PROCEDURE]

PROCEDURE GETCTLBOATLOANS

 CTLLABEL=PARAMBOATCTLDESC(USELANGUAGE)
 FOR EACH LOAN TRACKING WITH (LOAN TRACKING:TYPE=PARAMBOATLOANTT AND
                             (LOAN TRACKING:EXPIREDATE=DATENULL OR
                              LOAN TRACKING:EXPIREDATE>SYSTEMDATE))
  DO
   CALL GETBOATFIELDDATA
   ADDCTLINFO=BOATUSERCHAR
   ADDCTLINFOLABEL=""
   CALL ADDCOLLATERALINFO
  END
 UNTIL CTLINFOCOUNT>=3 

END [PROCEDURE]

PROCEDURE GETCTLVEHLOANS

 CTLLABEL=PARAMVEHCTLDESC(USELANGUAGE)
 FOR EACH LOAN TRACKING WITH (LOAN TRACKING:TYPE=PARAMVEHLOANTT AND
                             (LOAN TRACKING:EXPIREDATE=DATENULL OR
                              LOAN TRACKING:EXPIREDATE>SYSTEMDATE))
  DO
   FOR CURRENTFIELD=1 TO PARAMVEHCTLCOUNT
    DO
     IF PARAMVEHLOANTFLD(CURRENTFIELD)<>"" THEN
      DO
       VEHLOANFLD=PARAMVEHLOANTFLD(CURRENTFIELD)
       CALL GETCOLLATERALFIELDDATA
       IF COLLATERALFIELDDATA<>"" THEN
        DO
         BNOTEXT=COLLATERALFIELDDATA
         CALL BNONLTS
         ADDCTLINFO=BNOTEXT
         ADDCTLINFOLABEL=PARAMVEHLOANTLBL(CURRENTFIELD,USELANGUAGE)

[* Fallback to English if no Spanish label is found
*]
         IF USELANGUAGE=PARAMMSGTAGSPANISH AND
            ADDCTLINFOLABEL="" THEN
          ADDCTLINFOLABEL=PARAMVEHLOANTLBL(CURRENTFIELD,PARAMMSGTAGENGLISH)  
         CALL ADDCOLLATERALINFO
        END
      END
    END
  END
END [PROCEDURE]

PROCEDURE GETCTLSECUREDLOANS
 
 CTLLABEL=PARAMSECUREDCTLDESC(USELANGUAGE)
 FOR EACH LOAN PLEDGE WITH LOAN PLEDGE:TYPE=PLEDGETYPESHARESECURED
  DO
   ADDCTLINFO=LOAN PLEDGE:ACCOUNTNUMBER+"-S"+LOAN PLEDGE:ID
   ADDCTLINFOLABEL=""
   CALL ADDCOLLATERALINFO
  END
 UNTIL CTLINFOCOUNT>=3 
END [PROCEDURE]

PROCEDURE GETBOATFIELDDATA

 BOATUSERCHAR=""
 IF PARAMBOATLOANTFLD="USERCHAR1" THEN
  BOATUSERCHAR=LOAN TRACKING:USERCHAR1
 ELSE IF PARAMBOATLOANTFLD="USERCHAR2" THEN
  BOATUSERCHAR=LOAN TRACKING:USERCHAR2
 ELSE IF PARAMBOATLOANTFLD="USERCHAR3" THEN
  BOATUSERCHAR=LOAN TRACKING:USERCHAR3
 ELSE IF PARAMBOATLOANTFLD="USERCHAR4" THEN
  BOATUSERCHAR=LOAN TRACKING:USERCHAR4
 ELSE IF PARAMBOATLOANTFLD="USERCHAR5" THEN
  BOATUSERCHAR=LOAN TRACKING:USERCHAR5
 ELSE IF PARAMBOATLOANTFLD="USERCHAR6" THEN
  BOATUSERCHAR=LOAN TRACKING:USERCHAR6
 ELSE IF PARAMBOATLOANTFLD="USERCHAR7" THEN
  BOATUSERCHAR=LOAN TRACKING:USERCHAR7
 ELSE IF PARAMBOATLOANTFLD="USERCHAR8" THEN
  BOATUSERCHAR=LOAN TRACKING:USERCHAR8
 ELSE IF PARAMBOATLOANTFLD="USERCHAR9" THEN
  BOATUSERCHAR=LOAN TRACKING:USERCHAR9
 ELSE IF PARAMBOATLOANTFLD="USERCHAR10" THEN
  BOATUSERCHAR=LOAN TRACKING:USERCHAR10
 ELSE IF PARAMBOATLOANTFLD="USERCHAR11" THEN
  BOATUSERCHAR=LOAN TRACKING:USERCHAR11
 ELSE IF PARAMBOATLOANTFLD="USERCHAR12" THEN
  BOATUSERCHAR=LOAN TRACKING:USERCHAR12
 ELSE IF PARAMBOATLOANTFLD="USERCHAR13" THEN
  BOATUSERCHAR=LOAN TRACKING:USERCHAR13
 ELSE IF PARAMBOATLOANTFLD="USERCHAR14" THEN
  BOATUSERCHAR=LOAN TRACKING:USERCHAR14
 ELSE IF PARAMBOATLOANTFLD="USERCHAR15" THEN
  BOATUSERCHAR=LOAN TRACKING:USERCHAR15
 ELSE IF PARAMBOATLOANTFLD="USERCHAR16" THEN
  BOATUSERCHAR=LOAN TRACKING:USERCHAR16
 ELSE IF PARAMBOATLOANTFLD="USERCHAR17" THEN
  BOATUSERCHAR=LOAN TRACKING:USERCHAR17
 ELSE IF PARAMBOATLOANTFLD="USERCHAR18" THEN
  BOATUSERCHAR=LOAN TRACKING:USERCHAR18
 ELSE IF PARAMBOATLOANTFLD="USERCHAR19" THEN
  BOATUSERCHAR=LOAN TRACKING:USERCHAR19
 ELSE IF PARAMBOATLOANTFLD="USERCHAR20" THEN
  BOATUSERCHAR=LOAN TRACKING:USERCHAR20
END

PROCEDURE GETCOLLATERALFIELDDATA

 COLLATERALFIELDDATA=""

 IF CHARACTERSEARCH(VEHLOANFLD,"USERNUMBER")>0 THEN
  DO
   IF VEHLOANFLD="USERNUMBER1" THEN
    USERNUMBER=LOAN TRACKING:USERNUMBER1
   ELSE IF VEHLOANFLD="USERNUMBER2" THEN
    USERNUMBER=LOAN TRACKING:USERNUMBER2
   ELSE IF VEHLOANFLD="USERNUMBER3" THEN
    USERNUMBER=LOAN TRACKING:USERNUMBER3
   ELSE IF VEHLOANFLD="USERNUMBER4" THEN
    USERNUMBER=LOAN TRACKING:USERNUMBER4
   ELSE IF VEHLOANFLD="USERNUMBER5" THEN
    USERNUMBER=LOAN TRACKING:USERNUMBER5
   ELSE IF VEHLOANFLD="USERNUMBER6" THEN
    USERNUMBER=LOAN TRACKING:USERNUMBER6
   ELSE IF VEHLOANFLD="USERNUMBER7" THEN
    USERNUMBER=LOAN TRACKING:USERNUMBER7
   ELSE IF VEHLOANFLD="USERNUMBER8" THEN
    USERNUMBER=LOAN TRACKING:USERNUMBER8
   ELSE IF VEHLOANFLD="USERNUMBER9" THEN
    USERNUMBER=LOAN TRACKING:USERNUMBER9
   ELSE IF VEHLOANFLD="USERNUMBER10" THEN
    USERNUMBER=LOAN TRACKING:USERNUMBER10
   ELSE IF VEHLOANFLD="USERNUMBER11" THEN
    USERNUMBER=LOAN TRACKING:USERNUMBER11
   ELSE IF VEHLOANFLD="USERNUMBER12" THEN
    USERNUMBER=LOAN TRACKING:USERNUMBER12
   ELSE IF VEHLOANFLD="USERNUMBER13" THEN
    USERNUMBER=LOAN TRACKING:USERNUMBER13
   ELSE IF VEHLOANFLD="USERNUMBER14" THEN
    USERNUMBER=LOAN TRACKING:USERNUMBER14
   ELSE IF VEHLOANFLD="USERNUMBER15" THEN
    USERNUMBER=LOAN TRACKING:USERNUMBER15
   ELSE IF VEHLOANFLD="USERNUMBER16" THEN
    USERNUMBER=LOAN TRACKING:USERNUMBER16
   ELSE IF VEHLOANFLD="USERNUMBER17" THEN
    USERNUMBER=LOAN TRACKING:USERNUMBER17
   ELSE IF VEHLOANFLD="USERNUMBER18" THEN
    USERNUMBER=LOAN TRACKING:USERNUMBER18
   ELSE IF VEHLOANFLD="USERNUMBER19" THEN
    USERNUMBER=LOAN TRACKING:USERNUMBER19
   ELSE IF VEHLOANFLD="USERNUMBER20" THEN
    USERNUMBER=LOAN TRACKING:USERNUMBER20

   COLLATERALFIELDDATA=FORMAT("#########9",USERNUMBER)
  END
 ELSE IF CHARACTERSEARCH(VEHLOANFLD,"USERCHAR")>0 THEN
  DO
   IF VEHLOANFLD="USERCHAR1" THEN
    USERCHAR=LOAN TRACKING:USERCHAR1
   ELSE IF VEHLOANFLD="USERCHAR2" THEN
    USERCHAR=LOAN TRACKING:USERCHAR2
   ELSE IF VEHLOANFLD="USERCHAR3" THEN
    USERCHAR=LOAN TRACKING:USERCHAR3
   ELSE IF VEHLOANFLD="USERCHAR4" THEN
    USERCHAR=LOAN TRACKING:USERCHAR4
   ELSE IF VEHLOANFLD="USERCHAR5" THEN
    USERCHAR=LOAN TRACKING:USERCHAR5
   ELSE IF VEHLOANFLD="USERCHAR6" THEN
    USERCHAR=LOAN TRACKING:USERCHAR6
   ELSE IF VEHLOANFLD="USERCHAR7" THEN
    USERCHAR=LOAN TRACKING:USERCHAR7
   ELSE IF VEHLOANFLD="USERCHAR8" THEN
    USERCHAR=LOAN TRACKING:USERCHAR8
   ELSE IF VEHLOANFLD="USERCHAR9" THEN
    USERCHAR=LOAN TRACKING:USERCHAR9
   ELSE IF VEHLOANFLD="USERCHAR10" THEN
    USERCHAR=LOAN TRACKING:USERCHAR10
   ELSE IF VEHLOANFLD="USERCHAR11" THEN
    USERCHAR=LOAN TRACKING:USERCHAR11
   ELSE IF VEHLOANFLD="USERCHAR12" THEN
    USERCHAR=LOAN TRACKING:USERCHAR12
   ELSE IF VEHLOANFLD="USERCHAR13" THEN
    USERCHAR=LOAN TRACKING:USERCHAR13
   ELSE IF VEHLOANFLD="USERCHAR14" THEN
    USERCHAR=LOAN TRACKING:USERCHAR14
   ELSE IF VEHLOANFLD="USERCHAR15" THEN
    USERCHAR=LOAN TRACKING:USERCHAR15
   ELSE IF VEHLOANFLD="USERCHAR16" THEN
    USERCHAR=LOAN TRACKING:USERCHAR16
   ELSE IF VEHLOANFLD="USERCHAR17" THEN
    USERCHAR=LOAN TRACKING:USERCHAR17
   ELSE IF VEHLOANFLD="USERCHAR18" THEN
    USERCHAR=LOAN TRACKING:USERCHAR18
   ELSE IF VEHLOANFLD="USERCHAR19" THEN
    USERCHAR=LOAN TRACKING:USERCHAR19
   ELSE IF VEHLOANFLD="USERCHAR20" THEN
    USERCHAR=LOAN TRACKING:USERCHAR20
   COLLATERALFIELDDATA=USERCHAR
  END
 ELSE IF CHARACTERSEARCH(VEHLOANFLD,"USERAMOUNT")>0 THEN
  DO
   IF VEHLOANFLD="USERAMOUNT1" THEN
    USERAMOUNT=LOAN TRACKING:USERAMOUNT1
   ELSE IF VEHLOANFLD="USERAMOUNT2" THEN
    USERAMOUNT=LOAN TRACKING:USERAMOUNT2
   ELSE IF VEHLOANFLD="USERAMOUNT3" THEN
    USERAMOUNT=LOAN TRACKING:USERAMOUNT3
   ELSE IF VEHLOANFLD="USERAMOUNT4" THEN
    USERAMOUNT=LOAN TRACKING:USERAMOUNT4
   ELSE IF VEHLOANFLD="USERAMOUNT5" THEN
    USERAMOUNT=LOAN TRACKING:USERAMOUNT5
   ELSE IF VEHLOANFLD="USERAMOUNT6" THEN
    USERAMOUNT=LOAN TRACKING:USERAMOUNT6
   ELSE IF VEHLOANFLD="USERAMOUNT7" THEN
    USERAMOUNT=LOAN TRACKING:USERAMOUNT7
   ELSE IF VEHLOANFLD="USERAMOUNT8" THEN
    USERAMOUNT=LOAN TRACKING:USERAMOUNT8
   ELSE IF VEHLOANFLD="USERAMOUNT9" THEN
    USERAMOUNT=LOAN TRACKING:USERAMOUNT9
   ELSE IF VEHLOANFLD="USERAMOUNT10" THEN
    USERAMOUNT=LOAN TRACKING:USERAMOUNT10
   ELSE IF VEHLOANFLD="USERAMOUNT11" THEN
    USERAMOUNT=LOAN TRACKING:USERAMOUNT11
   ELSE IF VEHLOANFLD="USERAMOUNT12" THEN
    USERAMOUNT=LOAN TRACKING:USERAMOUNT12
   ELSE IF VEHLOANFLD="USERAMOUNT13" THEN
    USERAMOUNT=LOAN TRACKING:USERAMOUNT13
   ELSE IF VEHLOANFLD="USERAMOUNT14" THEN
    USERAMOUNT=LOAN TRACKING:USERAMOUNT14
   ELSE IF VEHLOANFLD="USERAMOUNT15" THEN
    USERAMOUNT=LOAN TRACKING:USERAMOUNT15
   ELSE IF VEHLOANFLD="USERAMOUNT16" THEN
    USERAMOUNT=LOAN TRACKING:USERAMOUNT16
   ELSE IF VEHLOANFLD="USERAMOUNT17" THEN
    USERAMOUNT=LOAN TRACKING:USERAMOUNT17
   ELSE IF VEHLOANFLD="USERAMOUNT18" THEN
    USERAMOUNT=LOAN TRACKING:USERAMOUNT18
   ELSE IF VEHLOANFLD="USERAMOUNT19" THEN
    USERAMOUNT=LOAN TRACKING:USERAMOUNT19
   ELSE IF VEHLOANFLD="USERAMOUNT20" THEN
    USERAMOUNT=LOAN TRACKING:USERAMOUNT20
   BNOAMT=USERAMOUNT
   CALL BNOAMTTEXTDISPLAY
   COLLATERALFIELDDATA=BNOTEXT
  END
 ELSE IF CHARACTERSEARCH(VEHLOANFLD,"USERCODE")>0 THEN
  DO
   IF VEHLOANFLD="USERCODE1" THEN
    USERCODE=LOAN TRACKING:USERCODE1
   ELSE IF VEHLOANFLD="USERCODE2" THEN
    USERCODE=LOAN TRACKING:USERCODE2
   ELSE IF VEHLOANFLD="USERCODE3" THEN
    USERCODE=LOAN TRACKING:USERCODE3
   ELSE IF VEHLOANFLD="USERCODE4" THEN
    USERCODE=LOAN TRACKING:USERCODE4
   ELSE IF VEHLOANFLD="USERCODE5" THEN
    USERCODE=LOAN TRACKING:USERCODE5
   ELSE IF VEHLOANFLD="USERCODE6" THEN
    USERCODE=LOAN TRACKING:USERCODE6
   ELSE IF VEHLOANFLD="USERCODE7" THEN
    USERCODE=LOAN TRACKING:USERCODE7
   ELSE IF VEHLOANFLD="USERCODE8" THEN
    USERCODE=LOAN TRACKING:USERCODE8
   ELSE IF VEHLOANFLD="USERCODE9" THEN
    USERCODE=LOAN TRACKING:USERCODE9
   ELSE IF VEHLOANFLD="USERCODE10" THEN
    USERCODE=LOAN TRACKING:USERCODE10
   ELSE IF VEHLOANFLD="USERCODE11" THEN
    USERCODE=LOAN TRACKING:USERCODE11
   ELSE IF VEHLOANFLD="USERCODE12" THEN
    USERCODE=LOAN TRACKING:USERCODE12
   ELSE IF VEHLOANFLD="USERCODE13" THEN
    USERCODE=LOAN TRACKING:USERCODE13
   ELSE IF VEHLOANFLD="USERCODE14" THEN
    USERCODE=LOAN TRACKING:USERCODE14
   ELSE IF VEHLOANFLD="USERCODE15" THEN
    USERCODE=LOAN TRACKING:USERCODE15
   ELSE IF VEHLOANFLD="USERCODE16" THEN
    USERCODE=LOAN TRACKING:USERCODE16
   ELSE IF VEHLOANFLD="USERCODE17" THEN
    USERCODE=LOAN TRACKING:USERCODE17
   ELSE IF VEHLOANFLD="USERCODE18" THEN
    USERCODE=LOAN TRACKING:USERCODE18
   ELSE IF VEHLOANFLD="USERCODE19" THEN
    USERCODE=LOAN TRACKING:USERCODE19
   ELSE IF VEHLOANFLD="USERCODE20" THEN
    USERCODE=LOAN TRACKING:USERCODE20
   COLLATERALFIELDDATA=FORMAT("###9",USERCODE)
  END
 ELSE IF CHARACTERSEARCH(VEHLOANFLD,"USERDATE")>0 THEN
  DO
   IF VEHLOANFLD="USERDATE1" THEN
    USERDATE=LOAN TRACKING:USERDATE1
   ELSE IF VEHLOANFLD="USERDATE2" THEN
    USERDATE=LOAN TRACKING:USERDATE2
   ELSE IF VEHLOANFLD="USERDATE3" THEN
    USERDATE=LOAN TRACKING:USERDATE3
   ELSE IF VEHLOANFLD="USERDATE4" THEN
    USERDATE=LOAN TRACKING:USERDATE4
   ELSE IF VEHLOANFLD="USERDATE5" THEN
    USERDATE=LOAN TRACKING:USERDATE5
   ELSE IF VEHLOANFLD="USERDATE6" THEN
    USERDATE=LOAN TRACKING:USERDATE6
   ELSE IF VEHLOANFLD="USERDATE7" THEN
    USERDATE=LOAN TRACKING:USERDATE7
   ELSE IF VEHLOANFLD="USERDATE8" THEN
    USERDATE=LOAN TRACKING:USERDATE8
   ELSE IF VEHLOANFLD="USERDATE9" THEN
    USERDATE=LOAN TRACKING:USERDATE9
   ELSE IF VEHLOANFLD="USERDATE10" THEN
    USERDATE=LOAN TRACKING:USERDATE10
   ELSE IF VEHLOANFLD="USERDATE11" THEN
    USERDATE=LOAN TRACKING:USERDATE11
   ELSE IF VEHLOANFLD="USERDATE12" THEN
    USERDATE=LOAN TRACKING:USERDATE12
   ELSE IF VEHLOANFLD="USERDATE13" THEN
    USERDATE=LOAN TRACKING:USERDATE13
   ELSE IF VEHLOANFLD="USERDATE14" THEN
    USERDATE=LOAN TRACKING:USERDATE14
   ELSE IF VEHLOANFLD="USERDATE15" THEN
    USERDATE=LOAN TRACKING:USERDATE15
   ELSE IF VEHLOANFLD="USERDATE16" THEN
    USERDATE=LOAN TRACKING:USERDATE16
   ELSE IF VEHLOANFLD="USERDATE17" THEN
    USERDATE=LOAN TRACKING:USERDATE17
   ELSE IF VEHLOANFLD="USERDATE18" THEN
    USERDATE=LOAN TRACKING:USERDATE18
   ELSE IF VEHLOANFLD="USERDATE19" THEN
    USERDATE=LOAN TRACKING:USERDATE19
   ELSE IF VEHLOANFLD="USERDATE20" THEN
    USERDATE=LOAN TRACKING:USERDATE20
   COLLATERALFIELDDATA=FORMAT("--/--/--",USERDATE)
  END
 ELSE IF CHARACTERSEARCH(VEHLOANFLD,"USERRATE")>0 THEN
  DO
   IF VEHLOANFLD="USERRATE1" THEN
    USERRATE=LOAN TRACKING:USERRATE1
   ELSE IF VEHLOANFLD="USERRATE2" THEN
    USERRATE=LOAN TRACKING:USERRATE2
   ELSE IF VEHLOANFLD="USERRATE3" THEN
    USERRATE=LOAN TRACKING:USERRATE3
   ELSE IF VEHLOANFLD="USERRATE4" THEN
    USERRATE=LOAN TRACKING:USERRATE4
   ELSE IF VEHLOANFLD="USERRATE5" THEN
    USERRATE=LOAN TRACKING:USERRATE5
   ELSE IF VEHLOANFLD="USERRATE6" THEN
    USERRATE=LOAN TRACKING:USERRATE6
   ELSE IF VEHLOANFLD="USERRATE7" THEN
    USERRATE=LOAN TRACKING:USERRATE7
   ELSE IF VEHLOANFLD="USERRATE8" THEN
    USERRATE=LOAN TRACKING:USERRATE8
   ELSE IF VEHLOANFLD="USERRATE9" THEN
    USERRATE=LOAN TRACKING:USERRATE9
   ELSE IF VEHLOANFLD="USERRATE10" THEN
    USERRATE=LOAN TRACKING:USERRATE10
   ELSE IF VEHLOANFLD="USERRATE11" THEN
    USERRATE=LOAN TRACKING:USERRATE11
   ELSE IF VEHLOANFLD="USERRATE12" THEN
    USERRATE=LOAN TRACKING:USERRATE12
   ELSE IF VEHLOANFLD="USERRATE13" THEN
    USERRATE=LOAN TRACKING:USERRATE13
   ELSE IF VEHLOANFLD="USERRATE14" THEN
    USERRATE=LOAN TRACKING:USERRATE14
   ELSE IF VEHLOANFLD="USERRATE15" THEN
    USERRATE=LOAN TRACKING:USERRATE15
   ELSE IF VEHLOANFLD="USERRATE16" THEN
    USERRATE=LOAN TRACKING:USERRATE16
   ELSE IF VEHLOANFLD="USERRATE17" THEN
    USERRATE=LOAN TRACKING:USERRATE17
   ELSE IF VEHLOANFLD="USERRATE18" THEN
    USERRATE=LOAN TRACKING:USERRATE18
   ELSE IF VEHLOANFLD="USERRATE19" THEN
    USERRATE=LOAN TRACKING:USERRATE19
   ELSE IF VEHLOANFLD="USERRATE20" THEN
    USERRATE=LOAN TRACKING:USERRATE20
   BNORATE=USERRATE
   CALL BNORATETEXTDISPLAY 
   COLLATERALFIELDDATA=BNOTEXT
  END
END

PROCEDURE GETUSELANGUAGE
 
 USELANGUAGE=PARAMMSGTAGENGLISH
 IF PARAMLANGSPANISH=TRUE THEN
  USELANGUAGE=RGLANGUAGE
END [PROCEDURE]

[*
**  --------------------------------------------------------------------
**  Config File Procedures
**  --------------------------------------------------------------------
*]

PROCEDURE PARAMMSGINIT

 PARAMMSGTAGSCOUNT=0
 PARAMMSGOPT=FALSE
 PARAMMSGMAXLINES=0
 FOR PARAMMSGTAGINDEX=1 TO PARAMMSGTAGSMAX
  DO
   PARAMMSGOPTIONAL(PARAMMSGTAGINDEX)=FALSE
   PARAMMSGDEFINED(PARAMMSGTAGINDEX)=FALSE
   PARAMMSGMAX(PARAMMSGTAGINDEX)=PARAMMSGDEFAULTMAX
  END
END [PROCEDURE] 

PROCEDURE PARAMMSGTAGADD

 IF PARAMMSGTAGSCOUNT<PARAMMSGTAGSMAX THEN
  DO
   PARAMMSGTAGSCOUNT=PARAMMSGTAGSCOUNT+1
   PARAMMSGTAGS(PARAMMSGTAGSCOUNT)=PARAMMSGTAG 
   PARAMMSGPROPS(PARAMMSGTAGSCOUNT)=PARAMMSGPROP
   PARAMMSGOPTIONAL(PARAMMSGTAGSCOUNT)=PARAMMSGOPT
   IF PARAMMSGMAXLINES<>0 THEN 
    PARAMMSGMAX(PARAMMSGTAGSCOUNT)=PARAMMSGMAXLINES
   
   PARAMMSGOPT=FALSE
   PARAMMSGMAXLINES=0
  END
END [PROCEDURE]

PROCEDURE BNOINITPARAMVALS
[* Initialize parameter/cfg variables
*]
 PARAMELIGLOANTYPELIST=""
 PARAMHOMELOANTYPELIST=""
 PARAMBOATLOANTYPELIST=""
 PARAMVEHLOANTYPELIST=""
 PARAMSECUREDLOANTYPELIST=""
 FOR TMPLOOP=0 TO LOANTYPESMAX
  DO
   PARAMELIGLOANTYPES(TMPLOOP)=FALSE
   PARAMHOMELOANTYPES(TMPLOOP)=FALSE
   PARAMBOATLOANTYPES(TMPLOOP)=FALSE
   PARAMVEHLOANTYPES(TMPLOOP)=FALSE
   PARAMSECUREDLOANTYPES(TMPLOOP)=FALSE
  END

 PARAMLOANWARNLIST=""
 PARAMACCTWARNLIST=""
 FOR TMPLOOP=0 TO WARNINGCODESMAX
  DO
   PARAMLOANWARNCODES(TMPLOOP)=FALSE
   PARAMACTTWARNCODES(TMPLOOP)=FALSE
  END 

 PARAMPAYOFFFEESFNAME=""
 PARAMFUTUREDAYSMAX=90
 PARAMBOATLOANTT=30
 PARAMBOATLOANTFLD=""
 PARAMVEHLOANTT=30
 PARAMVEHCTLCOUNT=0
 FOR TMPLOOP=1 TO PARAMVEHCTLMAX
  DO
   PARAMVEHLOANTFLD(TMPLOOP)=""
   PARAMVEHLOANTLBL(TMPLOOP,PARAMMSGTAGENGLISH)=""
   PARAMVEHLOANTLBL(TMPLOOP,PARAMMSGTAGSPANISH)=""
  END
 
 PARAMHOMECTLDESC(PARAMMSGTAGENGLISH)="Address"
 PARAMHOMECTLDESC(PARAMMSGTAGSPANISH)=""
 PARAMBOATCTLDESC(PARAMMSGTAGENGLISH)="Boat"
 PARAMBOATCTLDESC(PARAMMSGTAGSPANISH)=""
 PARAMSECUREDCTLDESC(PARAMMSGTAGENGLISH)="Secured against"
 PARAMSECUREDCTLDESC(PARAMMSGTAGSPANISH)=""
 PARAMVEHCTLDESC(PARAMMSGTAGENGLISH)="Vehicle"
 PARAMVEHCTLDESC(PARAMMSGTAGSPANISH)=""

 PARAMINTTYPEDESC(0,PARAMMSGTAGENGLISH)="Daily"
 PARAMINTTYPEDESC(1,PARAMMSGTAGENGLISH)="360 Day"
 PARAMINTTYPEDESC(2,PARAMMSGTAGENGLISH)="365.25 Day"
 PARAMINTTYPEDESC(3,PARAMMSGTAGENGLISH)="Daily Billed"
 PARAMINTTYPEDESC(4,PARAMMSGTAGENGLISH)="Daily Billed"
 PARAMINTTYPEDESC(5,PARAMMSGTAGENGLISH)="Actual/360"
 PARAMINTTYPEDESC(6,PARAMMSGTAGENGLISH)="Daily Billed 360"
 PARAMINTTYPEDESC(7,PARAMMSGTAGENGLISH)="Actual/364"
 PARAMINTTYPEDESC(8,PARAMMSGTAGENGLISH)="Scheduled/364"

 PARAMINTTYPEDESC(0,PARAMMSGTAGSPANISH)=""
 PARAMINTTYPEDESC(1,PARAMMSGTAGSPANISH)=""
 PARAMINTTYPEDESC(2,PARAMMSGTAGSPANISH)=""
 PARAMINTTYPEDESC(3,PARAMMSGTAGSPANISH)=""
 PARAMINTTYPEDESC(4,PARAMMSGTAGSPANISH)=""
 PARAMINTTYPEDESC(5,PARAMMSGTAGSPANISH)=""
 PARAMINTTYPEDESC(6,PARAMMSGTAGSPANISH)=""
 PARAMINTTYPEDESC(7,PARAMMSGTAGSPANISH)=""
 PARAMINTTYPEDESC(8,PARAMMSGTAGSPANISH)=""

 PARAMERRDISPLAYCOUNT=0
 PARAMLANGSPANISH=FALSE
 PARAMDEBUGMODE=BNODEBUGMODEUNDEFINED
 PARAMTESTMODE=FALSE
 PARAMTESTEC=0
 PARAMPROGINSTALLDATE=DATENULL
END [PROCEDURE]

PROCEDURE BNOSETPARAMVALS
[* Assign parameter settings retrieved from the configuration Letter
** file to variables for use throughout the program
*]
 CALL BNOINITPARAMVALS

 CALL GETPARAMMSGS

[* Get any display error messages if configured in CFG file
*]
 CALL GETERRORDISPLAYMESSAGES

[* Type lists
*]
 BNOPARAMFIND="LT"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMELIGLOANTYPELIST=BNOPARAMVAL

 BNOPARAMFIND=PARAMHLT
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMHOMELOANTYPELIST=BNOPARAMVAL

 BNOPARAMFIND=PARAMBLT
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMBOATLOANTYPELIST=BNOPARAMVAL

 BNOPARAMFIND=PARAMVLT
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMVEHLOANTYPELIST=BNOPARAMVAL

 BNOPARAMFIND=PARAMSLT
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMSECUREDLOANTYPELIST=BNOPARAMVAL      

[* Warning code lists
*]
 BNOPARAMFIND="LW"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMLOANWARNLIST=BNOPARAMVAL

 BNOPARAMFIND="AW"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMACCTWARNLIST=BNOPARAMVAL  

[* Misc parameters
*]
 BNOPARAMFIND="FD"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMFUTUREDAYSMAX=VALUE(BNOPARAMVAL)

 BNOPARAMFIND="FSN"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMPAYOFFFEESFNAME=BNOPARAMVAL

[*Collateral parametrs
*]
 BNOPARAMFIND="BTT"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMBOATLOANTT=VALUE(BNOPARAMVAL)

 BNOPARAMFIND="BCTL"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMBOATLOANTFLD=BNOPARAMVAL

 BNOPARAMFIND="VTT"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMVEHLOANTT=VALUE(BNOPARAMVAL)

 FOR BNOPARAMLOOP=1 TO BNOCFGPARAMCOUNT
  DO
   IF SEGMENT(BNOCFGPARAM(BNOPARAMLOOP),1,4)="VCTL" THEN
    DO
     BNOPARAMTMP=BNOCFGPARAM(BNOPARAMLOOP)
     CALL PARAMEXTRACTLANG
     TMPINDEX=VALUE(SEGMENT(BNOPARAMTMP,5,5))
     IF TMPINDEX>=1 AND TMPINDEX<=PARAMVEHCTLMAX THEN
      DO
       BNOTEXT=BNOCFGPARAMVAL(BNOPARAMLOOP)
       CALL BNONTS
       PARAMVEHLOANTFLD(TMPINDEX)=BNOTEXT
       IF TMPINDEX>PARAMVEHCTLCOUNT THEN
        PARAMVEHCTLCOUNT=TMPINDEX
      END
    END
  END

 FOR BNOPARAMLOOP=1 TO BNOCFGPARAMCOUNT
  DO
   IF SEGMENT(BNOCFGPARAM(BNOPARAMLOOP),1,6)="VCTLLB" THEN
    DO
     BNOPARAMTMP=BNOCFGPARAM(BNOPARAMLOOP)
     CALL PARAMEXTRACTLANG
     TMPINDEX=VALUE(SEGMENT(BNOPARAMTMP,7,7))
     IF TMPINDEX>=1 AND TMPINDEX<=PARAMVEHCTLMAX THEN
      DO
       BNOTEXT=BNOCFGPARAMVAL(BNOPARAMLOOP)
       CALL BNONTS
       PARAMVEHLOANTLBL(TMPINDEX,PARAMMSGTAGLANG)=BNOTEXT
       IF TMPINDEX>PARAMVEHCTLCOUNT THEN
        PARAMVEHCTLCOUNT=TMPINDEX
      END
    END
  END

 FOR BNOPARAMLOOP=1 TO BNOCFGPARAMCOUNT
  DO
   IF SEGMENT(BNOCFGPARAM(BNOPARAMLOOP),1,5)="HCTLD" THEN
    DO
     BNOPARAMTMP=BNOCFGPARAM(BNOPARAMLOOP)
     CALL PARAMEXTRACTLANG
     BNOTEXT=BNOCFGPARAMVAL(BNOPARAMLOOP)
     CALL BNONTS
     PARAMHOMECTLDESC(PARAMMSGTAGLANG)=BNOTEXT
    END
  END
  
 FOR BNOPARAMLOOP=1 TO BNOCFGPARAMCOUNT
  DO
   IF SEGMENT(BNOCFGPARAM(BNOPARAMLOOP),1,5)="BCTLD" THEN
    DO
     BNOPARAMTMP=BNOCFGPARAM(BNOPARAMLOOP)
     CALL PARAMEXTRACTLANG
     BNOTEXT=BNOCFGPARAMVAL(BNOPARAMLOOP)
     CALL BNONTS
     PARAMBOATCTLDESC(PARAMMSGTAGLANG)=BNOTEXT
    END
  END  

 FOR BNOPARAMLOOP=1 TO BNOCFGPARAMCOUNT
  DO
   IF SEGMENT(BNOCFGPARAM(BNOPARAMLOOP),1,5)="VCTLD" THEN
    DO
     BNOPARAMTMP=BNOCFGPARAM(BNOPARAMLOOP)
     CALL PARAMEXTRACTLANG
     BNOTEXT=BNOCFGPARAMVAL(BNOPARAMLOOP)
     CALL BNONTS
     PARAMVEHCTLDESC(PARAMMSGTAGLANG)=BNOTEXT
    END
  END

 FOR BNOPARAMLOOP=1 TO BNOCFGPARAMCOUNT
  DO
   IF SEGMENT(BNOCFGPARAM(BNOPARAMLOOP),1,5)="SCTLD" THEN
    DO
     BNOPARAMTMP=BNOCFGPARAM(BNOPARAMLOOP)
     CALL PARAMEXTRACTLANG
     BNOTEXT=BNOCFGPARAMVAL(BNOPARAMLOOP)
     CALL BNONTS
     PARAMSECUREDCTLDESC(PARAMMSGTAGLANG)=BNOTEXT
    END
  END       

 FOR BNOPARAMLOOP=1 TO BNOCFGPARAMCOUNT
  DO
   IF SEGMENT(BNOCFGPARAM(BNOPARAMLOOP),1,3)="ITD" THEN
    DO
     BNOPARAMTMP=BNOCFGPARAM(BNOPARAMLOOP)
     CALL PARAMEXTRACTLANG
     TMPINDEX=VALUE(SEGMENT(BNOPARAMTMP,4,4))
     IF TMPINDEX>=0 AND TMPINDEX<=PARAMINTTYPEMAX THEN
      DO
       BNOTEXT=BNOCFGPARAMVAL(BNOPARAMLOOP)
       CALL BNONTS
       PARAMINTTYPEDESC(TMPINDEX,PARAMMSGTAGLANG)=BNOTEXT
      END
    END
  END

[* Common parameters
*]
 BNOPARAMFIND="SLS"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  DO
   IF CHARACTERSEARCH("TRUEYES1ON",BNOPARAMVAL)>0 THEN
    PARAMLANGSPANISH=TRUE
   ELSE 
    PARAMLANGSPANISH=FALSE 
  END

 BNOPARAMFIND="PID"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMPROGINSTALLDATE=DATEVALUE(BNOPARAMVAL)

[* Test parameters
*]
 BNOPARAMFIND="DEBUGMODE"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE AND BNOPARAMVAL<>"" THEN
  DO
   IF CHARACTERSEARCH("TRUEYES1ON",BNOPARAMVAL)>0 THEN
    PARAMDEBUGMODE=BNODEBUGMODEON
   ELSE 
    PARAMDEBUGMODE=BNODEBUGMODEOFF 
  END

 BNOPARAMFIND="TESTMODE"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  DO
   IF CHARACTERSEARCH("TRUEYES1ON",BNOPARAMVAL)>0 THEN
    PARAMTESTMODE=TRUE
  END

 BNOPARAMFIND="TESTEC"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE AND
    BNOPARAMVAL<>"" THEN
  PARAMTESTEC=VALUE(BNOPARAMVAL)
END [PROCEDURE]

PROCEDURE PARAMPOSTPROCESS
[* Post-processing of the param/cfg variables
*]

[* Expand all the loan type lists
*]
 LELISTINPUT=PARAMELIGLOANTYPELIST
 IF LELISTINPUT="" THEN
  LELISTINPUT="NONE"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO LOANTYPESMAX
  DO
   PARAMELIGLOANTYPES(TMPLOOP)=LELIST(TMPLOOP)
  END
 
 LELISTINPUT=PARAMHOMELOANTYPELIST
 IF LELISTINPUT="" THEN
  LELISTINPUT="NONE"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO LOANTYPESMAX
  DO
   PARAMHOMELOANTYPES(TMPLOOP)=LELIST(TMPLOOP)
  END

 LELISTINPUT=PARAMBOATLOANTYPELIST
 IF LELISTINPUT="" THEN
  LELISTINPUT="NONE"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO LOANTYPESMAX
  DO
   PARAMBOATLOANTYPES(TMPLOOP)=LELIST(TMPLOOP)
  END

 LELISTINPUT=PARAMVEHLOANTYPELIST
 IF LELISTINPUT="" THEN
  LELISTINPUT="NONE"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO LOANTYPESMAX
  DO
   PARAMVEHLOANTYPES(TMPLOOP)=LELIST(TMPLOOP)
  END

 LELISTINPUT=PARAMSECUREDLOANTYPELIST
 IF LELISTINPUT="" THEN
  LELISTINPUT="NONE"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO LOANTYPESMAX
  DO
   PARAMSECUREDLOANTYPES(TMPLOOP)=LELIST(TMPLOOP)
  END

[* Expand the warning code lists
*]
 LELISTINPUT=PARAMLOANWARNLIST
 IF LELISTINPUT="" THEN
  LELISTINPUT="NONE"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO WARNINGCODESMAX
  DO
   PARAMLOANWARNCODES(TMPLOOP)=LELIST(TMPLOOP)
  END

 LELISTINPUT=PARAMACCTWARNLIST
 IF LELISTINPUT="" THEN
  LELISTINPUT="NONE"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO WARNINGCODESMAX
  DO
   PARAMACTTWARNCODES(TMPLOOP)=LELIST(TMPLOOP)
  END

[* Check for duplicate loan types in CFG
*]
 TMPLOOP=1
 WHILE TMPLOOP<=LOANTYPESMAX AND
       BNOERRORCODE=0
  DO
   IF PARAMHOMELOANTYPES(TMPLOOP)=TRUE THEN
    BNOPARAMTMP=PARAMHLT
   IF PARAMBOATLOANTYPES(TMPLOOP)=TRUE THEN
    BNOPARAMTMP=PARAMBLT
   IF PARAMVEHLOANTYPES(TMPLOOP)=TRUE THEN
    BNOPARAMTMP=PARAMVLT
   IF PARAMSECUREDLOANTYPES(TMPLOOP)=TRUE THEN
    BNOPARAMTMP=PARAMSLT

   IF PARAMHOMELOANTYPES(TMPLOOP)+PARAMBOATLOANTYPES(TMPLOOP)+
      PARAMVEHLOANTYPES(TMPLOOP)+PARAMSECUREDLOANTYPES(TMPLOOP)>1 THEN
    DO
     BNOERRORCODE=BNOERRCODEDUPLOANTYPE
     BNOERRORMODIFIER=BNOERRMODDUPLOANTYPE
     BNOERRORMODIFIER=FORMAT("Loan Type 9999",TMPLOOP)+" ("+BNOPARAMTMP+")"
    END

   TMPLOOP=TMPLOOP+1
  END

[* Adjust debug mode
*]
 IF PARAMDEBUGMODE<>BNODEBUGMODEUNDEFINED THEN
  BNODEBUGMODE=PARAMDEBUGMODE
 ELSE IF PARAMPROGINSTALLDATE<>DATENULL THEN
  DO
   IF PARAMPROGINSTALLDATE+BNODEBUGPRINTINFODAYS>SYSTEMDATE THEN
    BNODEBUGMODE=BNODEBUGMODEON
   ELSE 
    BNODEBUGMODE=BNODEBUGMODEOFF 
  END 
END [PROCEDURE]

PROCEDURE GETPARAMMSGS

 PARAMMSGALLCOUNT=0
 FOR BNOPARAMLOOP=1 TO BNOCFGPARAMCOUNT
  DO
   PARAMMSGTAGINDEX=1 
   PARAMMSGTAGFOUND=FALSE
   WHILE PARAMMSGTAGINDEX<=PARAMMSGTAGSCOUNT AND PARAMMSGTAGFOUND=FALSE
    DO
     BNOPARAMTMP=BNOCFGPARAM(BNOPARAMLOOP)
     CALL PARAMEXTRACTLANG
     IF PARAMMSGTAGS(PARAMMSGTAGINDEX)=BNOPARAMTMP THEN
      DO
       PARAMMSGTAGFOUND=TRUE
       IF BNOCFGPARAMVAL(BNOPARAMLOOP)<>"" THEN
        PARAMMSGDEFINED(PARAMMSGTAGINDEX)=TRUE

       IF PARAMMSGALLCOUNT<PARAMMSGALLMAX THEN
        DO
         PARAMMSGALLCOUNT=PARAMMSGALLCOUNT+1
         PARAMMSGALLTAGSLANG(PARAMMSGALLCOUNT)=PARAMMSGTAGLANG
         PARAMMSGALLTAGS(PARAMMSGALLCOUNT)=BNOPARAMTMP
         BNOTEXT=BNOCFGPARAMVAL(BNOPARAMLOOP)
         CALL BNOCLEANUPTEXT
         PARAMMSGALL(PARAMMSGALLCOUNT)=BNOTEXT
        END 
      END
     PARAMMSGTAGINDEX=PARAMMSGTAGINDEX+1
    END
  END
END [PROCEDURE]

PROCEDURE BNOCFGFILEREAD
[* Open and read through the parameter file to create an array of
** parameter names and associated values.
**
**  PASS    BCFGFILENAME      Parameter Letter file name
**  PASS    BNOCFGPARAMMAX    Maximum number of parameters
**  
**  RETURN  BNOCFGFILEFERROR  File open/read error
**  RETURN  BNOERRORCODE      Error code
**  RETURN  BNOCFGPARAM(A)    Parameter Name
**  RETURN  BNOCFGPARAMVAL(A) Parameter Value
**  RETURN  BNOCFGPARAMCOUNT  Parameters Found
**
*]
 BNOCFGPARAMALLOWDUPS=TRUE
 BNOCFGFILEFERROR=""
 BNOCFGPARAMCOUNT=0
 WHILELIMIT=1000000
 FILEOPEN("LETTER",BNOCFGFILENAME,"READ",BNOCFGFILENUMBER,BNOCFGFILEFERROR)
 IF BNOCFGFILEFERROR<>"" THEN
  DO
   BNOERRORCODE=BNOERRCODECONFIGREAD
   BNOERRORMODIFIER=BNOERRMODOPEN
   BNOERRORMODIFIER=BNOCFGFILENAME+" open error - "+BNOCFGFILEFERROR
   BNODEBUGMSG="Error opening CFG param file: "+BNOCFGFILEFERROR
   CALL BNODEBUGMSGADD
  END
 ELSE
  DO
   WHILE BNOCFGFILEFERROR="" AND BNOCFGPARAMCOUNT<BNOCFGPARAMMAX 
    DO
     FILEREADLINE(BNOCFGFILENUMBER,BNOCFGFILELINE,BNOCFGFILEFERROR)
     IF BNOCFGFILEFERROR<>"" AND
        BNOCFGFILEFERROR<>"EOF" THEN
      DO
       BNOERRORCODE=BNOERRCODECONFIGREAD
       BNOERRORMODIFIER=BNOERRMODREAD
       BNOERRORMODIFIER=BNOCFGFILENAME+" read error - "+BNOCFGFILEFERROR
       BNODEBUGMSG="Error reading CFG param file: "+BNOCFGFILEFERROR
       CALL BNODEBUGMSGADD
      END
     ELSE
      DO
       BNOPOS=CHARACTERSEARCH(BNOCFGFILELINE,":")
       IF SEGMENT(BNOCFGFILELINE,1,1)<>"*" AND BNOPOS>1 THEN
        DO
         BNOTEXT=SEGMENT(BNOCFGFILELINE,1,BNOPOS-1)
         CALL BNONLTS
         BNOPARAMTMP=BNOTEXT

         BNOTEXT=SEGMENT(BNOCFGFILELINE,BNOPOS+1,LENGTH(BNOCFGFILELINE))
         CALL BNONLS
         BNOPARAMVALTMP=BNOTEXT

         BNOPARAMFOUND=FALSE
         IF BNOCFGPARAMALLOWDUPS=FALSE THEN 
          DO
           FOR BNOTMPLOOP=1 TO BNOCFGPARAMCOUNT
            DO
             IF BNOCFGPARAM(BNOTMPLOOP)=BNOPARAMTMP THEN
              BNOPARAMFOUND=TRUE
            END
           IF BNOPARAMFOUND=TRUE THEN
            DO
             BNOERRORCODE=BNOERRCODECONFIGVALIDATE
             BNOERRORMODIFIER=BNOERRMODDUPLICATEPARAM
             BNOERRORMODIFIER="Duplicate Param file entry("+BNOPARAMTMP+")"
             BNODEBUGMSG="Duplicate Param file entry: "+BNOPARAMTMP
             CALL BNODEBUGMSGADD
            END
          END

         IF BNOPARAMFOUND=FALSE THEN
          DO
           BNOCFGPARAMCOUNT=BNOCFGPARAMCOUNT+1
           BNOCFGPARAM(BNOCFGPARAMCOUNT)=BNOPARAMTMP
           BNOCFGPARAMVAL(BNOCFGPARAMCOUNT)=BNOPARAMVALTMP
          END
        END  [IF SEGMENT(BNOCFGFILELINE,1,1)<>"*"]
      END  [IF BNOCFGFILEFERROR=""]
    END  [WHILE BNOCFGFILEFERROR=""]
  END

 FILECLOSE(BNOCFGFILENUMBER,BNOCFGFILEFERROR)
END [PROCEDURE]

PROCEDURE BNOCFGDEBUGADD
[* Add CFG lines to debug
*]

 IF BNODEBUGMODE=BNODEBUGMODEON AND
    BNODEBUGINCLUDEPARAMS=TRUE THEN
  DO
   FOR TMPLOOP=1 TO BNOCFGPARAMCOUNT
    DO
     BNOTEXT=BNOCFGPARAMVAL(TMPLOOP)
     CALL BNOCLEANUPTEXT
     BNODEBUGMSG="PARAM:"+BNOCFGPARAM(TMPLOOP)+"-"+
                  BNOTEXT
     CALL BNODEBUGMSGADD
    END
  END
END [PROCEDURE]

PROCEDURE BNOGETPARAMVAL
[* Find requested parameter setting and return value.
**
**  PASS    BNOPARAMFIND   Targeted parameter setting
**  
**  RETURN  BNOPARAMFOUND  T/F found flag
**  RETURN  BNOPARAMVAL    Parameter value found
*] 
 BNOPARAMFOUND=FALSE
 FOR BNOPARAMLOOP=1 TO BNOCFGPARAMCOUNT
  DO
   IF BNOCFGPARAM(BNOPARAMLOOP)=BNOPARAMFIND THEN
    DO
     BNOPARAMVAL=BNOCFGPARAMVAL(BNOPARAMLOOP)
     BNOPARAMFOUND=TRUE
     BNOPARAMLOOP=BNOCFGPARAMCOUNT
    END
  END
END [PROCEDURE]

PROCEDURE GETERRORDISPLAYMESSAGES
[* Find the error display lines
*] 
 
 FOR BNOPARAMLOOP=1 TO BNOCFGPARAMCOUNT
  DO
   IF SEGMENT(BNOCFGPARAM(BNOPARAMLOOP),1,3)="EDM" THEN
    DO
     BNOPARAMTMP=BNOCFGPARAM(BNOPARAMLOOP)
     CALL PARAMEXTRACTLANG
     TMPERRCODE=VALUE(SEGMENT(BNOPARAMTMP,4,6))
     IF CHARACTERSEARCH(BNOERRDISPLAYLIST,FORMAT("999",TMPERRCODE))>0 THEN
      DO
       BNOTEXT=BNOCFGPARAMVAL(BNOPARAMLOOP)
       CALL BNONTS
       CALL BNOCLEANUPTEXT
       TMPDISPLAYLINE=BNOTEXT
       CALL PARAMERRDISPLAYADD
      END
    END
  END
END [PROCEDURE]

PROCEDURE PARAMEXTRACTLANG
[* Extract language suffix and set PARAMMSGTAGLANG.  Return updated BNOPARAMTMP variable.
*]

 PARAMMSGTAGLANG=PARAMMSGTAGENGLISH
 TAGSFXPOS=CHARACTERSEARCH(BNOPARAMTMP,PARAMMSGTAGENGLISHSFX)
 IF TAGSFXPOS<>0 AND
    TAGSFXPOS=LENGTH(BNOPARAMTMP)-2 THEN
  BNOPARAMTMP=SEGMENT(BNOPARAMTMP,1,LENGTH(BNOPARAMTMP)-3)
 TAGSFXPOS=CHARACTERSEARCH(BNOPARAMTMP,PARAMMSGTAGSPANISHSFX)
 IF TAGSFXPOS<>0 AND
    TAGSFXPOS=LENGTH(BNOPARAMTMP)-2 THEN
  DO
   BNOPARAMTMP=SEGMENT(BNOPARAMTMP,1,LENGTH(BNOPARAMTMP)-3)
   PARAMMSGTAGLANG=PARAMMSGTAGSPANISH
  END 
END [PROCEDURE]

PROCEDURE PARAMERRDISPLAYADD

 IF PARAMERRDISPLAYCOUNT<PARAMERRDISPLAYMAX THEN
  DO
   PARAMERRDISPLAYCOUNT=PARAMERRDISPLAYCOUNT+1
   PARAMERRDISPLAYERRCODES(PARAMERRDISPLAYCOUNT)=TMPERRCODE
   PARAMERRDISPLAYLANG(PARAMERRDISPLAYCOUNT)=PARAMMSGTAGLANG
   BNOTEXT=TMPDISPLAYLINE
   CALL BNONTS
   PARAMERRDISPLAYLINES(PARAMERRDISPLAYCOUNT)=BNOTEXT
  END
END [PROCEDURE]

PROCEDURE BNOERRDISPLAYLISTADD
[* Add to the list of errors that support error display messages.  Used to 
** register those error codes that support display messages.
*]

 IF BNOERRDISPLAYLIST<>"" THEN
  BNOERRDISPLAYLIST=BNOERRDISPLAYLIST+","
 BNOERRDISPLAYLIST=BNOERRDISPLAYLIST+FORMAT("999",BNOERRDISPLAYCODE)
END [PROCEDURE]

PROCEDURE GETBNOERRDISPLAYMSG

 PARAMERRDISPLAYINDEX=1
 BNOERRDISPLAYMSGCOUNT=0
 WHILE PARAMERRDISPLAYINDEX<=PARAMERRDISPLAYCOUNT AND
       BNOERRDISPLAYMSGCOUNT<BNOERRDISPLAYMSGSMAX
  DO
   IF PARAMERRDISPLAYERRCODES(PARAMERRDISPLAYINDEX)=BNOERRCODE AND
      PARAMERRDISPLAYLANG(PARAMERRDISPLAYINDEX)=USELANGUAGE THEN
    DO
     BNOERRDISPLAYMSGCOUNT=BNOERRDISPLAYMSGCOUNT+1
     BNOERRDISPLAYMSG(BNOERRDISPLAYMSGCOUNT)=PARAMERRDISPLAYLINES(PARAMERRDISPLAYINDEX)
    END  
   PARAMERRDISPLAYINDEX=PARAMERRDISPLAYINDEX+1
  END

 IF BNOERRDISPLAYMSGCOUNT=1 AND
    BNOERRDISPLAYMSG(1)="" THEN
  BNOERRDISPLAYMSGCOUNT=0  
END [PROCEDURE]

[*
**  --------------------------------------------------------------------
**  JSON Procedures
**  --------------------------------------------------------------------
*]

PROCEDURE JSONERROR
[* Output the JSON for an error response
*]

 CALL BNOERRGETMESSAGE

 JSONPROPNAME="results"
 CALL JSONPROPFIRST
 CALL JSONOBJ
 NEWLINE
 
 JSONOBJFIRSTPROP=TRUE
 CALL JSONGENERALSPECS

 JSONPROPNAME="errorCode"
 CALL JSONPROP
 PRINT FORMAT("999",BNOERRCODE)
 NEWLINE

 JSONPROPNAME="errorMessage"
 CALL JSONPROP
 PRINT QQ+BNOERRMESSAGE
 IF BNOERRMODIFIER<>"" THEN
  PRINT ": "+BNOERRMODIFIER
 PRINT QQ
 NEWLINE

 CALL GETBNOERRDISPLAYMSG

[* Fall back to English message if no Spanish message defined for the error display message
*]
 IF BNOERRDISPLAYMSGCOUNT=0 AND
    USELANGUAGE=PARAMMSGTAGSPANISH THEN
  DO
   USELANGUAGE=PARAMMSGTAGENGLISH
   CALL GETBNOERRDISPLAYMSG
  END  
 
 IF BNOERRDISPLAYMSGCOUNT>0 THEN
  DO
   JSONPROPNAME="errorDisplayMessage"
   CALL JSONPROP

   CALL JSONARRAY
   FOR TMPLOOP=1 TO BNOERRDISPLAYMSGCOUNT
    DO
     BNOTEXT=BNOERRDISPLAYMSG(TMPLOOP)
     CALL BNONTS
     PRINT QQ+BNOTEXT+QQ
     IF TMPLOOP<BNOERRDISPLAYMSGCOUNT THEN
      PRINT ","
     NEWLINE
    END
   CALL JSONARRAYEND
  END

 IF BNOERRORCODE=BNOERRCODEINELIGLOANTYPE OR
    BNOERRORCODE=BNOERRCODEACCTWARNING OR
    BNOERRORCODE=BNOERRCODELOANWARNING OR
    BNOERRORCODE=BNOERRCODEBADPAYOFFDATE THEN
  DO
   LOANELIGIBLE=FALSE 
   CALL JSONLOANELIGIBLE  
  END
 ELSE IF @RGSTATE=STATEPERFORMCALC THEN
  DO
   LOANELIGIBLE=TRUE 
   CALL JSONLOANELIGIBLE  
  END

 CALL JSONMSGARRAYS

 CALL JSONOBJEND [results property]
END [PROCEDURE]

PROCEDURE JSONSUCCESSPRELOADDATA
[* Output the JSON for successful responses in the GETPRELOADDATA state
*]

 JSONPROPNAME="results"
 CALL JSONPROPFIRST
 CALL JSONOBJ
 NEWLINE

 JSONOBJFIRSTPROP=TRUE
 CALL JSONGENERALSPECS
 
 LOANELIGIBLE=TRUE
 CALL JSONLOANELIGIBLE
 
 CALL JSONMSGARRAYS

 CALL JSONOBJEND [END results property]
END [PROCEDURE]

PROCEDURE JSONSUCCESSPERFORMCALC
[* Output the JSON for successful responses in the PERFORMLOANPAYOFFCALC state
*]

 JSONPROPNAME="results"
 CALL JSONPROPFIRST
 CALL JSONOBJ
 NEWLINE

 JSONOBJFIRSTPROP=TRUE
 CALL JSONGENERALSPECS

 JSONPROPNAME="totalPayoffAmount"
 CALL JSONPROP
 BNOAMT=PAYOFFCALCAMOUNT+PAYOFFFEEAMTTOTAL
 CALL BNOAMTTEXT
 PRINT QQ+BNOTEXT+QQ
 NEWLINE

 JSONPROPNAME="payoffDate"
 CALL JSONPROP
 PRINT QQ+FORMAT("99/99/99",RGPAYOFFDATE)+QQ
 NEWLINE

 CALL JSONCALCACCOUNTDETAILS
 CALL JSONCALCCOLLATERAL
 CALL JSONCALCPAYOFFFEES

 CALL JSONMSGARRAYS

 CALL JSONOBJEND [END results property]
END [PROCEDURE]

PROCEDURE JSONCALCACCOUNTDETAILS

 JSONPROPNAME="accountDetails"
 CALL JSONPROP
 CALL JSONOBJ
 NEWLINE

 JSONPROPNAME="principalBalance"
 CALL JSONPROPFIRST
 BNOAMT=PAYOFFCALCPRINCIPALBAL
 CALL BNOAMTTEXT
 PRINT QQ+BNOTEXT+QQ
 NEWLINE

 JSONPROPNAME="interestType"
 CALL JSONPROP
 PRINT QQ+PAYOFFCALCINTERESTTYPE+QQ
 NEWLINE

 IF PAYOFFCALCLOANCODE<>3 THEN
  DO
   JSONPROPNAME="interestRate"
   CALL JSONPROP
   BNORATE=PAYOFFCALCINTRATE
   CALL BNORATETEXT
   PRINT QQ+BNOTEXT+QQ
   NEWLINE
  END

 JSONPROPNAME="interestDue"
 CALL JSONPROP
 BNOAMT=PAYOFFCALCINTERESTDUE
 CALL BNOAMTTEXT
 PRINT QQ+BNOTEXT+QQ
 NEWLINE 

 JSONPROPNAME="dueDate"
 CALL JSONPROP
 PRINT QQ+FORMAT("99/99/99",PAYOFFCALCDUEDATE)+QQ
 NEWLINE

 JSONPROPNAME="amountPastDueByPayoffDate"
 CALL JSONPROP
 BNOAMT=PAYOFFCALCAMTPASTDUE
 CALL BNOAMTTEXT
 PRINT QQ+BNOTEXT+QQ
 NEWLINE

 JSONPROPNAME="pastDuePayoffCount"
 CALL JSONPROP
 PRINT QQ
 PRINT PAYOFFCALCPASTDUECOUNT
 PRINT QQ
 NEWLINE

 JSONPROPNAME="lateChargeDue"
 CALL JSONPROP
 BNOAMT=PAYOFFCALCLATECHARGEDUE
 CALL BNOAMTTEXT
 PRINT QQ+BNOTEXT+QQ
 NEWLINE

 CALL JSONOBJEND [END accountDetails property]
END [PROCEDURE]

PROCEDURE JSONCALCCOLLATERAL

 JSONPROPNAME="associatedCollateral"
 CALL JSONPROP
 CALL JSONOBJ
 NEWLINE

 JSONPROPNAME="label"
 CALL JSONPROPFIRST
 PRINT QQ+CTLLABEL+QQ
 NEWLINE

 JSONPROPNAME="info"
 CALL JSONPROP
 CALL JSONARRAY
 NEWLINE

[* Collateral loop goes here 
*]

 FOR TMPLOOP=1 TO CTLINFOCOUNT
  DO
   IF TMPLOOP>1 THEN
    PRINT ","
   PRINT QQ
   IF CTLINFOLABEL(TMPLOOP)<>"" THEN
    PRINT CTLINFOLABEL(TMPLOOP)+":"
   PRINT CTLINFO(TMPLOOP)
   PRINT QQ
   NEWLINE 
  END

 CALL JSONARRAYEND
 
 CALL JSONOBJEND [END associatedCollateral property]
END [PROCEDURE]

PROCEDURE JSONCALCPAYOFFFEES

 IF PAYOFFFEECOUNT>0 THEN
  DO
   JSONPROPNAME="payoffFees"
   CALL JSONPROP
   CALL JSONARRAY
   NEWLINE

   FOR TMPLOOP=1 TO PAYOFFFEECOUNT
    DO
     IF TMPLOOP>1 THEN
      PRINT ","
     CALL JSONOBJ
     NEWLINE

     JSONPROPNAME="feeAmount"
     CALL JSONPROPFIRST
     BNOAMT=PAYOFFFEEAMT(TMPLOOP)
     CALL BNOAMTTEXT
     PRINT QQ+BNOTEXT+QQ
     NEWLINE

     JSONPROPNAME="feeDescription"
     CALL JSONPROP
     PRINT QQ+PAYOFFFEEDESC(TMPLOOP)+QQ
     NEWLINE

     CALL JSONOBJEND
    END

   CALL JSONARRAYEND
  END
END [PROCEDURE]

PROCEDURE JSONLOANELIGIBLE

 JSONPROPNAME="loanEligible"
 CALL JSONPROP
 PRINT JSONBOOLEAN(LOANELIGIBLE)
 NEWLINE
 JSONPROPNAME="maxDays"
 CALL JSONPROP
 PRINT PARAMFUTUREDAYSMAX
 NEWLINE
END [PROCEDURE]

PROCEDURE JSONGENERALSPECS
[* Output the generalSpecifications JSON object
*]

 JSONPROPNAME="generalSpecifications"
 CALL JSONPROP
 CALL JSONOBJ
 NEWLINE

 JSONOBJFIRSTPROP=TRUE
 CALL JSONPROGRAMINFO
 CALL JSONSYSTEMINFO

 CALL JSONOBJEND
END [PROCEDURE]

PROCEDURE JSONPROGRAMINFO
[* Output the programInfo JSON object
*]

 JSONPROPNAME="programInfo"
 CALL JSONPROP
 CALL JSONOBJ
 NEWLINE

 JSONPROPNAME="name"
 CALL JSONPROPFIRST
 PRINT QQ+BNOPROGRAMNAME+QQ
 NEWLINE
 JSONPROPNAME="version"
 CALL JSONPROP
 PRINT QQ+BNOPROGRAMVERSION+QQ
 NEWLINE
 JSONPROPNAME="lastModDate"
 CALL JSONPROP
 PRINT QQ+FORMAT("99/99/99 ",BNOLASTMODDATE)+BNOLASTMODTIME+QQ
 NEWLINE
 JSONPROPNAME="language"
 CALL JSONPROP
 PRINT USELANGUAGE
 NEWLINE

 IF BNOPROGRAMNOTE1<>"" THEN
  DO
   JSONPROPNAME="note1"
   CALL JSONPROP
   PRINT QQ+BNOPROGRAMNOTE1+QQ
   NEWLINE
  END 
 IF BNOPROGRAMNOTE2<>"" THEN
  DO
   JSONPROPNAME="note2"
   CALL JSONPROP
   PRINT QQ+BNOPROGRAMNOTE2+QQ
   NEWLINE
  END 

 CALL JSONOBJEND
END [PROCEDURE]

PROCEDURE JSONSYSTEMINFO
[* Output the systemInfo JSON object
*]

 JSONPROPNAME="systemInfo"
 CALL JSONPROP
 CALL JSONOBJ
 NEWLINE

 JSONPROPNAME="systemDate"
 CALL JSONPROPFIRST
 PRINT QQ+FORMAT("99/99/9999",SYSTEMDATE)+QQ
 NEWLINE

 JSONPROPNAME="slidLength"
 CALL JSONPROP
 PRINT BNOIDLENGTH
 NEWLINE

 JSONPROPNAME="memoMode"
 CALL JSONPROP
 PRINT JSONBOOLEAN(SYSMEMOMODE)
 NEWLINE

 CALL JSONOBJEND
END [PROCEDURE]

PROCEDURE JSONMSGARRAYS
 
 PARAMMSGTAGINDEX=1 
 WHILE PARAMMSGTAGINDEX<=PARAMMSGTAGSCOUNT
  DO
   MSGTAGSELECTED=FALSE
   IF PARAMMSGOPTIONAL(PARAMMSGTAGINDEX)=FALSE OR
     (PARAMMSGOPTIONAL(PARAMMSGTAGINDEX)=TRUE AND
      PARAMMSGDEFINED(PARAMMSGTAGINDEX)=TRUE) THEN
    MSGTAGSELECTED=TRUE

   IF MSGTAGSELECTED=TRUE AND
      PARAMMSGPROPS(PARAMMSGTAGINDEX)="" THEN
    MSGTAGSELECTED=FALSE

   IF MSGTAGSELECTED=TRUE THEN
    DO
     IF MSGPROPSELECTLIST<>"" AND
        CHARACTERSEARCH(MSGPROPSELECTLIST,PARAMMSGPROPS(PARAMMSGTAGINDEX))=0 THEN
      MSGTAGSELECTED=FALSE  
    END

   IF MSGTAGSELECTED=TRUE THEN 
    DO
     JSONPROPNAME=PARAMMSGPROPS(PARAMMSGTAGINDEX)
     CALL JSONPROP
     CALL JSONARRAY
     NEWLINE
  
     LINECOUNT=0
     FOR PARAMMSGALLINDEX=1 TO PARAMMSGALLCOUNT
      DO
       IF PARAMMSGALLTAGSLANG(PARAMMSGALLINDEX)=USELANGUAGE AND
          PARAMMSGALLTAGS(PARAMMSGALLINDEX)=PARAMMSGTAGS(PARAMMSGTAGINDEX) AND
          LINECOUNT<PARAMMSGMAX(PARAMMSGTAGINDEX) THEN
        DO
         LINECOUNT=LINECOUNT+1
         IF LINECOUNT<>1 THEN
          PRINT ","
         PRINT QQ+PARAMMSGALL(PARAMMSGALLINDEX)+QQ
         NEWLINE 
        END
      END
     CALL JSONARRAYEND
    END  
   
   PARAMMSGTAGINDEX=PARAMMSGTAGINDEX+1
  END

 MSGPROPSELECTLIST="" 
END [PROCEDURE]

[*
**  --------------------------------------------------------------------
**  JSON Procedures - Common
**  --------------------------------------------------------------------
*]
PROCEDURE JSONOPEN
[* Output JSON open char
*]
 PRINT "{"
 NEWLINE
END [PROCEDURE]

PROCEDURE JSONCLOSE
[* Output JSON close char
*]
 PRINT "}"
 NEWLINE
END [PROCEDURE]

PROCEDURE JSONOBJ
[* Output JSON object open char
*]
 PRINT "{"
END [PROCEDURE]

PROCEDURE JSONOBJEND
[* Output JSON object close char
*]
 PRINT "}"
 NEWLINE
END [PROCEDURE]

PROCEDURE JSONARRAY
[* Output JSON array open char
*]
 PRINT "["
END [PROCEDURE]

PROCEDURE JSONARRAYEND
[* Output JSON array close char
*]
 PRINT "]"
 NEWLINE
END [PROCEDURE]

PROCEDURE JSONPROPFIRST
 JSONOBJFIRSTPROP=TRUE
 CALL JSONPROP
END

PROCEDURE JSONPROP
[* Output JSON property name
*]
 IF JSONOBJFIRSTPROP=FALSE THEN
  PRINT ","
 PRINT QQ+JSONPROPNAME+QQ+":"
 JSONOBJFIRSTPROP=FALSE
END [PROCEDURE]

[*
**  --------------------------------------------------------------------
**  Debug/Error Processing Procedures
**  --------------------------------------------------------------------
*]

PROCEDURE BNOERRINIT
[* Initialize BNOERR variables
*]

 BNOERRCOUNT=0
 BNOERRMESSAGE=""
 BNOERRDISPLAYMSGCOUNT=0
END [PROCEDURE]

PROCEDURE BNOERRADD
[* Adds an error code to the valid list of error codes
**
**  PASS    BNOERRCODE       Numeric error code
**  PASS    BNOERRMESSAGE    Error description
*]

 IF BNOERRCOUNT<BNOERRMAX THEN
  DO
   BNOERRCOUNT=BNOERRCOUNT+1
   BNOERRCODES(BNOERRCOUNT)=BNOERRCODE
   BNOERRMESSAGES(BNOERRCOUNT)=BNOERRMESSAGE
  END
END [PROCEDURE]

PROCEDURE BNOERRUPDATE
[* Updates an error code error message.  Used to override the error code
** message that was assigned in the SETUP division of the PowerOn.
**
**  PASS    BNOERRCODE       Numeric error code
**  PASS    BNOERRMESSAGE    Error description
*]

 BNOERRTMPCOUNT=1
 BNOERRFOUND=FALSE
 WHILE BNOERRTMPCOUNT<=BNOERRCOUNT AND 
       BNOERRFOUND=FALSE
  DO
   IF BNOERRCODES(BNOERRTMPCOUNT)=BNOERRCODE THEN
    DO
     BNOERRFOUND=TRUE
     BNOERRMESSAGES(BNOERRTMPCOUNT)=BNOERRMESSAGE
    END
   BNOERRTMPCOUNT=BNOERRTMPCOUNT+1
  END
 BNOERRMESSAGE=""
END [PROCEDURE]

PROCEDURE BNOERRGETMESSAGE
[* Gets the error message associated with the BNOERRORCODE
**
**  PASS    BNOERRORCODE     Numeric error code
**  PASS    BNOERRORMODIFIER Msg modifier
**
**  RETURN  BNOERRCODE       Error code
**  RETURN  BNOERRMESSAGE    Error description
**  RETURN  BNOERRMODIFIER   Msg modifier
*]

 BNOERRMESSAGE=BNOERRUNDEFINED
 BNOERRMODIFIER=""
 BNOERRCODE=BNOERRORCODE
 BNOERRTMPCOUNT=1
 WHILE BNOERRTMPCOUNT<=BNOERRCOUNT AND 
       BNOERRMESSAGE=BNOERRUNDEFINED
  DO
   IF BNOERRCODES(BNOERRTMPCOUNT)=BNOERRORCODE THEN
    DO
     BNOERRMESSAGE=BNOERRMESSAGES(BNOERRTMPCOUNT)
     IF BNOERRORMODIFIER<>"" THEN
      BNOERRMODIFIER=BNOERRORMODIFIER
    END 
   BNOERRTMPCOUNT=BNOERRTMPCOUNT+1
  END
END [PROCEDURE]

PROCEDURE BNODEBUGMSGADD
[* Add a message line to the debug message array
**
** PASS    BNODEBUGMSGMAX     Current array index max lines allowed
** PASS    BNODEBUGMSG        Debug message to add to array
**
** RETURN  BNODEBUGCOUNT      Count of debug message lines
** RETURN  BNODEBUGMSGLIST(A) Debug lines of data to print
*]
 IF BNODEBUGCOUNT<BNODEBUGMSGMAX THEN
  DO
   BNODEBUGCOUNT=BNODEBUGCOUNT+1
   BNODEBUGMSGLIST(BNODEBUGCOUNT)=BNODEBUGMSG
   BNODEBUGMSG=""
  END
END [PROCEDURE]

PROCEDURE BNOJSONRGDATA
[* Print @RGUSER[CHR,NUM] data passed from the UX in proper JSON format
**
**  PASS    DEBUGMODE        Boolean: Print debug data, T/F
*]

 IF BNODEBUGMODE=BNODEBUGMODEON THEN
  DO
   JSONPROPNAME="rgData"
   CALL JSONPROP
   CALL JSONARRAY
   NEWLINE
   PRINT QQ+"CHR1:'"+@RGUSERCHR1+"' "+
            "CHR2:'"+@RGUSERCHR2+"'"+QQ+","
   NEWLINE
   PRINT QQ+"CHR3:'"+@RGUSERCHR3+"' "+
            "CHR4:'"+@RGUSERCHR4+"'"+QQ+","
                     
   NEWLINE
   PRINT QQ+"CHR5:'"+@RGUSERCHR5+"' "+
            "NUM1:"+FORMAT("#########9 ",@RGUSERNUM1)+
            "NUM2:"+FORMAT("#########9 ",@RGUSERNUM2)+
            "NUM3:"+FORMAT("#########9 ",@RGUSERNUM3)+
            "NUM4:"+FORMAT("#########9 ",@RGUSERNUM4)+
            "NUM5:"+FORMAT("#########9",@RGUSERNUM5)+QQ
   NEWLINE
   CALL JSONARRAYEND
  END
END [PROCEDURE]

PROCEDURE BNOJSONDEBUGDATA
[* Print debug output in proper JSON format. Requires DEBUGMODE to be
** on (or true).
**
**  PASS  DEBUGMODE           Boolean: Print debug data, T/F
**  PASS  BNODEBUGMSGLIST(A)  Array of debug messages to print
**  PASS  BNODEBUGCOUNT       Number of debug lines to print
*]
 IF BNODEBUGMODE=BNODEBUGMODEON THEN
  DO
   JSONPROPNAME="debugData"
   CALL JSONPROP
   CALL JSONARRAY
   NEWLINE
   PRINT QQ+"Debug note: Debug lines truncated to 126 characters"+QQ
   NEWLINE
   FOR BNODEBUGLOOP=1 TO BNODEBUGCOUNT
    DO
     PRINT ","+QQ+Segment(BNODEBUGMSGLIST(BNODEBUGLOOP),1,126)+QQ
     NEWLINE
    END
   CALL JSONARRAYEND
  END
END [PROCEDURE]

[*
**  --------------------------------------------------------------------
**  Utility Procedures
**  --------------------------------------------------------------------
*]
PROCEDURE BNONLTS
[* Remove leading and trailing spaces
**  PASS       BNOTEXT
**  RETURN     BNOTEXT
*]
 CALL BNONTS
 CALL BNONLS
END [PROCEDURE]

PROCEDURE BNONLS
[* Remove leading spaces
**  PASS       BNOTEXT
**  RETURN     BNOTEXT
*]
 IF LENGTH(BNOTEXT)=0 THEN
  BNOTEXT=""
 ELSE
  DO
   WHILE (LENGTH(BNOTEXT)>0 AND
          SEGMENT(BNOTEXT,1,1)=" ")
    DO
     BNOTEXT=SEGMENT(BNOTEXT,2,LENGTH(BNOTEXT))
    END
  END
END [PROCEDURE]

PROCEDURE BNONTS
[* Remove trailing spaces
**  PASS       BNOTEXT
**  RETURN     BNOTEXT
*]
 IF BNOTEXT<>"" THEN
  BNOTEXT=SEGMENT(BNOTEXT,1,LENGTH(BNOTEXT))
END [PROCEDURE]

PROCEDURE BNONLZ
[* Removes leading zeros. Does not remove leading spaces.
** '00123' results in '123'.
** ' 0123' results in ' 0123'
** '00000' results in ''.
** As a byproduct, trailing spaces are also removed.
**
**  PASS       BNOTEXT
**  RETURN     BNOTEXT
*]
 IF BNOTEXT<>"" THEN
  DO
   WHILE (SEGMENT(BNOTEXT,1,1)="0")
    DO
     IF LENGTH(BNOTEXT)=1 THEN
      BNOTEXT=""
     ELSE
      BNOTEXT=SEGMENT(BNOTEXT,2,LENGTH(BNOTEXT))
    END
  END
END [PROCEDURE]

PROCEDURE BNOAMTTEXT
 
 BNOTEXT=FORMAT("#######9.99",BNOAMT)
 CALL BNONLS
 IF BNOAMT<$0.00 THEN
  BNOTEXT="-"+BNOTEXT
END [PROCEDURE]

PROCEDURE BNOAMTTEXTDISPLAY
 
 BNOTEXT=FORMAT("##,###,##9.99",BNOAMT)
 CALL BNONLS
 BNOTEXT="$"+BNOTEXT
 IF BNOAMT<$0.00 THEN
  BNOTEXT="-"+BNOTEXT
END [PROCEDURE]

PROCEDURE BNORATETEXT
 
 BNOTEXT=FORMAT("##9.999",BNORATE)
 CALL BNONLS
END [PROCEDURE]

PROCEDURE BNORATETEXTDISPLAY
 
 CALL BNORATETEXT
 BNOTEXT=BNOTEXT+"%"
END [PROCEDURE]

PROCEDURE BNOCLEANUPINIT

 LELISTINPUT=BNOCLEANVALIDCHRLIST
 CALL LISTEXPAND
 FOR BNOCLEANLOOP=0 TO BNOCLEANVALIDCHRMAX
  DO
   BNOCLEANVALIDCHRS(BNOCLEANLOOP)=LELIST(BNOCLEANLOOP)
  END
END [PROCEDURE]

PROCEDURE BNOCLEANUPTEXT
[* Check character string and remove out any characters or hidden characters which have an ASCII value
** which is not established in the BNOCLEANVALIDCHRLIST string in the SETUP division . This is to avoid
** display issues with displaying the terms or conditions. Additionally, if a back-slash or double 
** quote is encountered, add a preceding backslash.
**
**  PASS       BNOTEXT   String to test
**  RETURN     BNOTEXT   Updated string
*]
 
 TMPCHR=""
 FOR BNOCLEANLOOP=1 TO LENGTH(BNOTEXT)
  DO
   CHRVAL=CHRVALUE(SEGMENT(BNOTEXT,BNOCLEANLOOP,BNOCLEANLOOP))
   IF  BNOCLEANVALIDCHRS(CHRVAL)=TRUE THEN
    DO
[* Check for back-slash or double-quote. If found, precede with a back-slash
*]
     IF CHRVAL=CHRVALBACKSLASH OR CHRVAL=CHRVALQUOTE THEN
      TMPCHR=TMPCHR+CTRLCHR(CHRVALBACKSLASH)+SEGMENT(BNOTEXT,BNOCLEANLOOP,BNOCLEANLOOP)
     ELSE
      TMPCHR=TMPCHR+SEGMENT(BNOTEXT,BNOCLEANLOOP,BNOCLEANLOOP)
    END
  END
 BNOTEXT=TMPCHR
END [PROCEDURE]

PROCEDURE BNOPARSEDATALINE
[* Parse through a line of delimited data and store individual fields into an array
**
**  PASS    BNODATALINE       Line of data to be parsed
**  PASS    BNODLDELIMITER    Field delimiter (defaults to "|" of not set)
**  RETURN  BNODLFIELD        Array of data elements from the parsed BNODATALINE
**  RETURN  BNODLFIELDCOUNT   Number of elements in the BNODLFIELD array
*]

 IF BNODLDELIMITER="" THEN
  BNODLDELIMITER="|"

 BNODLFIELDCOUNT=0
 FOR BNODLINDEX=0 TO BNODLFIELDMAX
  DO
   BNODLFIELD(BNODLINDEX)=""
  END
 WHILE BNODATALINE<>""
  DO
   BNODLPOS=CHARACTERSEARCH(BNODATALINE,BNODLDELIMITER)
   BNODLFIELDCOUNT=BNODLFIELDCOUNT+1
   IF BNODLPOS=0 THEN
    DO
     BNODLFIELD(BNODLFIELDCOUNT)=BNODATALINE
     BNODATALINE=""
    END
   ELSE
    DO
     BNODLFIELD(BNODLFIELDCOUNT)=SEGMENT(BNODATALINE,1,BNODLPOS-1)
     BNODATALINE=SEGMENT(BNODATALINE,BNODLPOS+1,LENGTH(BNODATALINE))
    END
  END
END [PROCEDURE]

#INCLUDE "RB.LISTEXPAND"
