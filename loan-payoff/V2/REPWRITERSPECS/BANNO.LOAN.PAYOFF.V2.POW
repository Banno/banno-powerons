[*  Copyright 2025 Jack Henry and Associates
**
**  PowerOn Name:                     BANNO.LOAN.PAYOFF.V2.POW
**  Configuration Letterfile Name:    BANNO.LOAN.PAYOFF.V2.CFG
**  Fee Display PowerOn Name:         BANNO.LOAN.PAYOFF.FEES.POW (template)
**
**  --------------------------------------------------------------------
**  Program Summary
**  --------------------------------------------------------------------
**  This Banno service PowerOn allows the user to request a loan
**  payoff for an entered date.
**
**  --------------------------------------------------------------------
**  Program states and JSON returns
**  --------------------------------------------------------------------
**    STATE:  GETPRELOADDATA
**  PROCESS:  Process GETPRELOADDATA state and create json response
**     PASS:  @RGUSERCHR1 10-character member number/account number
**            @RGUSERNUM1 ????
**   RETURN:  Provides UX GETPRELOADDATA response
**
**    STATE:  PERFORMLOANPAYOFFCALC
**  PROCESS:  Process PERFORMLOANPAYOFFCALC state and create json response
**     PASS:  @RGUSERCHR1 10-character member number/account number
**            @RGUSERCHR2 Payoff date in yyyy-mm-dd format
**            @RGUSERNUM1 ????
**   RETURN:  Provides UX PERFORMLOANPAYOFFCALC response
**
**  --------------------------------------------------------------------
**  Error codes and Logging Messages
**  --------------------------------------------------------------------
**  500: Config file open/read error
**  501: Config file validation error
**  502: Duplicate loan type in CFG
**  503: Ineligible Loan Type
**  504: Account Warning Found
**  505: Loan Warning Found
**  506: Loan Projection Error
**  507: Fee Specfile Error
**  508: Payoff date too many days in the future
**  509: Invalid
**
**  --------------------------------------------------------------------
**  Additional Information
**  --------------------------------------------------------------------
**
**  For more information check
**  https://github.com/Banno/banno-powerons
**
**  Banno is not responsible for any modifications to this file
**  made by unauthorized personnel.
**
**  DO NOT MODIFY THIS FILE UNLESS YOU KNOW WHAT YOU'RE DOING!
**
**  --------------------------------------------------------------------
**  Modification History
**    Ver. 2.0.0  11/07/2025 R. Robison: Original V2 version of loan payoff PO
**                           Feature set based on: BANNO.LOAN.PAYOFF.V1.POW Ver. 1.1.1  06/19/24
**    
*]
SYMCONNECT
STATELESS

TARGET=ACCOUNT

DEFINE
 #INCLUDE "RD.GETDATA.DEF"
 #INCLUDE "RB.LISTEXPAND.DEF"

 BNOLASTMODDATE            = '11/07/25'
 BNOLASTMODTIME            = "17:00 MT"
 BNOPROGRAMNAME            = "BANNO.LOAN.PAYOFF.V2.POW"
 BNOCFGFILENAME            = "BANNO.LOAN.PAYOFF.V2.CFG"
 BNOPROGRAMVERSION         = "2.0.0"
 BNOPROGRAMNOTE1           = "New PowerOn"
 BNOPROGRAMNOTE2           = ""

 BNODEBUGPRINTINFODAYS     = 60
 BNODEBUGINCLUDEPARAMS     = 1

 STATEGETPRELOADDATA       = "GETPRELOADDATA"
 STATEPERFORMCALC          = "PERFORMLOANPAYOFFCALC"

[* Error code setup
*]
 BNOERRCODECONFIGREAD      = 500
  BNOERRMODOPEN            = "[configuration file name] open error - [system generated letter file read error message]"
  BNOERRMODREAD            = "[configuration file name] read error - [system generated letter file read error message]"
 BNOERRCODECONFIGVALIDATE  = 501
  BNOERRMODDUPLICATEPARAM  = "Duplicate Param file entry([parameter name])"
  BNOERRMODINVALIDVALUE    = "Invalid Param Value([parameter name])"
 BNOERRCODEDUPLOANTYPE     = 502
  BNOERRMODDUPLOANTYPE     = "Loan Type [4-digit loan type] ([parameter name])")
 BNOERRCODEINELIGLOANTYPE  = 503
  BNOERRMODINELIGLOANTYPE  = "[4-digit loan type]"
 BNOERRCODEACCTWARNING     = 504
  BNOERRMODACCTWARNING     = "[3-digit comma separated account warning list]"
 BNOERRCODELOANWARNING     = 505
  BNOERRMODLOANWARNING     = "[3-digit comma separated loan warning list]"
 BNOERRCODELOANPROJECT     = 506
  BNOERRMODLOANPROJECT     = "[system generated PowerOn function LOANPROJECTCALC error message]"
 BNOERRCODEFEESPECFILE     = 507
  BNOERRMODFEESPECFILE     = "[Banno loan payoff fees PowerOn generated error message]"
 BNOERRCODEBADPAYOFFDATE   = 508
 BNOERRCODEINVALID         = 509

Payoff date too many days in the future
[* RGUSER Pass variables - passed from UX code
*]
 RGLANGUAGE=NUMBER
 RGMEMBERNUMBER=CHARACTER(10)
 RGPAYOFFDATE=DATE

[* Main data structures for PowerOn data/json
*]
 INTERESTDESC=CHARACTER(12) ARRAY(8) 
 INVALIDWARNLIST=CHARACTER

[* CFG Parameter variables specific to this PowerOn
*]
 PARAMELIGLOANTYPELIST=CHARACTER
 PARAMELIGLOANTYPES=NUMBER ARRAY(9999)
 PARAMHLT="HLT"
 PARAMHOMELOANTYPELIST=CHARACTER
 PARAMHOMELOANTYPES=NUMBER ARRAY(9999)
 PARAMBLT="BLT"
 PARAMBOATLOANTYPELIST=CHARACTER
 PARAMBOATLOANTYPES=NUMBER ARRAY(9999)
 PARAMVLT="VLT"
 PARAMVEHLOANTYPELIST=CHARACTER
 PARAMVEHLOANTYPES=NUMBER ARRAY(9999)
 PARAMSLT="SLT"
 PARAMSECUREDLOANTYPELIST=CHARACTER
 PARAMSECUREDLOANTYPES=NUMBER ARRAY(9999)

 PARAMLOANWARNLIST=CHARACTER
 PARAMLOANWARNCODES=NUMBER ARRAY(99)
 PARAMACCTWARNLIST=CHARACTER
 PARAMACTTWARNCODES=NUMBER ARRAY(99)

 PARAMPAYOFFFEESFNAME=CHARACTER
 PARAMFUTUREDAYSMAX=NUMBER
 PARAMBOATLOANTT=NUMBER
 PARAMBOATLOANTFLD=CHARACTER
 PARAMVEHLOANTT=NUMBER
 PARAMVEHLOANTFLD=CHARACTER ARRAY(3)
 PARAMVEHLOANTLBL=CHARACTER ARRAY(3)
 PARAMVEHCTLCOUNT=NUMBER
 PARAMVEHCTLMAX=3

[* CFG Parameter variables -- common
*]
 PARAMLANGSPANISH=NUMBER
 PARAMDEBUGMODE=NUMBER
 PARAMTESTMODE=NUMBER
 PARAMTESTEC=NUMBER
 PARAMPROGINSTALLDATE=DATE

[* CFG Parameter variables for soft text messages
*]
 PARAMMSGTAGSMAX=20
 PARAMMSGTAGSCOUNT=NUMBER
 PARAMMSGTAG=CHARACTER
 PARAMMSGPROP=CHARACTER
 PARAMMSGOPT=NUMBER
 PARAMMSGMAXLINES=NUMBER
 PARAMMSGTAGLANG=NUMBER

 PARAMMSGTAGS=CHARACTER ARRAY(20)
 PARAMMSGPROPS=CHARACTER ARRAY(20)
 PARAMMSGOPTIONAL=NUMBER ARRAY(20)
 PARAMMSGDEFINED=NUMBER ARRAY(20)
 PARAMMSGMAX=NUMBER ARRAY(20)
 PARAMMSGALLMAX=800
 PARAMMSGALL=CHARACTER ARRAY(800)
 PARAMMSGALLTAGS=CHARACTER ARRAY(800)
 PARAMMSGALLTAGSLANG=NUMBER ARRAY(800)
 PARAMMSGTAGNONE=0
 PARAMMSGTAGENGLISH=1
 PARAMMSGTAGSPANISH=2
 PARAMMSGTAGENGLISHSFX="_EN"
 PARAMMSGTAGSPANISHSFX="_SP"
 PARAMMSGALLCOUNT=NUMBER
 PARAMMSGTAGFOUND=NUMBER
 PARAMMSGTAGINDEX=NUMBER
 PARAMMSGALLINDEX=NUMBER
 PARAMMSGDEFAULTMAX=20 [each message can be up to 20 lines long by default]

[* CFG Parameter variables for errorDispalyMessages (EDM)
*] 
 PARAMERRDISPLAYMAX=200
 PARAMERRDISPLAYERRCODES=NUMBER ARRAY(200)
 PARAMERRDISPLAYLINES=CHARACTER ARRAY(200)
 PARAMERRDISPLAYLANG=NUMBER ARRAY(200)
 PARAMERRDISPLAYCOUNT=NUMBER
 PARAMERRDISPLAYINDEX=NUMBER

[* CFG Parameter processing - general
*]
 BNOCFGPARAMMAX=200
 BNOCFGPARAMCOUNT=NUMBER
 BNOCFGPARAM=CHARACTER ARRAY(200)
 BNOCFGPARAMVAL=CHARACTER ARRAY(200)
 BNOCFGFILENUMBER=NUMBER
 BNOCFGFILEFERROR=CHARACTER
 BNOCFGFILELINE=CHARACTER
 BNOCFGPARAMALLOWDUPS=NUMBER

 BNOPARAMFOUND=NUMBER
 BNOPARAMFOUNDINDEX=NUMBER
 BNOPARAMFIND=CHARACTER
 BNOPARAMVAL=CHARACTER
 BNOPARAMTMP=CHARACTER
 BNOPARAMVALTMP=CHARACTER
 BNOPARAMLOOP=NUMBER

[* Debug handling variables
*]
 BNODEBUGMSGMAX=999
 BNODEBUGMSGLIST=CHARACTER ARRAY(999)
 BNODEBUGLOOP=NUMBER
 BNODEBUGCOUNT=NUMBER
 BNODEBUGMSG=CHARACTER
 BNODEBUGMODE=NUMBER

[* Error handling variables
*]
 BNOERRMAX=99
 BNOERRCODE=NUMBER
 BNOERRMESSAGE=CHARACTER
 BNOERRMODIFIER=CHARACTER
 BNOERRCOUNT=NUMBER
 BNOERRTMPCOUNT=NUMBER
 BNOERRTMPCOUNT2=NUMBER
 BNOERRDISPLAYLIST=CHARACTER
 BNOERRDISPLAYCODE=NUMBER
 BNOERRFOUND=NUMBER
 BNOERRCODES=NUMBER ARRAY(99)
 BNOERRMESSAGES=CHARACTER ARRAY(99)
 BNOERRUNDEFINED="**Undefined**"

 BNOERRDISPLAYMSGSMAX=5
 BNOERRDISPLAYMSG=CHARACTER ARRAY(5)
 BNOERRDISPLAYMSGCOUNT=NUMBER
 BNOERRDISPLAYLINE=CHARACTER

[* Misc. Variables
*]
 BNOTEXT=CHARACTER
 BNOTMPLOOP=NUMBER
 BNOPOS=NUMBER 
 BNOERRORCODE=NUMBER
 BNOERRORMODIFIER=CHARACTER
 BNOIDLENGTH=NUMBER
 BNOSLTYPELENGTH=NUMBER

 JSONBOOLEAN=CHARACTER ARRAY(1)
 JSONPROPNAME=CHARACTER
 JSONOBJFIRSTPROP=NUMBER

 TMPLOOP=NUMBER
 TMPLOOP2=NUMBER
 TMPCHR=CHARACTER
 QQ=CHARACTER
 TMPERRCODE=NUMBER
 TMPDISPLAYLINE=CHARACTER
 CHRVAL=NUMBER
 TMPLINECOUNT=NUMBER
 LINECOUNT=NUMBER
 MSGTAGSELECTED=NUMBER
 MSGPROPSELECT=CHARACTER
 MSGPROPSELECTLIST=CHARACTER
 TAGSFXPOS=NUMBER
 TMPINDEX=NUMBER
 
 SYMXINSTANCE=NUMBER
 SYMXCLIENTNUM=NUMBER

[* BNOPARSEDATALINE variables
*]
 BNODATALINE=CHARACTER
 BNODLINDEX=NUMBER
 BNODLFIELDCOUNT=NUMBER
 BNODLFIELD=CHARACTER ARRAY(99)
 BNODLFIELDMAX=99
 BNODLPOS=NUMBER
 BNODLDELIMITER=CHARACTER

[* BNOCLEANUP variables
*]
 BNOCLEANLOOP=NUMBER
 BNOCLEANVALIDCHRLIST="32-126,128-175,181-184,189,190,198,199,208-216,221,222,224-253"
 BNOCLEANVALIDCHRS=NUMBER ARRAY(255)
 BNOCLEANVALIDCHRMAX=255

[* Replace variables
*]
 TRUE=1
 FALSE=0
 DATENULL='--/--/--'
 BNODEBUGMODEOFF=0
 BNODEBUGMODEON=1
 BNODEBUGMODEUNDEFINED=9999

 LOANTYPESMAX=9999
 WARNINGCODESMAX=99

 CHRVALQUOTE=34
 CHRVALBACKSLASH=92
END [DEFINE]

SETUP
 CALL BNOERRINIT

[* Register supported error messages
*] 
 BNOERRCODE=BNOERRCODECONFIGREAD          BNOERRMESSAGE="Config file open/read error"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODECONFIGVALIDATE      BNOERRMESSAGE="Config file validation error"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEDUPLOANTYPE         BNOERRMESSAGE="Duplicate loan type in CFG"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEINELIGLOANTYPE      BNOERRMESSAGE="Ineligible Loan Type"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEACCTWARNING         BNOERRMESSAGE="Account Warning Found"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODELOANWARNING         BNOERRMESSAGE="Loan Warning Found"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODELOANPROJECT         BNOERRMESSAGE="Loan Projection Error"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEFEESPECFILE         BNOERRMESSAGE="Fee Specfile Error"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEBADPAYOFFDATE       BNOERRMESSAGE="Payoff date too many days in the future"
 CALL BNOERRADD
 BNOERRCODE=BNOERRCODEINVALID             BNOERRMESSAGE="Invalid"
 CALL BNOERRADD


 [* Set any errors that support display messages
 *]
 [BNOERRDISPLAYCODE=BNOERRCODEMEMOMODE
 CALL BNOERRDISPLAYLISTADD]

[* This is where you define all the soft text CFG tags and json properties
**  - Optionally set PARAMMSGMAXLINES to override the default of 20 lines per message
**  - Optionally set PARAMMSGOPT to mark a message as optional. Message will not be returned in
**.   json response if no message lines found in the CFG.
*]
 CALL PARAMMSGINIT
 PARAMMSGTAG="TC"     PARAMMSGPROP="disclaimerText"     [Disclaimer Text Message]
 PARAMMSGMAXLINES=40
 
 CALL PARAMMSGTAGADD
 PARAMMSGTAG="CS"     PARAMMSGPROP="summaryText"        [Summary Text Message]
 PARAMMSGMAXLINES=40
 PARAMMSGOPT=TRUE
 CALL PARAMMSGTAGADD

 CALL SETUPDATA
END [SETUP]

PRINT TITLE=BNOPROGRAMNAME

 CALL INITIALIZEDATA
 CALL GETRGDATA

 CALL BNOCFGFILEREAD

 IF BNOERRORCODE=0 THEN
  CALL BNOSETPARAMVALS

 IF BNOERRORCODE=0 THEN
  CALL PARAMPOSTPROCESS

 IF BNOERRORCODE=0 AND
    PARAMTESTMODE=TRUE THEN
  BNOERRORCODE=PARAMTESTEC

 IF BNOERRORCODE=0 AND PARAMTESTMODE=FALSE THEN
  DO
   IF @RGSTATE=STATEGETPRELOADDATA THEN
    DO
     BNOERRORCODE=0
    END
   ELSE IF @RGSTATE=STATEPERFORMCALC THEN
    DO
     BNOERRORCODE=0
    END  
  END  

[* Output JSON 
*]
 CALL JSONOPEN
 
 IF @RGSTATE=STATEGETPRELOADDATA THEN
  DO
   IF BNOERRORCODE=0 THEN
    CALL JSONSUCCESSPRELOADDATA
   ELSE 
    CALL JSONERROR
  END
 ELSE IF @RGSTATE=STATEPERFORMCALC THEN
  DO
   IF BNOERRORCODE=0 THEN
    CALL JSONSUCCESSPROCESSDATA
   ELSE 
    CALL JSONERROR
  END 

 CALL BNOCFGDEBUGADD
 CALL BNOJSONRGDATA
 CALL BNOJSONDEBUGDATA
 IF BNODEBUGMODE=BNODEBUGMODEOFF THEN
  NEWLINE
 
 CALL JSONCLOSE
END [PRINT]

PROCEDURE SETUPDATA
[* Set the SETUP data constants
*]
 JSONBOOLEAN(TRUE)="true"
 JSONBOOLEAN(FALSE)="false"

 INTERESTDESC(0)="Daily"
 INTERESTDESC(1)="360 Day"
 INTERESTDESC(2)="365.25 Day"
 INTERESTDESC(3)="Daily Billed"
 INTERESTDESC(4)="Daily Billed"
 INTERESTDESC(5)="Actual/360"
 INTERESTDESC(6)="Daily Billed 360"
 INTERESTDESC(7)="Actual/364"
 INTERESTDESC(8)="Scheduled/364"
 
[* This is the default state of debug mode.  This may be overriden if the Program Install Date (PID)
** is set in the CFG configuration file.
*] 
 IF BNOLASTMODDATE+BNODEBUGPRINTINFODAYS>SYSTEMDATE THEN
  BNODEBUGMODE=BNODEBUGMODEON
 ELSE 
  BNODEBUGMODE=BNODEBUGMODEOFF 

 SYMXINSTANCE=@SYMXINSTANCEID
 SYMXCLIENTNUM=@CLIENTNUMBER
 BNOIDLENGTH=GETDATANUMBER(GETPARAMIDLENGTH)
 BNOSLTYPELENGTH=GETDATANUMBER(GETPARAMTYPELENGTH)

 QQ=CTRLCHR(CHRVALQUOTE)
 CALL BNOCLEANUPINIT
END [PROCEDURE]

PROCEDURE INITIALIZEDATA
[* Initialize variables
*]

 BNOERRORCODE=0
 BNOERRORMODIFIER=""
 BNOCFGPARAMALLOWDUPS=FALSE
 JSONOBJFIRSTPROP=TRUE
 BNODLDELIMITER=""
 MSGPROPSELECTLIST=""
END [PROCEDURE]

PROCEDURE GETRGDATA
[* Read in the @RG values from the UX, segment them into their individual
** values.
*]
 RGLANGUAGE=@RGSESSION
 RGMEMBERNUMBER=SEGMENT(@RGUSERCHR1,1,10)
 RGSLID=SEGMENT(@RGUSERCHR1,12,LENGTH(@RGUSERCHR1))
 RGSLID="0000"+RGSLID
 RGSLID=SEGMENT(RGSLID,(LENGTH(RGSLID)-SLIDLEN)+1,LENGTH(RGSLID))
 IF @RGSTATE=STATEGETPRELOADDATA THEN
  DO
[* Nothing to do here. RGMEMBERNUMBER and RGSLID set for all states
*]  
  END
 ELSE IF @RGSTATE=STATEPERFORMCALC THEN
  DO
   RGPAYOFFDATE=DATEVALUE(@RGUSERCHR2)
  END
END [PROCEDURE]

PROCEDURE VALIDATEPAYOFFDATA

 INVALIDWARNLIST=""

 IF RGPAYOFFDATE>SYSTEMDATE+PARAMFUTUREDAYSMAX THEN
  BNOERRORCODE=BNOERRCODEBADPAYOFFDATE

 IF BNOERRORCODE=0 THEN
  DO
   LOANFOUND=FALSE
   FOR ACCOUNT WITH NUMBER RGMEMBERNUMBER
    DO
[* Check for invalid account warnings
*]    
     TMPLOOP=1
     WHILE TMPLOOP<=WARNINGCODESMAX
      DO
       IF ANYWARNING(ACCOUNT,TMPLOOP) AND
          PARAMACTTWARNCODES(TMPLOOP)=TRUE THEN
        DO
         IF INVALIDWARNLIST<>"" THEN
             INVALIDWARNLIST=INVALIDWARNLIST+","
          INVALIDWARNLIST=INVALIDWARNLIST+FORMAT("999",TMPLOOP)
        END  
       TMPLOOP=TMPLOOP+1
      END

     IF INVALIDWARNLIST<>"" THEN
      DO
       BNOERRORCODE=BNOERRCODEACCTWARNING
       BNOERRORMODIFIER=BNOERRMODACCTWARNING
       BNOERRORMODIFIER=INVALIDWARNLIST
      END 

     IF BNOERRORCODE=0 THEN
      DO
       FOR EACH LOAN WITH (LOAN:ID=RGSLID)
        DO
         LOANFOUND=TRUE
         IF PARAMELIGLOANTYPELIST(LOAN:TYPE)=FALSE THEN
          DO
           BNOERRORCODE=BNOERRCODEINELIGLOANTYPE
           BNOERRORMODIFIER=BNOERRMODINELIGLOANTYPE
           BNOERRORMODIFIER=FORMAT("9999",LOAN:TYPE)
          END
         
        IF BNOERRORCODE=0 THEN
         DO
          TMPLOOP=1
          WHILE TMPLOOP<=WARNINGCODESMAX
           DO
            IF ANYWARNING(LOAN,TMPLOOP) AND
               PARAMLOANWARNCODES(TMPLOOP)=TRUE THEN
             DO
              IF INVALIDWARNLIST<>"" THEN
               INVALIDWARNLIST=INVALIDWARNLIST+","
              INVALIDWARNLIST=INVALIDWARNLIST+FORMAT("999",TMPLOOP)
             END  
            TMPLOOP=TMPLOOP+1
           END
  
          IF INVALIDWARNLIST<>"" THEN
           DO
            BNOERRORCODE=BNOERRCODELOANWARNING
            BNOERRORMODIFIER=BNOERRMODLOANWARNING
            BNOERRORMODIFIER=INVALIDWARNLIST
           END 
         END
        
        END
       UNTIL LOANFOUND=TRUE 
      END
    END

   IF BNOERRORCODE=0 AND
      LOANFOUND=FALSE THEN
    BNOERRORCODE=BNOERRORCODE=BNOERRCODEINVALID
  END
END [PROCEDURE]

PROCEDURE MSGPROPSELECTADD
[* Call before JSONMSGARRAYS to selectively output soft text/message properties.
** This may be multiple times with different MSGPROPSELECT values to select and output
** multiple soft text properties.  JSONMSGARRAYS will output all defined soft text messages
** if this procuedure is not called prior to JSONMSGARRAYS.
** Example:
**
**  MSGPROPSELECT="informationMsg"
**  CALL MSGPROPSELECTADD
**  CALL JSONMSGARRAYS
**
**  PASS    MSGPROPSELECT      The json property name for soft text that should be selected
**  
**  RETURN  MSGPROPSELECTLIST  Updated list
*]

 IF MSGPROPSELECTLIST<>"" THEN
  MSGPROPSELECTLIST=MSGPROPSELECTLIST+","
 MSGPROPSELECTLIST=MSGPROPSELECTLIST+MSGPROPSELECT 
END

[*
**  --------------------------------------------------------------------
**  Config File Procedures
**  --------------------------------------------------------------------
*]

PROCEDURE PARAMMSGINIT

 PARAMMSGTAGSCOUNT=0
 PARAMMSGOPT=FALSE
 PARAMMSGMAXLINES=0
 FOR PARAMMSGTAGINDEX=1 TO PARAMMSGTAGSMAX
  DO
   PARAMMSGOPTIONAL(PARAMMSGTAGINDEX)=FALSE
   PARAMMSGDEFINED(PARAMMSGTAGINDEX)=FALSE
   PARAMMSGMAX(PARAMMSGTAGINDEX)=PARAMMSGDEFAULTMAX
  END
END [PROCEDURE] 

PROCEDURE PARAMMSGTAGADD

 IF PARAMMSGTAGSCOUNT<PARAMMSGTAGSMAX THEN
  DO
   PARAMMSGTAGSCOUNT=PARAMMSGTAGSCOUNT+1
   PARAMMSGTAGS(PARAMMSGTAGSCOUNT)=PARAMMSGTAG 
   PARAMMSGPROPS(PARAMMSGTAGSCOUNT)=PARAMMSGPROP
   PARAMMSGOPTIONAL(PARAMMSGTAGSCOUNT)=PARAMMSGOPT
   IF PARAMMSGMAXLINES<>0 THEN 
    PARAMMSGMAX(PARAMMSGTAGSCOUNT)=PARAMMSGMAXLINES
   
   PARAMMSGOPT=FALSE
   PARAMMSGMAXLINES=0
  END
END [PROCEDURE]

PROCEDURE BNOINITPARAMVALS
[* Initialize parameter/cfg variables
*]
 PARAMELIGLOANTYPELIST=""
 PARAMHOMELOANTYPELIST=""
 PARAMBOATLOANTYPELIST=""
 PARAMVEHLOANTYPELIST=""
 PARAMSECUREDLOANTYPELIST=""
 FOR TMPLOOP=0 TO LOANTYPESMAX
  DO
   PARAMELIGLOANTYPES(TMPLOOP)=FALSE
   PARAMHOMELOANTYPES(TMPLOOP)=FALSE
   PARAMBOATLOANTYPES(TMPLOOP)=FALSE
   PARAMVEHLOANTYPES(TMPLOOP)=FALSE
   PARAMSECUREDLOANTYPES(TMPLOOP)=FALSE
  END

 PARAMLOANWARNLIST=""
 PARAMACCTWARNLIST=""
 FOR TMPLOOP=0 TO WARNINGCODESMAX
  DO
   PARAMLOANWARNCODES(TMPLOOP)=FALSE
   PARAMACTTWARNCODES(TMPLOOP)=FALSE
  END 

 PARAMPAYOFFFEESFNAME=""
 PARAMFUTUREDAYSMAX=90
 PARAMBOATLOANTT=30
 PARAMBOATLOANTFLD=""
 PARAMVEHLOANTT=30
 PARAMVEHCTLCOUNT=0
 FOR TMPLOOP=1 TO PARAMVEHCTLMAX
  DO
   PARAMVEHLOANTFLD(TMPLOOP)=""
   PARAMVEHLOANTLBL(TMPLOOP)=""
  END
 
 PARAMERRDISPLAYCOUNT=0
 PARAMLANGSPANISH=FALSE
 PARAMDEBUGMODE=BNODEBUGMODEUNDEFINED
 PARAMTESTMODE=FALSE
 PARAMTESTEC=0
 PARAMPROGINSTALLDATE=DATENULL
END [PROCEDURE]

PROCEDURE BNOSETPARAMVALS
[* Assign parameter settings retrieved from the configuration Letter
** file to variables for use throughout the program
*]
 CALL BNOINITPARAMVALS

 CALL GETPARAMMSGS

[* Get any display error messages if configured in CFG file
*]
 CALL GETERRORDISPLAYMESSAGES

[* Type lists
*]
 BNOPARAMFIND="LT"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMELIGLOANTYPELIST=BNOPARAMVAL

 BNOPARAMFIND=PARAMHLT
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMHOMELOANTYPELIST=BNOPARAMVAL

 BNOPARAMFIND=PARAMBLT
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMBOATLOANTYPELIST=BNOPARAMVAL

 BNOPARAMFIND=PARAMVLT
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMVEHLOANTYPELIST=BNOPARAMVAL

 BNOPARAMFIND=PARAMSLT
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMSECUREDLOANTYPELIST=BNOPARAMVAL      

[* Warning code lists
*]
 BNOPARAMFIND="LW"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMLOANWARNLIST=BNOPARAMVAL

 BNOPARAMFIND="AW"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMACCTWARNLIST=BNOPARAMVAL  

[* Misc parameters
*]
 BNOPARAMFIND="FD"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMFUTUREDAYSMAX=VALUE(BNOPARAMVAL)

 BNOPARAMFIND="FSN"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMPAYOFFFEESFNAME=BNOPARAMVAL

[*Collateral parametrs
*]
 BNOPARAMFIND="BTT"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMBOATLOANTT=VALUE(BNOPARAMVAL)

 BNOPARAMFIND="BCTL"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMBOATLOANTFLD=BNOPARAMVAL

 BNOPARAMFIND="VTT"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMVEHLOANTT=VALUE(BNOPARAMVAL)

 FOR BNOPARAMLOOP=1 TO BNOCFGPARAMCOUNT
  DO
   IF SEGMENT(BNOCFGPARAM(BNOPARAMLOOP),1,4)="VCTL" THEN
    DO
     BNOPARAMTMP=BNOCFGPARAM(BNOPARAMLOOP)
     CALL PARAMEXTRACTLANG
     TMPINDEX=VALUE(SEGMENT(BNOPARAMTMP,5,5))
     IF TMPINDEX>=1 AND TMPINDEX<=PARAMVEHCTLMAX THEN
      DO
       BNOTEXT=BNOCFGPARAMVAL(BNOPARAMLOOP)
       CALL BNONTS
       PARAMVEHLOANTFLD(TMPINDEX)=BNOTEXT
       IF TMPINDEX>PARAMVEHCTLCOUNT THEN
        PARAMVEHCTLCOUNT=TMPINDEX
      END
    END
  END

 FOR BNOPARAMLOOP=1 TO BNOCFGPARAMCOUNT
  DO
   IF SEGMENT(BNOCFGPARAM(BNOPARAMLOOP),1,6)="VCTLLB" THEN
    DO
     BNOPARAMTMP=BNOCFGPARAM(BNOPARAMLOOP)
[**TODO** Still need to add language support here]     
     CALL PARAMEXTRACTLANG
     TMPINDEX=VALUE(SEGMENT(BNOPARAMTMP,7,7))
     IF TMPINDEX>=1 AND TMPINDEX<=PARAMVEHCTLMAX THEN
      DO
       BNOTEXT=BNOCFGPARAMVAL(BNOPARAMLOOP)
       CALL BNONTS
       PARAMVEHLOANTLBL(TMPINDEX)=BNOTEXT
       IF TMPINDEX>PARAMVEHCTLCOUNT THEN
        PARAMVEHCTLCOUNT=TMPINDEX
      END
    END
  END 

[* Common parameters
*]
 BNOPARAMFIND="SLS"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  DO
   IF CHARACTERSEARCH("TRUEYES1ON",BNOPARAMVAL)>0 THEN
    PARAMLANGSPANISH=TRUE
   ELSE 
    PARAMLANGSPANISH=FALSE 
  END

 BNOPARAMFIND="PID"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  PARAMPROGINSTALLDATE=DATEVALUE(BNOPARAMVAL)

[* Test parameters
*]
 BNOPARAMFIND="DEBUGMODE"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE AND BNOPARAMVAL<>"" THEN
  DO
   IF CHARACTERSEARCH("TRUEYES1ON",BNOPARAMVAL)>0 THEN
    PARAMDEBUGMODE=BNODEBUGMODEON
   ELSE 
    PARAMDEBUGMODE=BNODEBUGMODEOFF 
  END

 BNOPARAMFIND="TESTMODE"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE THEN
  DO
   IF CHARACTERSEARCH("TRUEYES1ON",BNOPARAMVAL)>0 THEN
    PARAMTESTMODE=TRUE
  END

 BNOPARAMFIND="TESTEC"
 CALL BNOGETPARAMVAL
 IF BNOPARAMFOUND=TRUE AND
    BNOPARAMVAL<>"" THEN
  PARAMTESTEC=VALUE(BNOPARAMVAL)
END [PROCEDURE]

PROCEDURE PARAMPOSTPROCESS
[* Post-processing of the param/cfg variables
*]

[* Expand all the loan type lists
*]
 LELISTINPUT=PARAMELIGLOANTYPELIST
 IF LELISTINPUT="" THEN
  LELISTINPUT="NONE"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO LOANTYPESMAX
  DO
   PARAMELIGLOANTYPES(TMPLOOP)=LELIST(TMPLOOP)
  END
 
 LELISTINPUT=PARAMHOMELOANTYPELIST
 IF LELISTINPUT="" THEN
  LELISTINPUT="NONE"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO LOANTYPESMAX
  DO
   PARAMHOMELOANTYPES(TMPLOOP)=LELIST(TMPLOOP)
  END

 LELISTINPUT=PARAMBOATLOANTYPELIST
 IF LELISTINPUT="" THEN
  LELISTINPUT="NONE"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO LOANTYPESMAX
  DO
   PARAMBOATLOANTYPES(TMPLOOP)=LELIST(TMPLOOP)
  END

 LELISTINPUT=PARAMVEHLOANTYPELIST
 IF LELISTINPUT="" THEN
  LELISTINPUT="NONE"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO LOANTYPESMAX
  DO
   PARAMVEHLOANTYPES(TMPLOOP)=LELIST(TMPLOOP)
  END

 LELISTINPUT=PARAMSECUREDLOANTYPELIST
 IF LELISTINPUT="" THEN
  LELISTINPUT="NONE"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO LOANTYPESMAX
  DO
   PARAMSECUREDLOANTYPES(TMPLOOP)=LELIST(TMPLOOP)
  END

[* Expand the warning code lists
*]
 LELISTINPUT=PARAMLOANWARNLIST
 IF LELISTINPUT="" THEN
  LELISTINPUT="NONE"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO WARNINGCODESMAX
  DO
   PARAMLOANWARNCODES(TMPLOOP)=LELIST(TMPLOOP)
  END

 LELISTINPUT=PARAMACCTWARNLIST
 IF LELISTINPUT="" THEN
  LELISTINPUT="NONE"
 CALL LISTEXPAND
 FOR TMPLOOP=0 TO WARNINGCODESMAX
  DO
   PARAMACTTWARNCODES(TMPLOOP)=LELIST(TMPLOOP)
  END

[* Check for duplicate loan types in CFG
*]
 TMPLOOP=1
 WHILE TMPLOOP<=LOANTYPESMAX AND
       BNOERRORCODE=0
  DO
   IF PARAMHOMELOANTYPES(TMPLOOP)=TRUE THEN
    BNOPARAMTMP=PARAMHLT
   IF PARAMBOATLOANTYPES(TMPLOOP)=TRUE THEN
    BNOPARAMTMP=PARAMBLT
   IF PARAMVEHLOANTYPES(TMPLOOP)=TRUE THEN
    BNOPARAMTMP=PARAMVLT
   IF PARAMSECUREDLOANTYPES(TMPLOOP)=TRUE THEN
    BNOPARAMTMP=PARAMSLT

   IF PARAMHOMELOANTYPES(TMPLOOP)+PARAMBOATLOANTYPES(TMPLOOP)+
      PARAMVEHLOANTYPES(TMPLOOP)+PARAMSECUREDLOANTYPES(TMPLOOP)>1 THEN
    DO
     BNOERRORCODE=BNOERRCODEDUPLOANTYPE
     BNOERRORMODIFIER=BNOERRMODDUPLOANTYPE
     BNOERRORMODIFIER=FORMAT("Loan Type 9999",TMPLOOP)+" ("+BNOPARAMTMP+")"
    END

   TMPLOOP=TMPLOOP+1
  END

[* Adjust debug mode
*]
 IF PARAMDEBUGMODE<>BNODEBUGMODEUNDEFINED THEN
  BNODEBUGMODE=PARAMDEBUGMODE
 ELSE IF PARAMPROGINSTALLDATE<>DATENULL THEN
  DO
   IF PARAMPROGINSTALLDATE+BNODEBUGPRINTINFODAYS>SYSTEMDATE THEN
    BNODEBUGMODE=BNODEBUGMODEON
   ELSE 
    BNODEBUGMODE=BNODEBUGMODEOFF 
  END 
END [PROCEDURE]

PROCEDURE GETPARAMMSGS

 PARAMMSGALLCOUNT=0
 FOR BNOPARAMLOOP=1 TO BNOCFGPARAMCOUNT
  DO
   PARAMMSGTAGINDEX=1 
   PARAMMSGTAGFOUND=FALSE
   WHILE PARAMMSGTAGINDEX<=PARAMMSGTAGSCOUNT AND PARAMMSGTAGFOUND=FALSE
    DO
     BNOPARAMTMP=BNOCFGPARAM(BNOPARAMLOOP)
     CALL PARAMEXTRACTLANG
     IF PARAMMSGTAGS(PARAMMSGTAGINDEX)=BNOPARAMTMP THEN
      DO
       PARAMMSGTAGFOUND=TRUE
       IF BNOCFGPARAMVAL(BNOPARAMLOOP)<>"" THEN
        PARAMMSGDEFINED(PARAMMSGTAGINDEX)=TRUE

       IF PARAMMSGALLCOUNT<PARAMMSGALLMAX THEN
        DO
         PARAMMSGALLCOUNT=PARAMMSGALLCOUNT+1
         PARAMMSGALLTAGSLANG(PARAMMSGALLCOUNT)=PARAMMSGTAGLANG
         PARAMMSGALLTAGS(PARAMMSGALLCOUNT)=BNOPARAMTMP
         BNOTEXT=BNOCFGPARAMVAL(BNOPARAMLOOP)
         CALL BNOCLEANUPTEXT
         PARAMMSGALL(PARAMMSGALLCOUNT)=BNOTEXT
        END 
      END
     PARAMMSGTAGINDEX=PARAMMSGTAGINDEX+1
    END
  END
END [PROCEDURE]

PROCEDURE BNOCFGFILEREAD
[* Open and read through the parameter file to create an array of
** parameter names and associated values.
**
**  PASS    BCFGFILENAME      Parameter Letter file name
**  PASS    BNOCFGPARAMMAX    Maximum number of parameters
**  
**  RETURN  BNOCFGFILEFERROR  File open/read error
**  RETURN  BNOERRORCODE      Error code
**  RETURN  BNOCFGPARAM(A)    Parameter Name
**  RETURN  BNOCFGPARAMVAL(A) Parameter Value
**  RETURN  BNOCFGPARAMCOUNT  Parameters Found
**
*]
 BNOCFGPARAMALLOWDUPS=TRUE
 BNOCFGFILEFERROR=""
 BNOCFGPARAMCOUNT=0
 WHILELIMIT=1000000
 FILEOPEN("LETTER",BNOCFGFILENAME,"READ",BNOCFGFILENUMBER,BNOCFGFILEFERROR)
 IF BNOCFGFILEFERROR<>"" THEN
  DO
   BNOERRORCODE=BNOERRCODECONFIGREAD
   BNOERRORMODIFIER=BNOERRMODOPEN
   BNOERRORMODIFIER=BNOCFGFILENAME+" open error - "+BNOCFGFILEFERROR
   BNODEBUGMSG="Error opening CFG param file: "+BNOCFGFILEFERROR
   CALL BNODEBUGMSGADD
  END
 ELSE
  DO
   WHILE BNOCFGFILEFERROR="" AND BNOCFGPARAMCOUNT<BNOCFGPARAMMAX 
    DO
     FILEREADLINE(BNOCFGFILENUMBER,BNOCFGFILELINE,BNOCFGFILEFERROR)
     IF BNOCFGFILEFERROR<>"" AND
        BNOCFGFILEFERROR<>"EOF" THEN
      DO
       BNOERRORCODE=BNOERRCODECONFIGREAD
       BNOERRORMODIFIER=BNOERRMODREAD
       BNOERRORMODIFIER=BNOCFGFILENAME+" read error - "+BNOCFGFILEFERROR
       BNODEBUGMSG="Error reading CFG param file: "+BNOCFGFILEFERROR
       CALL BNODEBUGMSGADD
      END
     ELSE
      DO
       BNOPOS=CHARACTERSEARCH(BNOCFGFILELINE,":")
       IF SEGMENT(BNOCFGFILELINE,1,1)<>"*" AND BNOPOS>1 THEN
        DO
         BNOTEXT=SEGMENT(BNOCFGFILELINE,1,BNOPOS-1)
         CALL BNONLTS
         BNOPARAMTMP=BNOTEXT

         BNOTEXT=SEGMENT(BNOCFGFILELINE,BNOPOS+1,LENGTH(BNOCFGFILELINE))
         CALL BNONLS
         BNOPARAMVALTMP=BNOTEXT

         BNOPARAMFOUND=FALSE
         IF BNOCFGPARAMALLOWDUPS=FALSE THEN 
          DO
           FOR BNOTMPLOOP=1 TO BNOCFGPARAMCOUNT
            DO
             IF BNOCFGPARAM(BNOTMPLOOP)=BNOPARAMTMP THEN
              BNOPARAMFOUND=TRUE
            END
           IF BNOPARAMFOUND=TRUE THEN
            DO
             BNOERRORCODE=BNOERRCODECONFIGVALIDATE
             BNOERRORMODIFIER=BNOERRMODDUPLICATEPARAM
             BNOERRORMODIFIER="Duplicate Param file entry("+BNOPARAMTMP+")"
             BNODEBUGMSG="Duplicate Param file entry: "+BNOPARAMTMP
             CALL BNODEBUGMSGADD
            END
          END

         IF BNOPARAMFOUND=FALSE THEN
          DO
           BNOCFGPARAMCOUNT=BNOCFGPARAMCOUNT+1
           BNOCFGPARAM(BNOCFGPARAMCOUNT)=BNOPARAMTMP
           BNOCFGPARAMVAL(BNOCFGPARAMCOUNT)=BNOPARAMVALTMP
          END
        END  [IF SEGMENT(BNOCFGFILELINE,1,1)<>"*"]
      END  [IF BNOCFGFILEFERROR=""]
    END  [WHILE BNOCFGFILEFERROR=""]
  END

 FILECLOSE(BNOCFGFILENUMBER,BNOCFGFILEFERROR)
END [PROCEDURE]

PROCEDURE BNOCFGDEBUGADD
[* Add CFG lines to debug
*]

 IF BNODEBUGMODE=BNODEBUGMODEON AND
    BNODEBUGINCLUDEPARAMS=TRUE THEN
  DO
   FOR TMPLOOP=1 TO BNOCFGPARAMCOUNT
    DO
     BNOTEXT=BNOCFGPARAMVAL(TMPLOOP)
     CALL BNOCLEANUPTEXT
     BNODEBUGMSG="PARAM:"+BNOCFGPARAM(TMPLOOP)+"-"+
                  BNOTEXT
     CALL BNODEBUGMSGADD
    END
  END
END [PROCEDURE]

PROCEDURE BNOGETPARAMVAL
[* Find requested parameter setting and return value.
**
**  PASS    BNOPARAMFIND   Targeted parameter setting
**  
**  RETURN  BNOPARAMFOUND  T/F found flag
**  RETURN  BNOPARAMVAL    Parameter value found
*] 
 BNOPARAMFOUND=FALSE
 FOR BNOPARAMLOOP=1 TO BNOCFGPARAMCOUNT
  DO
   IF BNOCFGPARAM(BNOPARAMLOOP)=BNOPARAMFIND THEN
    DO
     BNOPARAMVAL=BNOCFGPARAMVAL(BNOPARAMLOOP)
     BNOPARAMFOUND=TRUE
     BNOPARAMLOOP=BNOCFGPARAMCOUNT
    END
  END
END [PROCEDURE]

PROCEDURE GETERRORDISPLAYMESSAGES
[* Find the error display lines
*] 
 
 FOR BNOPARAMLOOP=1 TO BNOCFGPARAMCOUNT
  DO
   IF SEGMENT(BNOCFGPARAM(BNOPARAMLOOP),1,3)="EDM" THEN
    DO
     BNOPARAMTMP=BNOCFGPARAM(BNOPARAMLOOP)
     CALL PARAMEXTRACTLANG
     TMPERRCODE=VALUE(SEGMENT(BNOPARAMTMP,4,6))
     IF CHARACTERSEARCH(BNOERRDISPLAYLIST,FORMAT("999",TMPERRCODE))>0 THEN
      DO
       BNOTEXT=BNOCFGPARAMVAL(BNOPARAMLOOP)
       CALL BNONTS
       CALL BNOCLEANUPTEXT
       TMPDISPLAYLINE=BNOTEXT
       CALL PARAMERRDISPLAYADD
      END
    END
  END
END [PROCEDURE]

PROCEDURE PARAMEXTRACTLANG
[* Extract language suffix and set PARAMMSGTAGLANG.  Return updated BNOPARAMTMP variable.
*]

 PARAMMSGTAGLANG=PARAMMSGTAGENGLISH
 TAGSFXPOS=CHARACTERSEARCH(BNOPARAMTMP,PARAMMSGTAGENGLISHSFX)
 IF TAGSFXPOS<>0 AND
    TAGSFXPOS=LENGTH(BNOPARAMTMP)-2 THEN
  BNOPARAMTMP=SEGMENT(BNOPARAMTMP,1,LENGTH(BNOPARAMTMP)-3)
 TAGSFXPOS=CHARACTERSEARCH(BNOPARAMTMP,PARAMMSGTAGSPANISHSFX)
 IF TAGSFXPOS<>0 AND
    TAGSFXPOS=LENGTH(BNOPARAMTMP)-2 THEN
  DO
   BNOPARAMTMP=SEGMENT(BNOPARAMTMP,1,LENGTH(BNOPARAMTMP)-3)
   PARAMMSGTAGLANG=PARAMMSGTAGSPANISH
  END 
END [PROCEDURE]

PROCEDURE PARAMERRDISPLAYADD

 IF PARAMERRDISPLAYCOUNT<PARAMERRDISPLAYMAX THEN
  DO
   PARAMERRDISPLAYCOUNT=PARAMERRDISPLAYCOUNT+1
   PARAMERRDISPLAYERRCODES(PARAMERRDISPLAYCOUNT)=TMPERRCODE
   PARAMERRDISPLAYLANG(PARAMERRDISPLAYCOUNT)=PARAMMSGTAGLANG
   BNOTEXT=TMPDISPLAYLINE
   CALL BNONTS
   PARAMERRDISPLAYLINES(PARAMERRDISPLAYCOUNT)=BNOTEXT
  END
END [PROCEDURE]

PROCEDURE BNOERRDISPLAYLISTADD
[* Add to the list of errors that support error display messages.  Used to 
** register those error codes that support display messages.
*]

 IF BNOERRDISPLAYLIST<>"" THEN
  BNOERRDISPLAYLIST=BNOERRDISPLAYLIST+","
 BNOERRDISPLAYLIST=BNOERRDISPLAYLIST+FORMAT("999",BNOERRDISPLAYCODE)
END [PROCEDURE]

PROCEDURE GETBNOERRDISPLAYMSG

 PARAMERRDISPLAYINDEX=1
 BNOERRDISPLAYMSGCOUNT=0
 WHILE PARAMERRDISPLAYINDEX<=PARAMERRDISPLAYCOUNT AND
       BNOERRDISPLAYMSGCOUNT<BNOERRDISPLAYMSGSMAX
  DO
   IF PARAMERRDISPLAYERRCODES(PARAMERRDISPLAYINDEX)=BNOERRCODE AND
      PARAMERRDISPLAYLANG(PARAMERRDISPLAYINDEX)=PARAMMSGTAGLANG THEN
    DO
     BNOERRDISPLAYMSGCOUNT=BNOERRDISPLAYMSGCOUNT+1
     BNOERRDISPLAYMSG(BNOERRDISPLAYMSGCOUNT)=PARAMERRDISPLAYLINES(PARAMERRDISPLAYINDEX)
    END  
   PARAMERRDISPLAYINDEX=PARAMERRDISPLAYINDEX+1
  END

 IF BNOERRDISPLAYMSGCOUNT=1 AND
    BNOERRDISPLAYMSG(1)="" THEN
  BNOERRDISPLAYMSGCOUNT=0  
END [PROCEDURE]

[*
**  --------------------------------------------------------------------
**  JSON Procedures
**  --------------------------------------------------------------------
*]

PROCEDURE JSONERROR
[* Output the JSON for an error response
*]

 CALL BNOERRGETMESSAGE

 JSONPROPNAME="results"
 CALL JSONPROPFIRST
 CALL JSONOBJ
 NEWLINE
 
 JSONOBJFIRSTPROP=TRUE
 CALL JSONGENERALSPECS

 JSONPROPNAME="errorCode"
 CALL JSONPROP
 PRINT FORMAT("999",BNOERRCODE)
 NEWLINE

 JSONPROPNAME="errorMessage"
 CALL JSONPROP
 PRINT QQ+BNOERRMESSAGE
 IF BNOERRMODIFIER<>"" THEN
  PRINT ": "+BNOERRMODIFIER
 PRINT QQ
 NEWLINE

 PARAMMSGTAGLANG=PARAMMSGTAGENGLISH
 IF PARAMLANGSPANISH=TRUE THEN
  PARAMMSGTAGLANG=RGLANGUAGE 
 CALL GETBNOERRDISPLAYMSG

[* Fall back to English message if no Spanish message defined for the error display message
*]
 IF BNOERRDISPLAYMSGCOUNT=0 AND
    PARAMMSGTAGLANG=PARAMMSGTAGSPANISH THEN
  DO
   PARAMMSGTAGLANG=PARAMMSGTAGENGLISH
   CALL GETBNOERRDISPLAYMSG
  END  
 
 IF BNOERRDISPLAYMSGCOUNT>0 THEN
  DO
   JSONPROPNAME="errorDisplayMessage"
   CALL JSONPROP

   CALL JSONARRAY
   FOR TMPLOOP=1 TO BNOERRDISPLAYMSGCOUNT
    DO
     BNOTEXT=BNOERRDISPLAYMSG(TMPLOOP)
     CALL BNONTS
     PRINT QQ+BNOTEXT+QQ
     IF TMPLOOP<BNOERRDISPLAYMSGCOUNT THEN
      PRINT ","
     NEWLINE
    END
   CALL JSONARRAYEND
  END

 CALL JSONOBJEND [results property]
END [PROCEDURE]

PROCEDURE JSONSUCCESSPRELOADDATA
[* Output the JSON for successful responses in the PRELOADDATA state
*]

 JSONPROPNAME="results"
 CALL JSONPROPFIRST
 CALL JSONOBJ
 NEWLINE

 JSONOBJFIRSTPROP=TRUE
 CALL JSONGENERALSPECS

 PARAMMSGTAGLANG=PARAMMSGTAGENGLISH
 IF PARAMLANGSPANISH=TRUE THEN
  PARAMMSGTAGLANG=RGLANGUAGE 
 CALL JSONMSGARRAYS

 CALL JSONOBJEND [END results property]
END [PROCEDURE]

PROCEDURE JSONSUCCESSPROCESSDATA
[* Output the JSON for successful responses in the PROCESSDATA state
*]

 JSONPROPNAME="results"
 CALL JSONPROPFIRST
 CALL JSONOBJ
 NEWLINE

 JSONOBJFIRSTPROP=TRUE
 CALL JSONGENERALSPECS

 JSONPROPNAME="success"
 CALL JSONPROP
 PRINT JSONBOOLEAN(TRUE)
 NEWLINE

 CALL JSONOBJEND [END results property]
END [PROCEDURE]

PROCEDURE JSONGENERALSPECS
[* Output the generalSpecifications JSON object
*]

 JSONPROPNAME="generalSpecifications"
 CALL JSONPROP
 CALL JSONOBJ
 NEWLINE

 JSONOBJFIRSTPROP=TRUE
 CALL JSONPROGRAMINFO
 CALL JSONSYSTEMINFO

 CALL JSONOBJEND
END [PROCEDURE]

PROCEDURE JSONPROGRAMINFO
[* Output the programInfo JSON object
*]

 JSONPROPNAME="programInfo"
 CALL JSONPROP
 CALL JSONOBJ
 NEWLINE

 JSONPROPNAME="name"
 CALL JSONPROPFIRST
 PRINT QQ+BNOPROGRAMNAME+QQ
 NEWLINE
 JSONPROPNAME="version"
 CALL JSONPROP
 PRINT QQ+BNOPROGRAMVERSION+QQ
 NEWLINE
 JSONPROPNAME="lastModDate"
 CALL JSONPROP
 PRINT QQ+FORMAT("99/99/99 ",BNOLASTMODDATE)+BNOLASTMODTIME+QQ
 NEWLINE
 IF BNOPROGRAMNOTE1<>"" THEN
  DO
   JSONPROPNAME="note1"
   CALL JSONPROP
   PRINT QQ+BNOPROGRAMNOTE1+QQ
   NEWLINE
  END 
 IF BNOPROGRAMNOTE2<>"" THEN
  DO
   JSONPROPNAME="note2"
   CALL JSONPROP
   PRINT QQ+BNOPROGRAMNOTE2+QQ
   NEWLINE
  END 

 CALL JSONOBJEND
END [PROCEDURE]

PROCEDURE JSONSYSTEMINFO
[* Output the systemInfo JSON object
*]

 JSONPROPNAME="systemInfo"
 CALL JSONPROP
 CALL JSONOBJ
 NEWLINE

 JSONPROPNAME="systemDate"
 CALL JSONPROPFIRST
 PRINT QQ+FORMAT("99/99/9999",SYSTEMDATE)+QQ
 NEWLINE

 JSONPROPNAME="slidLength"
 CALL JSONPROP
 PRINT BNOIDLENGTH
 NEWLINE

 JSONPROPNAME="memoMode"
 CALL JSONPROP
 PRINT JSONBOOLEAN(SYSMEMOMODE)
 NEWLINE

 CALL JSONOBJEND
END [PROCEDURE]

PROCEDURE JSONMSGARRAYS
 
 PARAMMSGTAGINDEX=1 
 WHILE PARAMMSGTAGINDEX<=PARAMMSGTAGSCOUNT
  DO
   MSGTAGSELECTED=FALSE
   IF PARAMMSGOPTIONAL(PARAMMSGTAGINDEX)=FALSE OR
     (PARAMMSGOPTIONAL(PARAMMSGTAGINDEX)=TRUE AND
      PARAMMSGDEFINED(PARAMMSGTAGINDEX)=TRUE) THEN
    MSGTAGSELECTED=TRUE

   IF MSGTAGSELECTED=TRUE AND
      PARAMMSGPROPS(PARAMMSGTAGINDEX)="" THEN
    MSGTAGSELECTED=FALSE

   IF MSGTAGSELECTED=TRUE THEN
    DO
     IF MSGPROPSELECTLIST<>"" AND
        CHARACTERSEARCH(MSGPROPSELECTLIST,PARAMMSGPROPS(PARAMMSGTAGINDEX))=0 THEN
      MSGTAGSELECTED=FALSE  
    END

   IF MSGTAGSELECTED=TRUE THEN 
    DO
     JSONPROPNAME=PARAMMSGPROPS(PARAMMSGTAGINDEX)
     CALL JSONPROP
     CALL JSONARRAY
     NEWLINE
  
     LINECOUNT=0
     FOR PARAMMSGALLINDEX=1 TO PARAMMSGALLCOUNT
      DO
       IF PARAMMSGALLTAGSLANG(PARAMMSGALLINDEX)=PARAMMSGTAGLANG AND
          PARAMMSGALLTAGS(PARAMMSGALLINDEX)=PARAMMSGTAGS(PARAMMSGTAGINDEX) AND
          LINECOUNT<PARAMMSGMAX(PARAMMSGTAGINDEX) THEN
        DO
         LINECOUNT=LINECOUNT+1
         IF LINECOUNT<>1 THEN
          PRINT ","
         PRINT QQ+PARAMMSGALL(PARAMMSGALLINDEX)+QQ
         NEWLINE 
        END
      END
     CALL JSONARRAYEND
    END  
   
   PARAMMSGTAGINDEX=PARAMMSGTAGINDEX+1
  END

 MSGPROPSELECTLIST="" 
END [PROCEDURE]

[*
**  --------------------------------------------------------------------
**  JSON Procedures - Common
**  --------------------------------------------------------------------
*]
PROCEDURE JSONOPEN
[* Output JSON open char
*]
 PRINT "{"
 NEWLINE
END [PROCEDURE]

PROCEDURE JSONCLOSE
[* Output JSON close char
*]
 PRINT "}"
 NEWLINE
END [PROCEDURE]

PROCEDURE JSONOBJ
[* Output JSON object open char
*]
 PRINT "{"
END [PROCEDURE]

PROCEDURE JSONOBJEND
[* Output JSON object close char
*]
 PRINT "}"
 NEWLINE
END [PROCEDURE]

PROCEDURE JSONARRAY
[* Output JSON array open char
*]
 PRINT "["
END [PROCEDURE]

PROCEDURE JSONARRAYEND
[* Output JSON array close char
*]
 PRINT "]"
 NEWLINE
END [PROCEDURE]

PROCEDURE JSONPROPFIRST
 JSONOBJFIRSTPROP=TRUE
 CALL JSONPROP
END

PROCEDURE JSONPROP
[* Output JSON property name
*]
 IF JSONOBJFIRSTPROP=FALSE THEN
  PRINT ","
 PRINT QQ+JSONPROPNAME+QQ+":"
 JSONOBJFIRSTPROP=FALSE
END [PROCEDURE]

[*
**  --------------------------------------------------------------------
**  Debug/Error Processing Procedures
**  --------------------------------------------------------------------
*]

PROCEDURE BNOERRINIT
[* Initialize BNOERR variables
*]

 BNOERRCOUNT=0
 BNOERRMESSAGE=""
 BNOERRDISPLAYMSGCOUNT=0
END [PROCEDURE]

PROCEDURE BNOERRADD
[* Adds an error code to the valid list of error codes
**
**  PASS    BNOERRCODE       Numeric error code
**  PASS    BNOERRMESSAGE    Error description
*]

 IF BNOERRCOUNT<BNOERRMAX THEN
  DO
   BNOERRCOUNT=BNOERRCOUNT+1
   BNOERRCODES(BNOERRCOUNT)=BNOERRCODE
   BNOERRMESSAGES(BNOERRCOUNT)=BNOERRMESSAGE
  END
END [PROCEDURE]

PROCEDURE BNOERRUPDATE
[* Updates an error code error message.  Used to override the error code
** message that was assigned in the SETUP division of the PowerOn.
**
**  PASS    BNOERRCODE       Numeric error code
**  PASS    BNOERRMESSAGE    Error description
*]

 BNOERRTMPCOUNT=1
 BNOERRFOUND=FALSE
 WHILE BNOERRTMPCOUNT<=BNOERRCOUNT AND 
       BNOERRFOUND=FALSE
  DO
   IF BNOERRCODES(BNOERRTMPCOUNT)=BNOERRCODE THEN
    DO
     BNOERRFOUND=TRUE
     BNOERRMESSAGES(BNOERRTMPCOUNT)=BNOERRMESSAGE
    END
   BNOERRTMPCOUNT=BNOERRTMPCOUNT+1
  END
 BNOERRMESSAGE=""
END [PROCEDURE]

PROCEDURE BNOERRGETMESSAGE
[* Gets the error message associated with the BNOERRORCODE
**
**  PASS    BNOERRORCODE     Numeric error code
**  PASS    BNOERRORMODIFIER Msg modifier
**
**  RETURN  BNOERRCODE       Error code
**  RETURN  BNOERRMESSAGE    Error description
**  RETURN  BNOERRMODIFIER   Msg modifier
*]

 BNOERRMESSAGE=BNOERRUNDEFINED
 BNOERRMODIFIER=""
 BNOERRCODE=BNOERRORCODE
 BNOERRTMPCOUNT=1
 WHILE BNOERRTMPCOUNT<=BNOERRCOUNT AND 
       BNOERRMESSAGE=BNOERRUNDEFINED
  DO
   IF BNOERRCODES(BNOERRTMPCOUNT)=BNOERRORCODE THEN
    DO
     BNOERRMESSAGE=BNOERRMESSAGES(BNOERRTMPCOUNT)
     IF BNOERRORMODIFIER<>"" THEN
      BNOERRMODIFIER=BNOERRORMODIFIER
    END 
   BNOERRTMPCOUNT=BNOERRTMPCOUNT+1
  END
END [PROCEDURE]

PROCEDURE BNODEBUGMSGADD
[* Add a message line to the debug message array
**
** PASS    BNODEBUGMSGMAX     Current array index max lines allowed
** PASS    BNODEBUGMSG        Debug message to add to array
**
** RETURN  BNODEBUGCOUNT      Count of debug message lines
** RETURN  BNODEBUGMSGLIST(A) Debug lines of data to print
*]
 IF BNODEBUGCOUNT<BNODEBUGMSGMAX THEN
  DO
   BNODEBUGCOUNT=BNODEBUGCOUNT+1
   BNODEBUGMSGLIST(BNODEBUGCOUNT)=BNODEBUGMSG
   BNODEBUGMSG=""
  END
END [PROCEDURE]

PROCEDURE BNOJSONRGDATA
[* Print @RGUSER[CHR,NUM] data passed from the UX in proper JSON format
**
**  PASS    DEBUGMODE        Boolean: Print debug data, T/F
*]

 IF BNODEBUGMODE=BNODEBUGMODEON THEN
  DO
   JSONPROPNAME="rgData"
   CALL JSONPROP
   CALL JSONARRAY
   NEWLINE
   PRINT QQ+"CHR1:'"+@RGUSERCHR1+"' "+
            "CHR2:'"+@RGUSERCHR2+"'"+QQ+","
   NEWLINE
   PRINT QQ+"CHR3:'"+@RGUSERCHR3+"' "+
            "CHR4:'"+@RGUSERCHR4+"'"+QQ+","
                     
   NEWLINE
   PRINT QQ+"CHR5:'"+@RGUSERCHR5+"' "+
            "NUM1:"+FORMAT("#########9 ",@RGUSERNUM1)+
            "NUM2:"+FORMAT("#########9 ",@RGUSERNUM2)+
            "NUM3:"+FORMAT("#########9 ",@RGUSERNUM3)+
            "NUM4:"+FORMAT("#########9 ",@RGUSERNUM4)+
            "NUM5:"+FORMAT("#########9",@RGUSERNUM5)+QQ
   NEWLINE
   CALL JSONARRAYEND
  END
END [PROCEDURE]

PROCEDURE BNOJSONDEBUGDATA
[* Print debug output in proper JSON format. Requires DEBUGMODE to be
** on (or true).
**
**  PASS  DEBUGMODE           Boolean: Print debug data, T/F
**  PASS  BNODEBUGMSGLIST(A)  Array of debug messages to print
**  PASS  BNODEBUGCOUNT       Number of debug lines to print
*]
 IF BNODEBUGMODE=BNODEBUGMODEON THEN
  DO
   JSONPROPNAME="debugData"
   CALL JSONPROP
   CALL JSONARRAY
   NEWLINE
   PRINT QQ+"Debug note: Debug lines truncated to 126 characters"+QQ
   NEWLINE
   FOR BNODEBUGLOOP=1 TO BNODEBUGCOUNT
    DO
     PRINT ","+QQ+Segment(BNODEBUGMSGLIST(BNODEBUGLOOP),1,126)+QQ
     NEWLINE
    END
   CALL JSONARRAYEND
  END
END [PROCEDURE]

[*
**  --------------------------------------------------------------------
**  Utility Procedures
**  --------------------------------------------------------------------
*]
PROCEDURE BNONLTS
[* Remove leading and trailing spaces
**  PASS       BNOTEXT
**  RETURN     BNOTEXT
*]
 CALL BNONTS
 CALL BNONLS
END [PROCEDURE]

PROCEDURE BNONLS
[* Remove leading spaces
**  PASS       BNOTEXT
**  RETURN     BNOTEXT
*]
 IF LENGTH(BNOTEXT)=0 THEN
  BNOTEXT=""
 ELSE
  DO
   WHILE (LENGTH(BNOTEXT)>0 AND
          SEGMENT(BNOTEXT,1,1)=" ")
    DO
     BNOTEXT=SEGMENT(BNOTEXT,2,LENGTH(BNOTEXT))
    END
  END
END [PROCEDURE]

PROCEDURE BNONTS
[* Remove trailing spaces
**  PASS       BNOTEXT
**  RETURN     BNOTEXT
*]
 IF BNOTEXT<>"" THEN
  BNOTEXT=SEGMENT(BNOTEXT,1,LENGTH(BNOTEXT))
END [PROCEDURE]

PROCEDURE BNONLZ
[* Removes leading zeros. Does not remove leading spaces.
** '00123' results in '123'.
** ' 0123' results in ' 0123'
** '00000' results in ''.
** As a byproduct, trailing spaces are also removed.
**
**  PASS       BNOTEXT
**  RETURN     BNOTEXT
*]
 IF BNOTEXT<>"" THEN
  DO
   WHILE (SEGMENT(BNOTEXT,1,1)="0")
    DO
     IF LENGTH(BNOTEXT)=1 THEN
      BNOTEXT=""
     ELSE
      BNOTEXT=SEGMENT(BNOTEXT,2,LENGTH(BNOTEXT))
    END
  END
END [PROCEDURE]

PROCEDURE BNOCLEANUPINIT

 LELISTINPUT=BNOCLEANVALIDCHRLIST
 CALL LISTEXPAND
 FOR BNOCLEANLOOP=0 TO BNOCLEANVALIDCHRMAX
  DO
   BNOCLEANVALIDCHRS(BNOCLEANLOOP)=LELIST(BNOCLEANLOOP)
  END
END [PROCEDURE]

PROCEDURE BNOCLEANUPTEXT
[* Check character string and remove out any characters or hidden characters which have an ASCII value
** which is not established in the BNOCLEANVALIDCHRLIST string in the SETUP division . This is to avoid
** display issues with displaying the terms or conditions. Additionally, if a back-slash or double 
** quote is encountered, add a preceding backslash.
**
**  PASS       BNOTEXT   String to test
**  RETURN     BNOTEXT   Updated string
*]
 
 TMPCHR=""
 FOR BNOCLEANLOOP=1 TO LENGTH(BNOTEXT)
  DO
   CHRVAL=CHRVALUE(SEGMENT(BNOTEXT,BNOCLEANLOOP,BNOCLEANLOOP))
   IF  BNOCLEANVALIDCHRS(CHRVAL)=TRUE THEN
    DO
[* Check for back-slash or double-quote. If found, precede with a back-slash
*]
     IF CHRVAL=CHRVALBACKSLASH OR CHRVAL=CHRVALQUOTE THEN
      TMPCHR=TMPCHR+CTRLCHR(CHRVALBACKSLASH)+SEGMENT(BNOTEXT,BNOCLEANLOOP,BNOCLEANLOOP)
     ELSE
      TMPCHR=TMPCHR+SEGMENT(BNOTEXT,BNOCLEANLOOP,BNOCLEANLOOP)
    END
  END
 BNOTEXT=TMPCHR
END [PROCEDURE]

PROCEDURE BNOPARSEDATALINE
[* Parse through a line of delimited data and store individual fields into an array
**
**  PASS    BNODATALINE       Line of data to be parsed
**  PASS    BNODLDELIMITER    Field delimiter (defaults to "|" of not set)
**  RETURN  BNODLFIELD        Array of data elements from the parsed BNODATALINE
**  RETURN  BNODLFIELDCOUNT   Number of elements in the BNODLFIELD array
*]

 IF BNODLDELIMITER="" THEN
  BNODLDELIMITER="|"

 BNODLFIELDCOUNT=0
 FOR BNODLINDEX=0 TO BNODLFIELDMAX
  DO
   BNODLFIELD(BNODLINDEX)=""
  END
 WHILE BNODATALINE<>""
  DO
   BNODLPOS=CHARACTERSEARCH(BNODATALINE,BNODLDELIMITER)
   BNODLFIELDCOUNT=BNODLFIELDCOUNT+1
   IF BNODLPOS=0 THEN
    DO
     BNODLFIELD(BNODLFIELDCOUNT)=BNODATALINE
     BNODATALINE=""
    END
   ELSE
    DO
     BNODLFIELD(BNODLFIELDCOUNT)=SEGMENT(BNODATALINE,1,BNODLPOS-1)
     BNODATALINE=SEGMENT(BNODATALINE,BNODLPOS+1,LENGTH(BNODATALINE))
    END
  END
END [PROCEDURE]

#INCLUDE "RB.LISTEXPAND"
